
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>larch.dataset &#8212; v5.7.0</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet">
  <link href="../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/larch-book.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="shortcut icon" href="../../_static/larch_favicon.png"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    
      
      <link rel="icon" sizes="32x32" href="../../_static/img/larch_favicon.png">
      
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/larch-logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">v5.7.0</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search these docs..." aria-label="Search these docs..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Users Guide
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../installation.html">
   Installing Larch
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../user-guide/choice-models.html">
   Choice Models
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../user-guide/data-fundamentals.html">
     Data Fundamentals
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../user-guide/linear-funcs.html">
     Linear Functions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../user-guide/machine-learning.html">
     Machine Learning
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../bibliography.html">
   References
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  API Reference
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../api/~data.html">
   Data
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/dataset.html">
     Dataset
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
    <label for="toctree-checkbox-3">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.Dataset.html">
       larch.Dataset
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.Dataset.construct.html">
       larch.Dataset.construct
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.Dataset.dims.html">
       larch.Dataset.dims
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.Dataset.sizes.html">
       larch.Dataset.sizes
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.Dataset.data_vars.html">
       larch.Dataset.data_vars
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.Dataset.coords.html">
       larch.Dataset.coords
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.Dataset.attrs.html">
       larch.Dataset.attrs
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.Dataset.encoding.html">
       larch.Dataset.encoding
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.Dataset.indexes.html">
       larch.Dataset.indexes
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.Dataset.chunks.html">
       larch.Dataset.chunks
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.Dataset.chunksizes.html">
       larch.Dataset.chunksizes
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.Dataset.nbytes.html">
       larch.Dataset.nbytes
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.Dataset.set_dtypes.html">
       larch.Dataset.set_dtypes
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/datatree.html">
     DataTree
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
    <label for="toctree-checkbox-4">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.DataTree.html">
       larch.DataTree
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.DataTree.root_node_name.html">
       larch.DataTree.root_node_name
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.DataTree.subspaces.html">
       larch.DataTree.subspaces
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.DataTree.relationships_are_digitized.html">
       larch.DataTree.relationships_are_digitized
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.DataTree.n_cases.html">
       larch.DataTree.n_cases
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.DataTree.n_alts.html">
       larch.DataTree.n_alts
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.DataTree.CASEID.html">
       larch.DataTree.CASEID
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.DataTree.ALTID.html">
       larch.DataTree.ALTID
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.DataTree.add_dataset.html">
       larch.DataTree.add_dataset
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.DataTree.add_relationship.html">
       larch.DataTree.add_relationship
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.DataTree.digitize_relationships.html">
       larch.DataTree.digitize_relationships
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.DataTree.query_cases.html">
       larch.DataTree.query_cases
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.DataTree.replace_datasets.html">
       larch.DataTree.replace_datasets
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.DataTree.setup_flow.html">
       larch.DataTree.setup_flow
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/dataframes.html">
     DataFrames
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
    <label for="toctree-checkbox-5">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.DataFrames.html">
       larch.DataFrames
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../api/~models.html">
   Models
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/model.html">
     Model
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
    <label for="toctree-checkbox-7">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.html">
       larch.numba.Model
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.datatree.html">
       larch.numba.Model.datatree
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.dataset.html">
       larch.numba.Model.dataset
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.n_cases.html">
       larch.numba.Model.n_cases
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.choice_ca_var.html">
       larch.numba.Model.choice_ca_var
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.choice_co_vars.html">
       larch.numba.Model.choice_co_vars
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.choice_co_code.html">
       larch.numba.Model.choice_co_code
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.availability_ca_var.html">
       larch.numba.Model.availability_ca_var
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.availability_co_vars.html">
       larch.numba.Model.availability_co_vars
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.utility_ca.html">
       larch.numba.Model.utility_ca
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.utility_co.html">
       larch.numba.Model.utility_co
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.quantity_ca.html">
       larch.numba.Model.quantity_ca
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.pf.html">
       larch.numba.Model.pf
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.most_recent_estimation_result.html">
       larch.numba.Model.most_recent_estimation_result
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.possible_overspecification.html">
       larch.numba.Model.possible_overspecification
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.set_values.html">
       larch.numba.Model.set_values
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.lock_value.html">
       larch.numba.Model.lock_value
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.set_cap.html">
       larch.numba.Model.set_cap
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.remove_unused_parameters.html">
       larch.numba.Model.remove_unused_parameters
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.maximize_loglike.html">
       larch.numba.Model.maximize_loglike
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.calculate_parameter_covariance.html">
       larch.numba.Model.calculate_parameter_covariance
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.loglike_nil.html">
       larch.numba.Model.loglike_nil
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.loglike_null.html">
       larch.numba.Model.loglike_null
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.rho_sq_nil.html">
       larch.numba.Model.rho_sq_nil
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.rho_sq_null.html">
       larch.numba.Model.rho_sq_null
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.parameter_summary.html">
       larch.numba.Model.parameter_summary
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.estimation_statistics.html">
       larch.numba.Model.estimation_statistics
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.to_xlsx.html">
       larch.numba.Model.to_xlsx
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.bhhh.html">
       larch.numba.Model.bhhh
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.check_d_loglike.html">
       larch.numba.Model.check_d_loglike
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.d_loglike.html">
       larch.numba.Model.d_loglike
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.d_loglike_casewise.html">
       larch.numba.Model.d_loglike_casewise
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.loglike.html">
       larch.numba.Model.loglike
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.loglike_casewise.html">
       larch.numba.Model.loglike_casewise
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.logsums.html">
       larch.numba.Model.logsums
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.probability.html">
       larch.numba.Model.probability
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.quantity.html">
       larch.numba.Model.quantity
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.total_weight.html">
       larch.numba.Model.total_weight
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.numba.Model.utility.html">
       larch.numba.Model.utility
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../api/linear.html">
     Linear Functions
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/nesting.html">
     NestingTree
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
    <label for="toctree-checkbox-8">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.model.tree.NestingTree.html">
       larch.model.tree.NestingTree
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.model.tree.NestingTree.new_node.html">
       larch.model.tree.NestingTree.new_node
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.model.tree.NestingTree.add_node.html">
       larch.model.tree.NestingTree.add_node
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.model.tree.NestingTree.remove_node.html">
       larch.model.tree.NestingTree.remove_node
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.model.tree.NestingTree.add_edge.html">
       larch.model.tree.NestingTree.add_edge
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.model.tree.NestingTree.remove_edge.html">
       larch.model.tree.NestingTree.remove_edge
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/modelgroup.html">
     ModelGroup
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
    <label for="toctree-checkbox-9">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.model.model_group.ModelGroup.html">
       larch.model.model_group.ModelGroup
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.model.model_group.ModelGroup.n_cases.html">
       larch.model.model_group.ModelGroup.n_cases
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.model.model_group.ModelGroup.set_values.html">
       larch.model.model_group.ModelGroup.set_values
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.model.model_group.ModelGroup.total_weight.html">
       larch.model.model_group.ModelGroup.total_weight
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.model.model_group.ModelGroup.loglike.html">
       larch.model.model_group.ModelGroup.loglike
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.model.model_group.ModelGroup.loglike2.html">
       larch.model.model_group.ModelGroup.loglike2
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../api/generated/larch.model.model_group.ModelGroup.to_xlsx.html">
       larch.model.model_group.ModelGroup.to_xlsx
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Examples
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../example/mtc.html">
   MTC Mode Choice
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../example/000_mtc_data.html">
     MTC Work Mode Choice Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../example/001_mnl.html">
     1: MTC MNL Mode Choice
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../example/002_mtc.html">
     2: MTC MNL Mode Choice, Motorized
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../example/017A_mnl_segmented.html">
     17a: Market Segmentatation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../example/017_mnl_final.html">
     17: MTC Expanded MNL Mode Choice
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../example/022-nl.html">
     22: MTC Motorized and Non-Motorized Nested Mode Choice
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../example/028-nl.html">
     28: MTC Motorized - Shared Ride - Non-Motorized Nested Mode Choice
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../example/swissmetro.html">
   Swissmetro
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/>
  <label for="toctree-checkbox-11">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../example/101_swissmetro_mnl.html">
     101: Swissmetro MNL Mode Choice
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../example/102-swissmetro-weighted.html">
     102: Swissmetro Weighted MNL Mode Choice
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../example/109-swissmetro-nl.html">
     109: Swissmetro Nested Logit Mode Choice
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../example/exampville.html">
   Exampville
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/>
  <label for="toctree-checkbox-12">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../example/200_exampville.html">
     200: Exampville Simulated Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../example/201_exville_mode_choice.html">
     201: Exampville Mode Choice
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../example/202_exville_mc_logsums.html">
     202: Exampville Mode Choice Logsums
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../example/203_exville_dest.html">
     203: Exampville Destination Choice
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../example/itinerary.html">
   Itinerary Choice
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/>
  <label for="toctree-checkbox-13">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../example/300_itinerary.html">
     300: Itinerary Choice Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../example/301_itin_mnl.html">
     301: Itinerary Choice using MNL
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../example/legacy.html">
   Legacy Examples
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" type="checkbox"/>
  <label for="toctree-checkbox-14">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../example/legacy/mtc.html">
     MTC Mode Choice Examples
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" type="checkbox"/>
    <label for="toctree-checkbox-15">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/000_mtc_data.html">
       MTC Work Mode Choice Data
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/001.mtc.html">
       1: MTC MNL Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/002_mtc.html">
       2: MTC MNL Mode Choice, Motorized
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/003_mtc.html">
       3: MTC MNL Mode Choice, Zeroed Shared
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/005_mtc.html">
       5: MTC MNL Mode Choice, Motorized Travel Time
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/006_mtc.html">
       6: MTC MNL Mode Choice, Motorized Times
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/007_mtc.html">
       7: MTC MNL Mode Choice, Diminishing OVTT by Distance
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/008_mtc.html">
       8: MTC MNL Mode Choice, TTR = 2.5
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/009_mtc.html">
       9: MTC MNL Mode Choice, TTR = 4.0
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/010_mtc.html">
       10: MTC MNL Mode Choice, Autos per Household
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/011_mtc.html">
       11: MTC MNL Mode Choice, Vehicle by Worker
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/012_mtc.html">
       12: MTC MNL Mode Choice, Autos per Adult
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/013_mtc.html">
       13: MTC MNL Mode Choice, CBD
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/014_mtc.html">
       14: MTC MNL Mode Choice, Work Zone Density
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/015_mtc.html">
       15: MTC MNL Mode Choice, CBD and Work Zone Density
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/016_mtc.html">
       16: MTC MNL Mode Choice, Cost by Income
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/017A_mtc.html">
       17A: MTC MNL Mode Choice, Segmented for 1 or fewer cars
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/017B_mtc.html">
       17B: MTC MNL Mode Choice, Segmented for 2 or more cars
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/017C_mtc.html">
       17C: MTC MNL Mode Choice, Segmented for Males
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/017D_mtc.html">
       17D: MTC MNL Mode Choice, Segmented for Females
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/017_mtc.html">
       17: MTC Expanded MNL Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/018_mtc.html">
       18: MTC Motorized Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/019_mtc.html">
       19: MTC Private Auto Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/020_mtc.html">
       20: MTC Shared Ride Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/021_mtc.html">
       21: MTC Non-Motorized Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/022_mtc.html">
       22: MTC Motorized and Non-Motorized Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/023_mtc.html">
       23W: MTC Private Auto - Non-Motorized Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/024_mtc.html">
       23W: MTC Shared Ride - Non-Motorized Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/025_mtc.html">
       25: MTC Private Auto - Motorized Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/026_mtc.html">
       26: MTC Shared Ride - Motorized Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/027_mtc.html">
       27: MTC Shared Ride - Private Auto Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/028_mtc.html">
       28: MTC Motorized - Shared Ride - Non-Motorized Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/029_mtc.html">
       29: MTC Motorized - Shared Ride - Private Auto Nested Mode Choice
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../example/legacy/swissmetro.html">
     Swissmetro Examples
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" type="checkbox"/>
    <label for="toctree-checkbox-16">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/101_mnl.html">
       101: Swissmetro MNL Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/102_mnl_weighted.html">
       102: Swissmetro Weighted MNL Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/107_latent_class.html">
       107: Latent Class Models
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/109_nl.html">
       109: Swissmetro Nested Logit Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/111_cnl.html">
       111: Swissmetro Cross-Nested Logit Mode Choice
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../example/legacy/itinerary.html">
     Itinerary Choice Examples
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" type="checkbox"/>
    <label for="toctree-checkbox-17">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/300L_itinerary.html">
       300L: Itinerary Choice Data
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/301_itin_mnl.html">
       301: Itinerary Choice using MNL
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../example/legacy/302_itin_nl.html">
       302: Itinerary Choice using Simple Nested Logit
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/jpn--/larch"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/jpn--/larch/issues/new?title=Issue%20on%20page%20%2F_modules/larch/dataset.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            
              <div>
                
  <h1>Source code for larch.dataset</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">import</span> <span class="nn">numba</span> <span class="k">as</span> <span class="nn">nb</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span>
<span class="kn">from</span> <span class="nn">xarray.core</span> <span class="kn">import</span> <span class="n">dtypes</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Collection</span><span class="p">,</span>
    <span class="n">DefaultDict</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">MutableMapping</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Set</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
    <span class="n">overload</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">construct</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="n">flow</span>
<span class="kn">from</span> <span class="nn">.patch</span> <span class="kn">import</span> <span class="n">register_dataarray_classmethod</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">sharrow</span> <span class="kn">import</span> <span class="n">Dataset</span> <span class="k">as</span> <span class="n">_sharrow_Dataset</span>
    <span class="kn">from</span> <span class="nn">sharrow</span> <span class="kn">import</span> <span class="n">DataArray</span> <span class="k">as</span> <span class="n">_sharrow_DataArray</span>
    <span class="kn">from</span> <span class="nn">sharrow</span> <span class="kn">import</span> <span class="n">DataTree</span> <span class="k">as</span> <span class="n">_sharrow_DataTree</span>
    <span class="kn">from</span> <span class="nn">sharrow.accessors</span> <span class="kn">import</span> <span class="n">register_dataarray_method</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;larch.dataset requires the sharrow library&quot;</span><span class="p">)</span>
    <span class="k">class</span> <span class="nc">_noclass</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">_sharrow_Dataset</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span>
    <span class="n">_sharrow_DataArray</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span>
    <span class="n">_sharrow_DataTree</span> <span class="o">=</span> <span class="n">_noclass</span>
    <span class="n">register_dataarray_method</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>

<span class="kn">from</span> <span class="nn">.dim_names</span> <span class="kn">import</span> <span class="n">CASEID</span> <span class="k">as</span> <span class="n">_CASEID</span><span class="p">,</span> <span class="n">ALTID</span> <span class="k">as</span> <span class="n">_ALTID</span><span class="p">,</span> <span class="n">CASEALT</span> <span class="k">as</span> <span class="n">_CASEALT</span><span class="p">,</span> <span class="n">ALTIDX</span> <span class="k">as</span> <span class="n">_ALTIDX</span><span class="p">,</span> <span class="n">CASEPTR</span> <span class="k">as</span> <span class="n">_CASEPTR</span><span class="p">,</span> <span class="n">GROUPID</span> <span class="k">as</span> <span class="n">_GROUPID</span><span class="p">,</span> <span class="n">INGROUP</span> <span class="k">as</span> <span class="n">_INGROUP</span>

<span class="n">DataArray</span> <span class="o">=</span> <span class="n">_sharrow_DataArray</span>

<span class="nd">@register_dataarray_classmethod</span>
<span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">coords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a dataset filled with zeros.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coords : Tuple[array-like]</span>
<span class="sd">        A sequence of coordinate vectors.  Ideally each should have a</span>
<span class="sd">        `name` attribute that names a dimension, otherwise placeholder</span>
<span class="sd">        names are used.</span>
<span class="sd">    dtype : dtype, default np.float64</span>
<span class="sd">        dtype of the new array. If omitted, it defaults to np.float64.</span>
<span class="sd">    name : str or None, optional</span>
<span class="sd">        Name of this array.</span>
<span class="sd">    attrs : dict_like or None, optional</span>
<span class="sd">        Attributes to assign to the new instance. By default, an empty</span>
<span class="sd">        attribute dictionary is initialized.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    DataArray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">coo</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;dim_</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
        <span class="n">coo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span>
        <span class="n">coords</span><span class="o">=</span><span class="n">coo</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
        <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">,</span>
    <span class="p">)</span>

<span class="nd">@register_dataarray_method</span>
<span class="k">def</span> <span class="nf">to_zarr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write DataArray contents to a zarr store.</span>

<span class="sd">    All parameters are passed directly to :py:meth:`xarray.Dataset.to_zarr`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Only xarray.Dataset objects can be written to netCDF files, so</span>
<span class="sd">    the xarray.DataArray is converted to a xarray.Dataset object</span>
<span class="sd">    containing a single variable. If the DataArray has no name, or if the</span>
<span class="sd">    name is the same as a coordinate name, then it is given the name</span>
<span class="sd">    ``&quot;__xarray_dataarray_variable__&quot;``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Dataset.to_zarr</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">xarray.backends.api</span> <span class="kn">import</span> <span class="n">DATAARRAY_VARIABLE</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># If no name is set then use a generic xarray name</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">DATAARRAY_VARIABLE</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># No problems with the name - so we&#39;re fine!</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">store</span><span class="p">)</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.zip&#39;</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">zarr</span>
            <span class="k">with</span> <span class="n">zarr</span><span class="o">.</span><span class="n">ZipStore</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">zstore</span><span class="p">:</span>
                <span class="n">dataset</span><span class="o">.</span><span class="n">to_zarr</span><span class="p">(</span><span class="n">zstore</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span>

    <span class="k">return</span> <span class="n">dataset</span><span class="o">.</span><span class="n">to_zarr</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="nd">@register_dataarray_classmethod</span>
<span class="k">def</span> <span class="nf">from_zarr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_zarr</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot infer name to load&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dataset</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>


<span class="nd">@register_dataarray_method</span>
<span class="k">def</span> <span class="nf">value_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_name</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Count the number of times each unique value appears in the array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    index_name : str, default &#39;index&#39;</span>
<span class="sd">        Name of index dimension in result.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    DataArray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">values</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">index_name</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="n">index_name</span><span class="p">:</span><span class="n">values</span><span class="p">})</span>


<span class="n">Dataset</span> <span class="o">=</span> <span class="n">_sharrow_Dataset</span>
<span class="c1"># class Dataset(_sharrow_Dataset):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     A xarray.Dataset extended interface for use with Larch.</span>
<span class="c1">#</span>
<span class="c1">#     A Dataset consists of variables, coordinates and attributes which</span>
<span class="c1">#     together form a self describing dataset.</span>
<span class="c1">#</span>
<span class="c1">#     Dataset implements the mapping interface with keys given by variable</span>
<span class="c1">#     names and values given by DataArray objects for each variable name.</span>
<span class="c1">#</span>
<span class="c1">#     One dimensional variables with name equal to their dimension are</span>
<span class="c1">#     index coordinates used for label based indexing.</span>
<span class="c1">#</span>
<span class="c1">#     For Larch, one dimension of each Dataset must typiccally be named &#39;_caseid_&#39;,</span>
<span class="c1">#     and this dimension is used to identify the individual discrete choice</span>
<span class="c1">#     observations or simulations in the data. The `caseid` argument can be</span>
<span class="c1">#     used to set an existing dimension as &#39;_caseid_&#39; on Dataset construction.</span>
<span class="c1">#</span>
<span class="c1">#     Parameters</span>
<span class="c1">#     ----------</span>
<span class="c1">#     data_vars : dict-like, optional</span>
<span class="c1">#         A mapping from variable names to :py:class:`~xarray.DataArray`</span>
<span class="c1">#         objects, :py:class:`~xarray.Variable` objects or to tuples of</span>
<span class="c1">#         the form ``(dims, data[, attrs])`` which can be used as</span>
<span class="c1">#         arguments to create a new ``Variable``. Each dimension must</span>
<span class="c1">#         have the same length in all variables in which it appears.</span>
<span class="c1">#</span>
<span class="c1">#         The following notations are accepted:</span>
<span class="c1">#</span>
<span class="c1">#         - mapping {var name: DataArray}</span>
<span class="c1">#         - mapping {var name: Variable}</span>
<span class="c1">#         - mapping {var name: (dimension name, array-like)}</span>
<span class="c1">#         - mapping {var name: (tuple of dimension names, array-like)}</span>
<span class="c1">#         - mapping {dimension name: array-like}</span>
<span class="c1">#           (it will be automatically moved to coords, see below)</span>
<span class="c1">#</span>
<span class="c1">#         Each dimension must have the same length in all variables in</span>
<span class="c1">#         which it appears.</span>
<span class="c1">#</span>
<span class="c1">#     coords : dict-like, optional</span>
<span class="c1">#         Another mapping in similar form as the `data_vars` argument,</span>
<span class="c1">#         except the each item is saved on the dataset as a &quot;coordinate&quot;.</span>
<span class="c1">#         These variables have an associated meaning: they describe</span>
<span class="c1">#         constant/fixed/independent quantities, unlike the</span>
<span class="c1">#         varying/measured/dependent quantities that belong in</span>
<span class="c1">#         `variables`. Coordinates values may be given by 1-dimensional</span>
<span class="c1">#         arrays or scalars, in which case `dims` do not need to be</span>
<span class="c1">#         supplied: 1D arrays will be assumed to give index values along</span>
<span class="c1">#         the dimension with the same name.</span>
<span class="c1">#</span>
<span class="c1">#         The following notations are accepted:</span>
<span class="c1">#</span>
<span class="c1">#         - mapping {coord name: DataArray}</span>
<span class="c1">#         - mapping {coord name: Variable}</span>
<span class="c1">#         - mapping {coord name: (dimension name, array-like)}</span>
<span class="c1">#         - mapping {coord name: (tuple of dimension names, array-like)}</span>
<span class="c1">#         - mapping {dimension name: array-like}</span>
<span class="c1">#           (the dimension name is implicitly set to be the same as the</span>
<span class="c1">#           coord name)</span>
<span class="c1">#</span>
<span class="c1">#         The last notation implies that the coord name is the same as</span>
<span class="c1">#         the dimension name.</span>
<span class="c1">#</span>
<span class="c1">#     attrs : dict-like, optional</span>
<span class="c1">#         Global attributes to save on this dataset.</span>
<span class="c1">#</span>
<span class="c1">#     caseid : str, optional, keyword only</span>
<span class="c1">#         This named dimension will be marked as the &#39;_caseid_&#39; dimension.</span>
<span class="c1">#</span>
<span class="c1">#     alts : str or Mapping or array-like, keyword only</span>
<span class="c1">#         If given as a str, this named dimension will be marked as the</span>
<span class="c1">#         &#39;_altid_&#39; dimension.  Otherwise, give a Mapping that defines</span>
<span class="c1">#         alternative names and (integer) codes or an array of codes.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#     __slots__ = (&#39;_flow_library&#39;,)</span>
<span class="c1">#</span>
<span class="c1">#     def __new__(cls, *args, caseid=None, alts=None, **kwargs):</span>
<span class="c1">#         import logging</span>
<span class="c1">#         logging.getLogger(&quot;sharrow&quot;).debug(f&quot;NEW INSTANCE {cls}&quot;)</span>
<span class="c1">#         obj = super().__new__(cls)</span>
<span class="c1">#         super(cls, obj).__init__(*args, **kwargs)</span>
<span class="c1">#         return cls._initialize_for_larch(obj, caseid, alts)</span>
<span class="c1">#</span>
<span class="c1">#     @classmethod</span>
<span class="c1">#     def _initialize_for_larch(cls, obj, caseid=None, alts=None):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         obj : Dataset</span>
<span class="c1">#             The dataaset being initialized.</span>
<span class="c1">#         caseid : str, optional</span>
<span class="c1">#             The name of a dimension referencing cases.</span>
<span class="c1">#         alts : Mapping or str or array-like, optional</span>
<span class="c1">#             If given as a mapping, links alternative codes to names.</span>
<span class="c1">#             A string names a dimension that defines the alternatives.</span>
<span class="c1">#             An array or list of integers gives codes for the alternatives,</span>
<span class="c1">#             which are otherwise unnamed.</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         Dataset</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         obj._flow_library = {}</span>
<span class="c1">#         if caseid is not None:</span>
<span class="c1">#             if caseid not in obj.dims:</span>
<span class="c1">#                 raise ValueError(f&quot;no dim named &#39;{caseid}&#39; to make into {_CASEID}&quot;)</span>
<span class="c1">#             obj.attrs[_CASEID] = caseid</span>
<span class="c1">#         if isinstance(alts, pd.Series):</span>
<span class="c1">#             alts_dim_name = alts.name or alts.index.name or &#39;_altid_&#39;</span>
<span class="c1">#             alts_k = DataArray(</span>
<span class="c1">#                 alts.index, dims=alts_dim_name,</span>
<span class="c1">#             )</span>
<span class="c1">#             alts_v = DataArray(</span>
<span class="c1">#                 alts.values, dims=alts_dim_name,</span>
<span class="c1">#             )</span>
<span class="c1">#         elif isinstance(alts, Mapping):</span>
<span class="c1">#             alts_dim_name = &#39;_altid_&#39;</span>
<span class="c1">#             alts_k = DataArray(</span>
<span class="c1">#                 list(alts.keys()), dims=alts_dim_name,</span>
<span class="c1">#             )</span>
<span class="c1">#             alts_v = DataArray(</span>
<span class="c1">#                 list(alts.values()), dims=alts_dim_name,</span>
<span class="c1">#             )</span>
<span class="c1">#         elif isinstance(alts, str):</span>
<span class="c1">#             alts_dim_name = alts</span>
<span class="c1">#             alts_k = alts_v = None</span>
<span class="c1">#         elif alts is None:</span>
<span class="c1">#             alts_dim_name = None</span>
<span class="c1">#             alts_k = alts_v = None</span>
<span class="c1">#         else:</span>
<span class="c1">#             alts_dim_name = getattr(alts, &#39;name&#39;, &#39;_altid_&#39;)</span>
<span class="c1">#             alts_v = np.asarray(alts).reshape(-1)</span>
<span class="c1">#             alts_k = None</span>
<span class="c1">#         if alts_dim_name:</span>
<span class="c1">#             obj.attrs[_ALTID] = alts_dim_name</span>
<span class="c1">#         if alts_k is not None:</span>
<span class="c1">#             if np.issubdtype(alts_v, np.integer) and not np.issubdtype(alts_k, np.integer):</span>
<span class="c1">#                 obj.coords[alts_dim_name] = alts_v</span>
<span class="c1">#                 obj.coords[&#39;alt_names&#39;] = alts_k</span>
<span class="c1">#             else:</span>
<span class="c1">#                 obj.coords[alts_dim_name] = alts_k</span>
<span class="c1">#                 obj.coords[&#39;alt_names&#39;] = alts_v</span>
<span class="c1">#         elif alts_v is not None:</span>
<span class="c1">#             obj.coords[alts_dim_name] = alts_v</span>
<span class="c1">#         return obj</span>
<span class="c1">#</span>
<span class="c1">#     # @classmethod</span>
<span class="c1">#     # def construct(cls, source, caseid=None, alts=None):</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     A generic constructor for creating Datasets from various similar objects.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Parameters</span>
<span class="c1">#     #     ----------</span>
<span class="c1">#     #     source : pandas.DataFrame, pyarrow.Table, xarray.Dataset, or Sequence[str]</span>
<span class="c1">#     #         The source from which to create a Dataset.  DataFrames and Tables</span>
<span class="c1">#     #         are converted to Datasets that have one dimension (the rows) and</span>
<span class="c1">#     #         seperate variables for each of the columns.  A list of strings</span>
<span class="c1">#     #         creates a dataset with those named empty variables.</span>
<span class="c1">#     #     caseid : str, optional</span>
<span class="c1">#     #         The name of a dimension referencing cases.</span>
<span class="c1">#     #     alts : Mapping or str or array-like, optional</span>
<span class="c1">#     #         If given as a mapping, links alternative codes to names.</span>
<span class="c1">#     #         A string names a dimension that defines the alternatives.</span>
<span class="c1">#     #         An array or list of integers gives codes for the alternatives,</span>
<span class="c1">#     #         which are otherwise unnamed.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Returns</span>
<span class="c1">#     #     -------</span>
<span class="c1">#     #     Dataset</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     if isinstance(source, pd.DataFrame):</span>
<span class="c1">#     #         source = cls.from_dataframe(source)</span>
<span class="c1">#     #     else:</span>
<span class="c1">#     #         source = super().construct(source)</span>
<span class="c1">#     #     return cls._initialize_for_larch(source, caseid, alts)</span>
<span class="c1">#</span>
<span class="c1">#     def _set_sparse_data_from_dataframe_gcxs(</span>
<span class="c1">#         self, idx: pd.Index, arrays: List[Tuple[Hashable, np.ndarray]], dims: tuple</span>
<span class="c1">#     ) -&gt; None:</span>
<span class="c1">#         from sparse import COO, GCXS</span>
<span class="c1">#</span>
<span class="c1">#         if isinstance(idx, pd.MultiIndex):</span>
<span class="c1">#             coords = np.stack([np.asarray(code) for code in idx.codes], axis=0)</span>
<span class="c1">#             is_sorted = idx.is_monotonic_increasing</span>
<span class="c1">#             shape = tuple(lev.size for lev in idx.levels)</span>
<span class="c1">#         else:</span>
<span class="c1">#             coords = np.arange(idx.size).reshape(1, -1)</span>
<span class="c1">#             is_sorted = True</span>
<span class="c1">#             shape = (idx.size,)</span>
<span class="c1">#</span>
<span class="c1">#         if not is_sorted:</span>
<span class="c1">#             raise ValueError(&quot;index must be sorted&quot;)</span>
<span class="c1">#</span>
<span class="c1">#         template_data = COO(</span>
<span class="c1">#             coords,</span>
<span class="c1">#             np.zeros(len(idx)),</span>
<span class="c1">#             shape,</span>
<span class="c1">#             has_duplicates=False,</span>
<span class="c1">#             sorted=is_sorted,</span>
<span class="c1">#             fill_value=np.nan,</span>
<span class="c1">#         )</span>
<span class="c1">#         template_gcxs = GCXS(template_data, compressed_axes=(0,))</span>
<span class="c1">#</span>
<span class="c1">#         for name, values in arrays:</span>
<span class="c1">#             # In virtually all real use cases, the sparse array will now have</span>
<span class="c1">#             # missing values and needs a fill_value. For consistency, don&#39;t</span>
<span class="c1">#             # special case the rare exceptions (e.g., dtype=int without a</span>
<span class="c1">#             # MultiIndex).</span>
<span class="c1">#             dtype, fill_value = dtypes.maybe_promote(values.dtype)</span>
<span class="c1">#             values = np.asarray(values, dtype=dtype)</span>
<span class="c1">#</span>
<span class="c1">#             data = GCXS(</span>
<span class="c1">#                 (values, template_gcxs.indices, template_gcxs.indptr),</span>
<span class="c1">#                 shape=template_gcxs.shape,</span>
<span class="c1">#                 compressed_axes=(0,),</span>
<span class="c1">#                 prune=False,</span>
<span class="c1">#             )</span>
<span class="c1">#             self[name] = (dims, data)</span>
<span class="c1">#</span>
<span class="c1">#     def __init__(self, *args, **kwargs):</span>
<span class="c1">#         pass # init for superclass happens inside __new__</span>
<span class="c1">#</span>
<span class="c1">#     # @property</span>
<span class="c1">#     # def CASEID(self):</span>
<span class="c1">#     #     result = self.attrs.get(_CASEID, None)</span>
<span class="c1">#     #     if result is None:</span>
<span class="c1">#     #         warnings.warn(&quot;no defined CASEID&quot;)</span>
<span class="c1">#     #         return _CASEID</span>
<span class="c1">#     #     return result</span>
<span class="c1">#     #</span>
<span class="c1">#     # @CASEID.setter</span>
<span class="c1">#     # def CASEID(self, dim_name):</span>
<span class="c1">#     #     if dim_name not in self.dims:</span>
<span class="c1">#     #         raise ValueError(f&quot;{dim_name} not in dims&quot;)</span>
<span class="c1">#     #     self.attrs[_CASEID] = dim_name</span>
<span class="c1">#     #</span>
<span class="c1">#     # @property</span>
<span class="c1">#     # def ALTID(self):</span>
<span class="c1">#     #     result = self.attrs.get(_ALTID, None)</span>
<span class="c1">#     #     if result is None:</span>
<span class="c1">#     #         warnings.warn(&quot;no defined ALTID&quot;)</span>
<span class="c1">#     #         return _ALTID</span>
<span class="c1">#     #     return result</span>
<span class="c1">#     #</span>
<span class="c1">#     # @ALTID.setter</span>
<span class="c1">#     # def ALTID(self, dim_name):</span>
<span class="c1">#     #     self.attrs[_ALTID] = dim_name</span>
<span class="c1">#</span>
<span class="c1">#     # @property</span>
<span class="c1">#     # def alts_mapping(self):</span>
<span class="c1">#     #     &quot;&quot;&quot;Dict[int,str] : Mapping of alternative codes to names&quot;&quot;&quot;</span>
<span class="c1">#     #     a = self.coords[self.ALTID]</span>
<span class="c1">#     #     if &#39;alt_names&#39; in a.coords:</span>
<span class="c1">#     #         return dict(zip(a.values, a.coords[&#39;alt_names&#39;].values))</span>
<span class="c1">#     #     else:</span>
<span class="c1">#     #         return dict(zip(a.values, a.values))</span>
<span class="c1">#     #</span>
<span class="c1">#     # @property</span>
<span class="c1">#     # def n_cases(self):</span>
<span class="c1">#     #     try:</span>
<span class="c1">#     #         return self.dims[self.CASEID]</span>
<span class="c1">#     #     except KeyError:</span>
<span class="c1">#     #         logging.getLogger().error(f&quot;missing {self.CASEID!r} among dims {self.dims}&quot;)</span>
<span class="c1">#     #         raise</span>
<span class="c1">#     #</span>
<span class="c1">#     # @property</span>
<span class="c1">#     # def n_alts(self):</span>
<span class="c1">#     #     if self.ALTID in self.dims:</span>
<span class="c1">#     #         return self.dims[self.ALTID]</span>
<span class="c1">#     #     if &#39;n_alts&#39; in self.attrs:</span>
<span class="c1">#     #         return self.attrs[&#39;n_alts&#39;]</span>
<span class="c1">#     #     raise ValueError(&#39;no n_alts set&#39;)</span>
<span class="c1">#</span>
<span class="c1">#     # @property</span>
<span class="c1">#     # def CASEALT(self):</span>
<span class="c1">#     #     &quot;&quot;&quot;str : The _casealt_ dimension of this Dataset, if defined.&quot;&quot;&quot;</span>
<span class="c1">#     #     result = self.attrs.get(_CASEALT, None)</span>
<span class="c1">#     #     return result</span>
<span class="c1">#     #</span>
<span class="c1">#     # @CASEALT.setter</span>
<span class="c1">#     # def CASEALT(self, dim_name):</span>
<span class="c1">#     #     self.attrs[_CASEALT] = dim_name</span>
<span class="c1">#     #</span>
<span class="c1">#     # @property</span>
<span class="c1">#     # def ALTIDX(self):</span>
<span class="c1">#     #     &quot;&quot;&quot;str : The _alt_idx_ dimension of this Dataset, if defined.&quot;&quot;&quot;</span>
<span class="c1">#     #     result = self.attrs.get(_ALTIDX, None)</span>
<span class="c1">#     #     return result</span>
<span class="c1">#     #</span>
<span class="c1">#     # @ALTIDX.setter</span>
<span class="c1">#     # def ALTIDX(self, dim_name):</span>
<span class="c1">#     #     self.attrs[_ALTIDX] = dim_name</span>
<span class="c1">#     #</span>
<span class="c1">#     # @property</span>
<span class="c1">#     # def CASEPTR(self):</span>
<span class="c1">#     #     &quot;&quot;&quot;str : The _caseptr_ dimension of this Dataset, if defined.&quot;&quot;&quot;</span>
<span class="c1">#     #     result = self.attrs.get(_CASEPTR, None)</span>
<span class="c1">#     #     return result</span>
<span class="c1">#     #</span>
<span class="c1">#     # @CASEPTR.setter</span>
<span class="c1">#     # def CASEPTR(self, dim_name):</span>
<span class="c1">#     #     self.attrs[_CASEPTR] = dim_name</span>
<span class="c1">#     #</span>
<span class="c1">#     # @property</span>
<span class="c1">#     # def GROUPID(self):</span>
<span class="c1">#     #     &quot;&quot;&quot;str : The _groupid_ dimension of this Dataset, if defined.&quot;&quot;&quot;</span>
<span class="c1">#     #     result = self.attrs.get(_GROUPID, None)</span>
<span class="c1">#     #     return result</span>
<span class="c1">#     #</span>
<span class="c1">#     # @GROUPID.setter</span>
<span class="c1">#     # def GROUPID(self, dim_name):</span>
<span class="c1">#     #     self.attrs[_GROUPID] = dim_name</span>
<span class="c1">#     #</span>
<span class="c1">#     # @property</span>
<span class="c1">#     # def INGROUP(self):</span>
<span class="c1">#     #     &quot;&quot;&quot;str : The _ingroup_ dimension of this Dataset, if defined.&quot;&quot;&quot;</span>
<span class="c1">#     #     result = self.attrs.get(_INGROUP, None)</span>
<span class="c1">#     #     return result</span>
<span class="c1">#     #</span>
<span class="c1">#     # @INGROUP.setter</span>
<span class="c1">#     # def INGROUP(self, dim_name):</span>
<span class="c1">#     #     self.attrs[_INGROUP] = dim_name</span>
<span class="c1">#</span>
<span class="c1">#     def _repr_html_(self):</span>
<span class="c1">#         html = super()._repr_html_()</span>
<span class="c1">#         html = html.replace(&quot;sharrow.Dataset&quot;, &quot;larch.Dataset&quot;)</span>
<span class="c1">#         return html</span>
<span class="c1">#</span>
<span class="c1">#     def __repr__(self):</span>
<span class="c1">#         r = super().__repr__()</span>
<span class="c1">#         r = r.replace(&quot;sharrow.Dataset&quot;, &quot;larch.Dataset&quot;)</span>
<span class="c1">#         return r</span>
<span class="c1">#</span>
<span class="c1">#     # def __getattr__(self, name):</span>
<span class="c1">#     #     # change attrs from xr.DataArray to larch.DataArray</span>
<span class="c1">#     #     result = super().__getattr__(name)</span>
<span class="c1">#     #     if isinstance(result, xr.DataArray) and not isinstance(result, DataArray):</span>
<span class="c1">#     #         c = self.attrs.get(_CASEID, None)</span>
<span class="c1">#     #         a = self.attrs.get(_ALTID, None)</span>
<span class="c1">#     #         if c is not None:</span>
<span class="c1">#     #             result.attrs[_CASEID] = c</span>
<span class="c1">#     #         if a is not None:</span>
<span class="c1">#     #             result.attrs[_ALTID] = a</span>
<span class="c1">#     #         result.__class__ = DataArray</span>
<span class="c1">#     #     return result</span>
<span class="c1">#     #</span>
<span class="c1">#     # def __getitem__(self, name):</span>
<span class="c1">#     #     # change items from xr.DataArray to larch.DataArray</span>
<span class="c1">#     #     result = super().__getitem__(name)</span>
<span class="c1">#     #     if isinstance(result, xr.DataArray) and not isinstance(result, DataArray):</span>
<span class="c1">#     #         c = self.attrs.get(_CASEID, None)</span>
<span class="c1">#     #         a = self.attrs.get(_ALTID, None)</span>
<span class="c1">#     #         if c is not None:</span>
<span class="c1">#     #             result.attrs[_CASEID] = c</span>
<span class="c1">#     #         if a is not None:</span>
<span class="c1">#     #             result.attrs[_ALTID] = a</span>
<span class="c1">#     #         result.__class__ = DataArray</span>
<span class="c1">#     #     return result</span>
<span class="c1">#</span>
<span class="c1">#     # def get_expr(self, expression):</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     Access or evaluate an expression.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Parameters</span>
<span class="c1">#     #     ----------</span>
<span class="c1">#     #     expression : str</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Returns</span>
<span class="c1">#     #     -------</span>
<span class="c1">#     #     DataArray</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     try:</span>
<span class="c1">#     #         result = self[expression]</span>
<span class="c1">#     #     except (KeyError, IndexError):</span>
<span class="c1">#     #         try:</span>
<span class="c1">#     #             self._flow_library</span>
<span class="c1">#     #         except AttributeError:</span>
<span class="c1">#     #             flow = self.setup_flow({expression: expression})</span>
<span class="c1">#     #         else:</span>
<span class="c1">#     #             if expression in self._flow_library:</span>
<span class="c1">#     #                 flow = self._flow_library[expression]</span>
<span class="c1">#     #             else:</span>
<span class="c1">#     #                 flow = self.setup_flow({expression: expression})</span>
<span class="c1">#     #                 self._flow_library[expression] = flow</span>
<span class="c1">#     #         if not flow.tree.root_dataset is self:</span>
<span class="c1">#     #             flow.tree = self.as_tree()</span>
<span class="c1">#     #         result = flow.load_dataarray().isel(expressions=0)</span>
<span class="c1">#     #     return result</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#     # def to_arrays(self, graph, float_dtype=np.float64):</span>
<span class="c1">#     #     from .numba.data_arrays import DataArrays</span>
<span class="c1">#     #     from .numba.cascading import array_av_cascade, array_ch_cascade</span>
<span class="c1">#     #</span>
<span class="c1">#     #     if &#39;co&#39; in self:</span>
<span class="c1">#     #         co = self[&#39;co&#39;].values.astype(float_dtype)</span>
<span class="c1">#     #     else:</span>
<span class="c1">#     #         co = np.empty( (self.n_cases, 0), dtype=float_dtype)</span>
<span class="c1">#     #</span>
<span class="c1">#     #     if &#39;ca&#39; in self:</span>
<span class="c1">#     #         ca = self[&#39;ca&#39;].values.astype(float_dtype)</span>
<span class="c1">#     #     else:</span>
<span class="c1">#     #         ca = np.empty( (self.n_cases, self.n_alts, 0), dtype=float_dtype)</span>
<span class="c1">#     #</span>
<span class="c1">#     #     if &#39;ce_data&#39; in self:</span>
<span class="c1">#     #         ce_data = self[&#39;ce_data&#39;].values.astype(float_dtype)</span>
<span class="c1">#     #     else:</span>
<span class="c1">#     #         ce_data = np.empty( (0, 0), dtype=float_dtype)</span>
<span class="c1">#     #</span>
<span class="c1">#     #     if self.ALTIDX is not None:</span>
<span class="c1">#     #         ce_altidx = self[self.ALTIDX].values</span>
<span class="c1">#     #     else:</span>
<span class="c1">#     #         ce_altidx = np.empty( (0), dtype=np.int16)</span>
<span class="c1">#     #</span>
<span class="c1">#     #     if self.CASEPTR is not None:</span>
<span class="c1">#     #         ce_caseptr = np.lib.stride_tricks.sliding_window_view(</span>
<span class="c1">#     #             self[self.CASEPTR].values, 2</span>
<span class="c1">#     #         )</span>
<span class="c1">#     #     else:</span>
<span class="c1">#     #         ce_caseptr = np.empty( (self.n_cases, 0), dtype=np.int16)</span>
<span class="c1">#     #</span>
<span class="c1">#     #     if &#39;wt&#39; in self:</span>
<span class="c1">#     #         wt = self[&#39;wt&#39;].values.astype(float_dtype)</span>
<span class="c1">#     #     else:</span>
<span class="c1">#     #         wt = np.ones(self.n_cases, dtype=float_dtype)</span>
<span class="c1">#     #</span>
<span class="c1">#     #     if &#39;ch&#39; in self:</span>
<span class="c1">#     #         ch = array_ch_cascade(self[&#39;ch&#39;].values, graph, dtype=float_dtype)</span>
<span class="c1">#     #     else:</span>
<span class="c1">#     #         ch = np.zeros([self.n_cases, len(graph)], dtype=float_dtype)</span>
<span class="c1">#     #</span>
<span class="c1">#     #     if &#39;av&#39; in self:</span>
<span class="c1">#     #         av = array_av_cascade(self[&#39;av&#39;].values, graph)</span>
<span class="c1">#     #     else:</span>
<span class="c1">#     #         av = np.ones([self.n_cases, len(graph)], dtype=np.int8)</span>
<span class="c1">#     #</span>
<span class="c1">#     #     return DataArrays(</span>
<span class="c1">#     #         ch, av, wt, co, ca, ce_data, ce_altidx, ce_caseptr</span>
<span class="c1">#     #     )</span>
<span class="c1">#</span>
<span class="c1">#     # def validate_format(self):</span>
<span class="c1">#     #     error_msgs = []</span>
<span class="c1">#     #     warn_msgs = []</span>
<span class="c1">#     #     if self.CASEID not in self.dims:</span>
<span class="c1">#     #         error_msgs.append(</span>
<span class="c1">#     #             f&quot;- There is no dimensions named `{self.CASEID}`. &quot;</span>
<span class="c1">#     #         )</span>
<span class="c1">#     #     if self.ALTID not in self.dims:</span>
<span class="c1">#     #         warn_msgs.append(</span>
<span class="c1">#     #             f&quot;- There is no dimensions named `_altid_`. &quot;</span>
<span class="c1">#     #         )</span>
<span class="c1">#     #     msgs = []</span>
<span class="c1">#     #     if error_msgs:</span>
<span class="c1">#     #         msgs.append(&quot;ERRORS:&quot;)</span>
<span class="c1">#     #         msgs.extend(error_msgs)</span>
<span class="c1">#     #     if warn_msgs:</span>
<span class="c1">#     #         msgs.append(&quot;WARNINGS:&quot;)</span>
<span class="c1">#     #         msgs.extend(warn_msgs)</span>
<span class="c1">#     #     return msgs</span>
<span class="c1">#</span>
<span class="c1">#     # def query_cases(self, query, parser=&quot;pandas&quot;, engine=None):</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     Return a new dataset with each array indexed along the CASEID dimension.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     The indexers are given as strings containing Python expressions to be</span>
<span class="c1">#     #     evaluated against the data variables in the dataset.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Parameters</span>
<span class="c1">#     #     ----------</span>
<span class="c1">#     #     query : str</span>
<span class="c1">#     #         Python expressions to be evaluated against the data variables</span>
<span class="c1">#     #         in the dataset. The expressions will be evaluated using the pandas</span>
<span class="c1">#     #         eval() function, and can contain any valid Python expressions but cannot</span>
<span class="c1">#     #         contain any Python statements.</span>
<span class="c1">#     #     parser : {&quot;pandas&quot;, &quot;python&quot;}, default: &quot;pandas&quot;</span>
<span class="c1">#     #         The parser to use to construct the syntax tree from the expression.</span>
<span class="c1">#     #         The default of &#39;pandas&#39; parses code slightly different than standard</span>
<span class="c1">#     #         Python. Alternatively, you can parse an expression using the &#39;python&#39;</span>
<span class="c1">#     #         parser to retain strict Python semantics.</span>
<span class="c1">#     #     engine : {&quot;python&quot;, &quot;numexpr&quot;, None}, default: None</span>
<span class="c1">#     #         The engine used to evaluate the expression. Supported engines are:</span>
<span class="c1">#     #</span>
<span class="c1">#     #         - None: tries to use numexpr, falls back to python</span>
<span class="c1">#     #         - &quot;numexpr&quot;: evaluates expressions using numexpr</span>
<span class="c1">#     #         - &quot;python&quot;: performs operations as if you had evald in top level python</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Returns</span>
<span class="c1">#     #     -------</span>
<span class="c1">#     #     obj : Dataset</span>
<span class="c1">#     #         A new Dataset with the same contents as this dataset, except each</span>
<span class="c1">#     #         array is indexed by the results of the query on the CASEID dimension.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     See Also</span>
<span class="c1">#     #     --------</span>
<span class="c1">#     #     Dataset.isel</span>
<span class="c1">#     #     pandas.eval</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     return self.query({self.CASEID: query}, parser=parser, engine=engine)</span>
<span class="c1">#</span>
<span class="c1">#     # def dissolve_coords(self, dim, others=None):</span>
<span class="c1">#     #     d = self.reset_index(dim)</span>
<span class="c1">#     #     a = d[f&quot;{dim}_&quot;]</span>
<span class="c1">#     #     mapper = dict((j, i) for (i, j) in enumerate(a.to_series()))</span>
<span class="c1">#     #     mapper_f = np.vectorize(mapper.get)</span>
<span class="c1">#     #     if others is None:</span>
<span class="c1">#     #         others = []</span>
<span class="c1">#     #     if isinstance(others, str):</span>
<span class="c1">#     #         others = [others]</span>
<span class="c1">#     #     for other in others:</span>
<span class="c1">#     #         d[other] = xr.apply_ufunc(mapper_f, d[other])</span>
<span class="c1">#     #     return d</span>
<span class="c1">#</span>
<span class="c1">#     # def dissolve_zero_variance(self, dim=&#39;&lt;ALTID&gt;&#39;, inplace=False):</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     Dissolve dimension on variables where it has no variance.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     This method is convenient to convert variables that have</span>
<span class="c1">#     #     been loaded as |idca| or |idce| format into |idco| format where</span>
<span class="c1">#     #     appropriate.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Parameters</span>
<span class="c1">#     #     ----------</span>
<span class="c1">#     #     dim : str, optional</span>
<span class="c1">#     #         The name of the dimension to potentially dissolve.</span>
<span class="c1">#     #     inplace : bool, default False</span>
<span class="c1">#     #         Whether to dissolve variables in-place.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Returns</span>
<span class="c1">#     #     -------</span>
<span class="c1">#     #     Dataset</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     if dim == &#39;&lt;ALTID&gt;&#39;:</span>
<span class="c1">#     #         dim = self.ALTID</span>
<span class="c1">#     #     if inplace:</span>
<span class="c1">#     #         obj = self</span>
<span class="c1">#     #     else:</span>
<span class="c1">#     #         obj = self.copy()</span>
<span class="c1">#     #     for k in obj.variables:</span>
<span class="c1">#     #         if obj[k].dtype.kind in {&#39;U&#39;, &#39;S&#39;, &#39;O&#39;}:</span>
<span class="c1">#     #             continue</span>
<span class="c1">#     #         if dim in obj[k].dims:</span>
<span class="c1">#     #             try:</span>
<span class="c1">#     #                 dissolve = (obj[k].std(dim=dim).max() &lt; 1e-10)</span>
<span class="c1">#     #             except TypeError:</span>
<span class="c1">#     #                 pass</span>
<span class="c1">#     #             else:</span>
<span class="c1">#     #                 if dissolve:</span>
<span class="c1">#     #                     obj[k] = obj[k].min(dim=dim)</span>
<span class="c1">#     #         elif obj[k].dims == (self.CASEALT,):</span>
<span class="c1">#     #             proposal, flag = ce_dissolve_zero_variance(obj[k].values, obj[obj.CASEPTR].values)</span>
<span class="c1">#     #             if flag == 0:</span>
<span class="c1">#     #                 obj = obj.assign({k: DataArray(proposal, dims=(obj.CASEID))})</span>
<span class="c1">#     #     return obj</span>
<span class="c1">#</span>
<span class="c1">#     # def set_dtypes(self, dtypes, inplace=False, on_error=&#39;warn&#39;):</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     Set the dtypes for the variables in this Dataset.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Parameters</span>
<span class="c1">#     #     ----------</span>
<span class="c1">#     #     dtypes : Mapping or DataFrame</span>
<span class="c1">#     #         Mapping of names to dtypes, or a DataFrame to infer such a</span>
<span class="c1">#     #         mapping.</span>
<span class="c1">#     #     inplace : bool, default False</span>
<span class="c1">#     #         Whether to convert dtypes inplace.</span>
<span class="c1">#     #     on_error : {&#39;warn&#39;, &#39;raise&#39;, &#39;ignore&#39;}</span>
<span class="c1">#     #         What to do when a type conversion triggers an error.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Returns</span>
<span class="c1">#     #     -------</span>
<span class="c1">#     #     Dataset</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     if isinstance(dtypes, pd.DataFrame):</span>
<span class="c1">#     #         dtypes = dtypes.dtypes</span>
<span class="c1">#     #     if inplace:</span>
<span class="c1">#     #         obj = self</span>
<span class="c1">#     #     else:</span>
<span class="c1">#     #         obj = self.copy()</span>
<span class="c1">#     #     for k in obj:</span>
<span class="c1">#     #         if k not in dtypes:</span>
<span class="c1">#     #             continue</span>
<span class="c1">#     #         try:</span>
<span class="c1">#     #             obj[k] = obj[k].astype(dtypes[k])</span>
<span class="c1">#     #         except Exception as err:</span>
<span class="c1">#     #             if on_error == &#39;warn&#39;:</span>
<span class="c1">#     #                 warnings.warn(f&quot;{err!r} on converting {k}&quot;)</span>
<span class="c1">#     #             elif on_error == &#39;raise&#39;:</span>
<span class="c1">#     #                 raise</span>
<span class="c1">#     #     return obj</span>
<span class="c1">#</span>
<span class="c1">#     # def set_altids(self, altids, dim_name=None, inplace=False):</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     Set the alternative ids for this Dataset.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Parameters</span>
<span class="c1">#     #     ----------</span>
<span class="c1">#     #     altids : array-like of int</span>
<span class="c1">#     #         Integer id codes.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Returns</span>
<span class="c1">#     #     -------</span>
<span class="c1">#     #     Dataset</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     if inplace:</span>
<span class="c1">#     #         obj = self</span>
<span class="c1">#     #     else:</span>
<span class="c1">#     #         obj = self.copy()</span>
<span class="c1">#     #     dim_name = dim_name or getattr(altids, &#39;name&#39;, None) or obj.attrs.get(_ALTID, _ALTID)</span>
<span class="c1">#     #     if not isinstance(altids, DataArray):</span>
<span class="c1">#     #         altids = xr.DataArray(</span>
<span class="c1">#     #             np.asarray(altids),</span>
<span class="c1">#     #             dims=(dim_name),</span>
<span class="c1">#     #         )</span>
<span class="c1">#     #     obj.coords[dim_name] = altids</span>
<span class="c1">#     #     obj.ALTID = dim_name</span>
<span class="c1">#     #     return obj</span>
<span class="c1">#     #</span>
<span class="c1">#     # def set_altnames(self, altnames, inplace=False):</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     Set the alternative names for this Dataset.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Parameters</span>
<span class="c1">#     #     ----------</span>
<span class="c1">#     #     altnames : Mapping or array-like</span>
<span class="c1">#     #         A mapping of (integer) codes to names, or an array or names</span>
<span class="c1">#     #         of the same length and order as the alternatives already</span>
<span class="c1">#     #         defined in this Dataset.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Returns</span>
<span class="c1">#     #     -------</span>
<span class="c1">#     #     Dataset</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     if inplace:</span>
<span class="c1">#     #         obj = self</span>
<span class="c1">#     #     else:</span>
<span class="c1">#     #         obj = self.copy()</span>
<span class="c1">#     #     if isinstance(altnames, Mapping):</span>
<span class="c1">#     #         names = xr.DataArray(</span>
<span class="c1">#     #             [altnames.get(i, None) for i in obj[obj.ALTID].values],</span>
<span class="c1">#     #             dims=obj.ALTID,</span>
<span class="c1">#     #         )</span>
<span class="c1">#     #     elif isinstance(altnames, DataArray):</span>
<span class="c1">#     #         names = altnames</span>
<span class="c1">#     #     else:</span>
<span class="c1">#     #         names = xr.DataArray(</span>
<span class="c1">#     #             np.asarray(altnames),</span>
<span class="c1">#     #             dims=obj.ALTID,</span>
<span class="c1">#     #         )</span>
<span class="c1">#     #     obj.coords[&#39;altnames&#39;] = names</span>
<span class="c1">#     #     return obj</span>
<span class="c1">#</span>
<span class="c1">#     # @classmethod</span>
<span class="c1">#     # def from_idca(cls, df, crack=True, altnames=None, avail=&#39;_avail_&#39;, fill_missing=None):</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     Construct a Dataset from an idca-format DataFrame.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     This method loads the data as dense arrays.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Parameters</span>
<span class="c1">#     #     ----------</span>
<span class="c1">#     #     df : DataFrame</span>
<span class="c1">#     #         The input data should be an idca-format or idce-format DataFrame,</span>
<span class="c1">#     #         with the caseid&#39;s and altid&#39;s in a two-level pandas MultiIndex.</span>
<span class="c1">#     #     crack : bool, default True</span>
<span class="c1">#     #         If True, the `dissolve_zero_variance` method is applied before</span>
<span class="c1">#     #         repairing dtypes, to ensure that missing value are handled</span>
<span class="c1">#     #         properly.</span>
<span class="c1">#     #     altnames : Mapping, optional</span>
<span class="c1">#     #         If given as a mapping, links alternative codes to names.</span>
<span class="c1">#     #         An array or list of strings gives names for the alternatives,</span>
<span class="c1">#     #         sorted in the same order as the codes.</span>
<span class="c1">#     #     avail : str, default &#39;_avail_&#39;</span>
<span class="c1">#     #         When the imported data is in idce format (i.e. sparse) then</span>
<span class="c1">#     #         an availability indicator is computed and given this name.</span>
<span class="c1">#     #     fill_missing : scalar or Mapping, optional</span>
<span class="c1">#     #         Fill values to use for missing values when imported data is</span>
<span class="c1">#     #         in idce format (i.e. sparse).  Give a single value to use</span>
<span class="c1">#     #         globally, or a mapping of {variable: value} or {dtype: value}.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Returns</span>
<span class="c1">#     #     -------</span>
<span class="c1">#     #     Dataset</span>
<span class="c1">#     #</span>
<span class="c1">#     #     See Also</span>
<span class="c1">#     #     --------</span>
<span class="c1">#     #     Dataset.from_idce : Construct a Dataset from a sparse idca-format DataFrame.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     if df.index.nlevels != 2:</span>
<span class="c1">#     #         raise ValueError(&quot;source idca dataframe must have a two &quot;</span>
<span class="c1">#     #                          &quot;level MultiIndex giving case and alt id&#39;s&quot;)</span>
<span class="c1">#     #     caseidname, altidname = df.index.names</span>
<span class="c1">#     #</span>
<span class="c1">#     #     # check altids are integers, if they are not then fix it</span>
<span class="c1">#     #     if df.index.levels[1].dtype.kind != &#39;i&#39;:</span>
<span class="c1">#     #         if altnames is None:</span>
<span class="c1">#     #             altnames = df.index.levels[1]</span>
<span class="c1">#     #             df.index = df.index.set_levels(np.arange(1, len(altnames) + 1), level=1)</span>
<span class="c1">#     #         else:</span>
<span class="c1">#     #             new_index = df.index.get_level_values(1).astype(pd.CategoricalDtype(altnames))</span>
<span class="c1">#     #             df.index = df.index.set_codes(new_index.codes, level=1).set_levels(np.arange(1, len(altnames) + 1), level=1)</span>
<span class="c1">#     #</span>
<span class="c1">#     #     ds = cls.construct(df, caseid=caseidname, alts=altidname)</span>
<span class="c1">#     #     if crack:</span>
<span class="c1">#     #         ds = ds.dissolve_zero_variance()</span>
<span class="c1">#     #     ds = ds.set_dtypes(df)</span>
<span class="c1">#     #     if altnames is not None:</span>
<span class="c1">#     #         ds = ds.set_altnames(altnames)</span>
<span class="c1">#     #     if avail not in ds and len(df) &lt; ds.n_cases * ds.n_alts:</span>
<span class="c1">#     #         av = DataArray.from_series(pd.Series(1, index=df.index)).fillna(0).astype(np.int8)</span>
<span class="c1">#     #         ds[avail] = av</span>
<span class="c1">#     #         if fill_missing is not None:</span>
<span class="c1">#     #             if isinstance(fill_missing, Mapping):</span>
<span class="c1">#     #                 for k, i in ds.items():</span>
<span class="c1">#     #                     if ds.ALTID not in i.dims:</span>
<span class="c1">#     #                         continue</span>
<span class="c1">#     #                     if k not in fill_missing and i.dtype not in fill_missing:</span>
<span class="c1">#     #                         continue</span>
<span class="c1">#     #                     filler = fill_missing.get(k, fill_missing[i.dtype])</span>
<span class="c1">#     #                     ds[k] = i.where(ds[&#39;_avail_&#39;]!=0, filler)</span>
<span class="c1">#     #             else:</span>
<span class="c1">#     #                 for k, i in ds.items():</span>
<span class="c1">#     #                     if ds.ALTID not in i.dims:</span>
<span class="c1">#     #                         continue</span>
<span class="c1">#     #                     ds[k] = i.where(ds[&#39;_avail_&#39;]!=0, fill_missing)</span>
<span class="c1">#     #     return ds</span>
<span class="c1">#</span>
<span class="c1">#     # @classmethod</span>
<span class="c1">#     # def from_idce(cls, df, crack=True, altnames=None, dim_name=None, alt_index=&#39;alt_idx&#39;, case_index=None, case_pointer=None):</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     Construct a Dataset from a sparse idca-format DataFrame.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Parameters</span>
<span class="c1">#     #     ----------</span>
<span class="c1">#     #     df : DataFrame</span>
<span class="c1">#     #         The input data should be an idca-format or idce-format DataFrame,</span>
<span class="c1">#     #         with the caseid&#39;s and altid&#39;s in a two-level pandas MultiIndex.</span>
<span class="c1">#     #     crack : bool, default False</span>
<span class="c1">#     #         If True, the `dissolve_zero_variance` method is applied before</span>
<span class="c1">#     #         repairing dtypes, to ensure that missing value are handled</span>
<span class="c1">#     #         properly.</span>
<span class="c1">#     #     altnames : Mapping, optional</span>
<span class="c1">#     #         If given as a mapping, links alternative codes to names.</span>
<span class="c1">#     #         An array or list of strings gives names for the alternatives,</span>
<span class="c1">#     #         sorted in the same order as the codes.</span>
<span class="c1">#     #     dim_name : str, optional</span>
<span class="c1">#     #         Name to apply to the sparse index dimension.</span>
<span class="c1">#     #     alt_index : str, default &#39;alt_idx&#39;</span>
<span class="c1">#     #         Add the alt index (position) for each sparse data row as a</span>
<span class="c1">#     #         coords array with this name.</span>
<span class="c1">#     #     case_index : str, optional</span>
<span class="c1">#     #         Add the case index (position) for each sparse data row as a</span>
<span class="c1">#     #         coords array with this name. If not given, this array is not</span>
<span class="c1">#     #         stored but it can still be reconstructed later from the case</span>
<span class="c1">#     #         pointers.</span>
<span class="c1">#     #     case_pointer : str, optional</span>
<span class="c1">#     #         Use this name for the case_ptr dimension, overriding the</span>
<span class="c1">#     #         default.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Returns</span>
<span class="c1">#     #     -------</span>
<span class="c1">#     #     Dataset</span>
<span class="c1">#     #</span>
<span class="c1">#     #     See Also</span>
<span class="c1">#     #     --------</span>
<span class="c1">#     #     Dataset.from_idca : Construct a dense Dataset from a idca-format DataFrame.</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     if df.index.nlevels != 2:</span>
<span class="c1">#     #         raise ValueError(&quot;source idce dataframe must have a two &quot;</span>
<span class="c1">#     #                          &quot;level MultiIndex giving case and alt id&#39;s&quot;)</span>
<span class="c1">#     #     caseidname, altidname = df.index.names</span>
<span class="c1">#     #     caseidname = caseidname or _CASEID</span>
<span class="c1">#     #     altidname = altidname or _ALTID</span>
<span class="c1">#     #     dim_name = dim_name or _CASEALT</span>
<span class="c1">#     #     case_pointer = case_pointer or _CASEPTR</span>
<span class="c1">#     #     ds = cls.from_dataframe(df.reset_index(drop=True).rename_axis(index=dim_name))</span>
<span class="c1">#     #     ds.coords[caseidname] = xr.DataArray(df.index.levels[0], dims=caseidname)</span>
<span class="c1">#     #     ds.coords[altidname] = xr.DataArray(df.index.levels[1], dims=altidname)</span>
<span class="c1">#     #     if case_index is not None:</span>
<span class="c1">#     #         ds.coords[case_index] = xr.DataArray(df.index.codes[0], dims=dim_name)</span>
<span class="c1">#     #     if alt_index is None:</span>
<span class="c1">#     #         raise ValueError(&#39;alt_index cannot be None&#39;)</span>
<span class="c1">#     #     ds.coords[alt_index] = xr.DataArray(df.index.codes[1], dims=dim_name)</span>
<span class="c1">#     #     ds.coords[case_pointer] = xr.DataArray(</span>
<span class="c1">#     #         np.where(np.diff(df.index.codes[0], prepend=np.nan, append=np.nan))[0],</span>
<span class="c1">#     #         dims=case_pointer,</span>
<span class="c1">#     #     )</span>
<span class="c1">#     #     ds.attrs[&#39;_exclude_dims_&#39;] = (caseidname, altidname, case_pointer)</span>
<span class="c1">#     #     ds.attrs[_CASEID] = caseidname</span>
<span class="c1">#     #     ds.attrs[_ALTID] = altidname</span>
<span class="c1">#     #     ds.attrs[_CASEALT] = dim_name</span>
<span class="c1">#     #     ds.attrs[_ALTIDX] = alt_index</span>
<span class="c1">#     #     ds.attrs[_CASEPTR] = case_pointer</span>
<span class="c1">#     #     ds = ds.drop_vars(dim_name)</span>
<span class="c1">#     #     if crack:</span>
<span class="c1">#     #         ds = ds.dissolve_zero_variance()</span>
<span class="c1">#     #     ds = ds.set_dtypes(df)</span>
<span class="c1">#     #     if altnames is not None:</span>
<span class="c1">#     #         ds = ds.set_altnames(altnames)</span>
<span class="c1">#     #     return ds</span>
<span class="c1">#</span>
<span class="c1">#     # @classmethod</span>
<span class="c1">#     # def from_idco(cls, df, alts=None):</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     Construct a Dataset from an idco-format DataFrame.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Parameters</span>
<span class="c1">#     #     ----------</span>
<span class="c1">#     #     df : DataFrame</span>
<span class="c1">#     #         The input data should be an idco-format DataFrame, with</span>
<span class="c1">#     #         the caseid&#39;s in a single-level index,</span>
<span class="c1">#     #     alts : Mapping or array-like, optional</span>
<span class="c1">#     #         If given as a mapping, links alternative codes to names.</span>
<span class="c1">#     #         An array or list of integers gives codes for the alternatives,</span>
<span class="c1">#     #         which are otherwise unnamed.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Returns</span>
<span class="c1">#     #     -------</span>
<span class="c1">#     #     Dataset</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     if df.index.nlevels != 1:</span>
<span class="c1">#     #         raise ValueError(&quot;source idco dataframe must have a one &quot;</span>
<span class="c1">#     #                          &quot;level Index giving case id&#39;s&quot;)</span>
<span class="c1">#     #     caseidname = df.index.name or &#39;index&#39;</span>
<span class="c1">#     #     ds = cls.construct(df, caseid=caseidname, alts=alts)</span>
<span class="c1">#     #     ds = ds.set_dtypes(df)</span>
<span class="c1">#     #     return ds</span>
<span class="c1">#</span>
<span class="c1">#     # def as_tree(self, label=&#39;main&#39;, exclude_dims=()):</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     Convert this Dataset to a DataTree.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     For |idco| and |idca| datasets, the result will generally be a</span>
<span class="c1">#     #     single-node tree.  For |idce| data, there will be</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Parameters</span>
<span class="c1">#     #     ----------</span>
<span class="c1">#     #     label : str, default &#39;main&#39;</span>
<span class="c1">#     #         Name to use for the root node in the tree.</span>
<span class="c1">#     #     exclude_dims : Tuple[str], optional</span>
<span class="c1">#     #         Exclude these dimensions, in addition to any</span>
<span class="c1">#     #         dimensions listed in the `_exclude_dims_` attribute.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Returns</span>
<span class="c1">#     #     -------</span>
<span class="c1">#     #     DataTree</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     if self.CASEPTR is not None:</span>
<span class="c1">#     #         case_index = case_ptr_to_indexes(self.dims[self.CASEALT], self[self.CASEPTR].values)</span>
<span class="c1">#     #         obj = self.assign({&#39;_case_index_&#39;: DataArray(case_index, dims=(self.CASEALT))})</span>
<span class="c1">#     #         tree = DataTree(**{label: obj.drop_dims(self.CASEID)})</span>
<span class="c1">#     #         ds = obj.keep_dims(self.CASEID)</span>
<span class="c1">#     #         ds.attrs.pop(&#39;_exclude_dims_&#39;, None)</span>
<span class="c1">#     #         ds.attrs.pop(&#39;_caseptr_&#39;, None)</span>
<span class="c1">#     #         ds.attrs.pop(&#39;_casealt_&#39;, None)</span>
<span class="c1">#     #         ds.attrs.pop(&#39;_alt_idx_&#39;, None)</span>
<span class="c1">#     #         tree.add_dataset(</span>
<span class="c1">#     #             &#39;idcoVars&#39;,</span>
<span class="c1">#     #             ds,</span>
<span class="c1">#     #             relationships=(</span>
<span class="c1">#     #                 f&quot;{label}._case_index_ -&gt; idcoVars.{self.CASEID}&quot;</span>
<span class="c1">#     #             )</span>
<span class="c1">#     #         )</span>
<span class="c1">#     #     else:</span>
<span class="c1">#     #         tree = DataTree(**{label: self})</span>
<span class="c1">#     #     return tree</span>
<span class="c1">#</span>
<span class="c1">#     # def setup_flow(self, *args, **kwargs):</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     Set up a new Flow for analysis using the structure of this DataTree.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     This method creates a new `DataTree` with only this Dataset as</span>
<span class="c1">#     #     the root Dataset labeled `main`.  All other arguments are passed</span>
<span class="c1">#     #     through to `DataTree.setup_flow`.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Returns</span>
<span class="c1">#     #     -------</span>
<span class="c1">#     #     Flow</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     return self.as_tree().setup_flow(*args, **kwargs)</span>
<span class="c1">#     #</span>
<span class="c1">#     # def caseids(self):</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     Access the caseids coordinates as an index.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Returns</span>
<span class="c1">#     #     -------</span>
<span class="c1">#     #     pd.Index</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     return self.indexes[self.CASEID]</span>
<span class="c1">#     #</span>
<span class="c1">#     # def altids(self):</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     Access the altids coordinates as an index.</span>
<span class="c1">#     #</span>
<span class="c1">#     #     Returns</span>
<span class="c1">#     #     -------</span>
<span class="c1">#     #     pd.Index</span>
<span class="c1">#     #     &quot;&quot;&quot;</span>
<span class="c1">#     #     return self.indexes[self.ALTID]</span>
<span class="c1">#</span>

<div class="viewcode-block" id="DataTree"><a class="viewcode-back" href="../../api/generated/larch.DataTree.html#larch.DataTree">[docs]</a><span class="k">class</span> <span class="nc">DataTree</span><span class="p">(</span><span class="n">_sharrow_DataTree</span><span class="p">):</span>

    <span class="n">DatasetType</span> <span class="o">=</span> <span class="n">Dataset</span>

<div class="viewcode-block" id="DataTree.__init__"><a class="viewcode-back" href="../../api/generated/larch.DataTree.html#larch.DataTree.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">root_node_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_funcs</span><span class="o">=</span><span class="p">(),</span>
        <span class="n">extra_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cache_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">relationships</span><span class="o">=</span><span class="p">(),</span>
        <span class="n">force_digitization</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="n">root_node_name</span><span class="o">=</span><span class="n">root_node_name</span><span class="p">,</span>
            <span class="n">extra_funcs</span><span class="o">=</span><span class="n">extra_funcs</span><span class="p">,</span>
            <span class="n">extra_vars</span><span class="o">=</span><span class="n">extra_vars</span><span class="p">,</span>
            <span class="n">cache_dir</span><span class="o">=</span><span class="n">cache_dir</span><span class="p">,</span>
            <span class="n">relationships</span><span class="o">=</span><span class="n">relationships</span><span class="p">,</span>
            <span class="n">force_digitization</span><span class="o">=</span><span class="n">force_digitization</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">dim_order</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_dataset</span><span class="o">.</span><span class="n">dc</span><span class="o">.</span><span class="n">CASEID</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_dataset</span><span class="o">.</span><span class="n">dc</span><span class="o">.</span><span class="n">ALTID</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim_order</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dim_order</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">idco_subtree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;idcoVars&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspaces</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspaces</span><span class="p">[</span><span class="s1">&#39;idcoVars&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dc</span><span class="o">.</span><span class="n">as_tree</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ALTID</span><span class="p">,</span> <span class="n">ignore_missing_dims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">CASEID</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;str : The _caseid_ dimension of the root Dataset.&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_dataset</span><span class="o">.</span><span class="n">dc</span><span class="o">.</span><span class="n">CASEID</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;no defined CASEID&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_CASEID</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ALTID</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;str : The _altid_ dimension of the root Dataset.&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_dataset</span><span class="o">.</span><span class="n">dc</span><span class="o">.</span><span class="n">ALTID</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;no defined ALTID&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_ALTID</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">CASEALT</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;str : The _casealt_ dimension of the root Dataset, if defined.&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_dataset</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">_CASEALT</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ALTIDX</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;str : The _alt_idx_ dimension of the root Dataset, if defined.&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_dataset</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">_ALTIDX</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">CASEPTR</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;str : The _caseptr_ dimension of the root Dataset, if defined.&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_dataset</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">_CASEPTR</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_cases</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;int : The size of the _caseid_ dimension of the root Dataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_dataset</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">CASEID</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_alts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;int : The size of the _altid_ dimension of the root Dataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_dataset</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ALTID</span><span class="p">]</span>

<div class="viewcode-block" id="DataTree.query_cases"><a class="viewcode-back" href="../../api/generated/larch.DataTree.query_cases.html#larch.DataTree.query_cases">[docs]</a>    <span class="k">def</span> <span class="nf">query_cases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new DataTree, with a query filter applied to the root Dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        query : str</span>
<span class="sd">            Python expressions to be evaluated against the data variables</span>
<span class="sd">            in the root dataset. The expressions will be evaluated using the pandas</span>
<span class="sd">            eval() function, and can contain any valid Python expressions but cannot</span>
<span class="sd">            contain any Python statements.</span>
<span class="sd">        parser : {&quot;pandas&quot;, &quot;python&quot;}, default: &quot;pandas&quot;</span>
<span class="sd">            The parser to use to construct the syntax tree from the expression.</span>
<span class="sd">            The default of &#39;pandas&#39; parses code slightly different than standard</span>
<span class="sd">            Python. Alternatively, you can parse an expression using the &#39;python&#39;</span>
<span class="sd">            parser to retain strict Python semantics.</span>
<span class="sd">        engine : {&quot;python&quot;, &quot;numexpr&quot;, None}, default: None</span>
<span class="sd">            The engine used to evaluate the expression. Supported engines are:</span>

<span class="sd">            - None: tries to use numexpr, falls back to python</span>
<span class="sd">            - &quot;numexpr&quot;: evaluates expressions using numexpr</span>
<span class="sd">            - &quot;python&quot;: performs operations as if you had evald in top level python</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataTree</span>
<span class="sd">            A new DataTree with the same contents as this DataTree, except each</span>
<span class="sd">            array of the root Dataset is indexed by the results of the query on</span>
<span class="sd">            the CASEID dimension.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.query_cases</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">root_dataset</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">root_dataset</span><span class="o">.</span><span class="n">dc</span><span class="o">.</span><span class="n">query_cases</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span></div>

    <span class="k">def</span> <span class="nf">caseids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Access the caseids coordinates as an index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_dataset</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">CASEID</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspaces</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">CASEID</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">indexes</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">CASEID</span><span class="p">]</span>
            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">altids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Access the altids coordinates as an index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_dataset</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ALTID</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspaces</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ALTID</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">indexes</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ALTID</span><span class="p">]</span>
            <span class="k">raise</span>

<div class="viewcode-block" id="DataTree.setup_flow"><a class="viewcode-back" href="../../api/generated/larch.DataTree.setup_flow.html#larch.DataTree.setup_flow">[docs]</a>    <span class="k">def</span> <span class="nf">setup_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set up a new Flow for analysis using the structure of this DataTree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        definition_spec : Dict[str,str]</span>
<span class="sd">            Gives the names and expressions that define the variables to</span>
<span class="sd">            create in this new `Flow`.</span>
<span class="sd">        cache_dir : Path-like, optional</span>
<span class="sd">            A location to write out generated python and numba code. If not</span>
<span class="sd">            provided, a unique temporary directory is created.</span>
<span class="sd">        name : str, optional</span>
<span class="sd">            The name of this Flow used for writing out cached files. If not</span>
<span class="sd">            provided, a unique name is generated. If `cache_dir` is given,</span>
<span class="sd">            be sure to avoid name conflicts with other flow&#39;s in the same</span>
<span class="sd">            directory.</span>
<span class="sd">        dtype : str, default &quot;float32&quot;</span>
<span class="sd">            The name of the numpy dtype that will be used for the output.</span>
<span class="sd">        boundscheck : bool, default False</span>
<span class="sd">            If True, boundscheck enables bounds checking for array indices, and</span>
<span class="sd">            out of bounds accesses will raise IndexError. The default is to not</span>
<span class="sd">            do bounds checking, which is faster but can produce garbage results</span>
<span class="sd">            or segfaults if there are problems, so try turning this on for</span>
<span class="sd">            debugging if you are getting unexplained errors or crashes.</span>
<span class="sd">        error_model : {&#39;numpy&#39;, &#39;python&#39;}, default &#39;numpy&#39;</span>
<span class="sd">            The error_model option controls the divide-by-zero behavior. Setting</span>
<span class="sd">            it to python causes divide-by-zero to raise exception like</span>
<span class="sd">            CPython. Setting it to numpy causes divide-by-zero to set the</span>
<span class="sd">            result to +/-inf or nan.</span>
<span class="sd">        nopython : bool, default True</span>
<span class="sd">            Compile using numba&#39;s `nopython` mode.  Provided for debugging only,</span>
<span class="sd">            as there&#39;s little point in turning this off for production code, as</span>
<span class="sd">            all the speed benefits of sharrow will be lost.</span>
<span class="sd">        fastmath : bool, default True</span>
<span class="sd">            If true, fastmath enables the use of &quot;fast&quot; floating point transforms,</span>
<span class="sd">            which can improve performance but can result in tiny distortions in</span>
<span class="sd">            results.  See numba docs for details.</span>
<span class="sd">        parallel : bool, default True</span>
<span class="sd">            Enable or disable parallel computation for certain functions.</span>
<span class="sd">        readme : str, optional</span>
<span class="sd">            A string to inject as a comment at the top of the flow Python file.</span>
<span class="sd">        flow_library : Mapping[str,Flow], optional</span>
<span class="sd">            An in-memory cache of precompiled Flow objects.  Using this can result</span>
<span class="sd">            in performance improvements when repeatedly using the same definitions.</span>
<span class="sd">        extra_hash_data : Tuple[Hashable], optional</span>
<span class="sd">            Additional data used for generating the flow hash.  Useful to prevent</span>
<span class="sd">            conflicts when using a flow_library with multiple similar flows.</span>
<span class="sd">        write_hash_audit : bool, default True</span>
<span class="sd">            Writes a hash audit log into a comment in the flow Python file, for</span>
<span class="sd">            debugging purposes.</span>
<span class="sd">        hashing_level : int, default 1</span>
<span class="sd">            Level of detail to write into flow hashes.  Increase detail to avoid</span>
<span class="sd">            hash conflicts for similar flows.  Level 2 adds information about</span>
<span class="sd">            names used in expressions and digital encodings to the flow hash,</span>
<span class="sd">            which prevents conflicts but requires more pre-computation to generate</span>
<span class="sd">            the hash.</span>
<span class="sd">        dim_exclude : Collection[str], optional</span>
<span class="sd">            Exclude these root dataset dimensions from this flow.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Flow</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;dim_exclude&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;_exclude_dims_&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dim_exclude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;_exclude_dims_&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">setup_flow</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">merge</span><span class="p">(</span>
        <span class="n">objects</span><span class="p">,</span>
        <span class="n">compat</span><span class="o">=</span> <span class="s2">&quot;no_conflicts&quot;</span><span class="p">,</span>
        <span class="n">join</span><span class="o">=</span> <span class="s2">&quot;outer&quot;</span><span class="p">,</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
        <span class="n">combine_attrs</span> <span class="o">=</span> <span class="s2">&quot;override&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">caseid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge any number of xarray objects into a single larch.Dataset as variables.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    objects : iterable of Dataset or iterable of DataArray or iterable of dict-like</span>
<span class="sd">        Merge together all variables from these objects. If any of them are</span>
<span class="sd">        DataArray objects, they must have a name.</span>

<span class="sd">    compat : {&quot;identical&quot;, &quot;equals&quot;, &quot;broadcast_equals&quot;, &quot;no_conflicts&quot;, &quot;override&quot;}, optional</span>
<span class="sd">        String indicating how to compare variables of the same name for</span>
<span class="sd">        potential conflicts:</span>
<span class="sd">        - &quot;broadcast_equals&quot;: all values must be equal when variables are</span>
<span class="sd">          broadcast against each other to ensure common dimensions.</span>
<span class="sd">        - &quot;equals&quot;: all values and dimensions must be the same.</span>
<span class="sd">        - &quot;identical&quot;: all values, dimensions and attributes must be the</span>
<span class="sd">          same.</span>
<span class="sd">        - &quot;no_conflicts&quot;: only values which are not null in both datasets</span>
<span class="sd">          must be equal. The returned dataset then contains the combination</span>
<span class="sd">          of all non-null values.</span>
<span class="sd">        - &quot;override&quot;: skip comparing and pick variable from first dataset</span>

<span class="sd">    join : {&quot;outer&quot;, &quot;inner&quot;, &quot;left&quot;, &quot;right&quot;, &quot;exact&quot;}, optional</span>
<span class="sd">        String indicating how to combine differing indexes in objects.</span>
<span class="sd">        - &quot;outer&quot;: use the union of object indexes</span>
<span class="sd">        - &quot;inner&quot;: use the intersection of object indexes</span>
<span class="sd">        - &quot;left&quot;: use indexes from the first object with each dimension</span>
<span class="sd">        - &quot;right&quot;: use indexes from the last object with each dimension</span>
<span class="sd">        - &quot;exact&quot;: instead of aligning, raise `ValueError` when indexes to be</span>
<span class="sd">          aligned are not equal</span>
<span class="sd">        - &quot;override&quot;: if indexes are of same size, rewrite indexes to be</span>
<span class="sd">          those of the first object with that dimension. Indexes for the same</span>
<span class="sd">          dimension must have the same size in all objects.</span>

<span class="sd">    fill_value : scalar or dict-like, optional</span>
<span class="sd">        Value to use for newly missing values. If a dict-like, maps</span>
<span class="sd">        variable names to fill values. Use a data array&#39;s name to</span>
<span class="sd">        refer to its values.</span>

<span class="sd">    combine_attrs : {&quot;drop&quot;, &quot;identical&quot;, &quot;no_conflicts&quot;, &quot;drop_conflicts&quot;, \</span>
<span class="sd">                    &quot;override&quot;} or callable, default: &quot;override&quot;</span>
<span class="sd">        A callable or a string indicating how to combine attrs of the objects being</span>
<span class="sd">        merged:</span>
<span class="sd">        - &quot;drop&quot;: empty attrs on returned Dataset.</span>
<span class="sd">        - &quot;identical&quot;: all attrs must be the same on every object.</span>
<span class="sd">        - &quot;no_conflicts&quot;: attrs from all objects are combined, any that have</span>
<span class="sd">          the same name must also have the same value.</span>
<span class="sd">        - &quot;drop_conflicts&quot;: attrs from all objects are combined, any that have</span>
<span class="sd">          the same name but different values are dropped.</span>
<span class="sd">        - &quot;override&quot;: skip comparing and copy attrs from the first dataset to</span>
<span class="sd">          the result.</span>
<span class="sd">        If a callable, it must expect a sequence of ``attrs`` dicts and a context object</span>
<span class="sd">        as its only parameters.</span>

<span class="sd">    caseid : str, optional, keyword only</span>
<span class="sd">        This named dimension will be marked as the &#39;_caseid_&#39; dimension.</span>

<span class="sd">    alts : str or Mapping or array-like, keyword only</span>
<span class="sd">        If given as a str, this named dimension will be marked as the</span>
<span class="sd">        &#39;_altid_&#39; dimension.  Otherwise, give a Mapping that defines</span>
<span class="sd">        alternative names and (integer) codes or an array of codes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dataset</span>
<span class="sd">        Dataset with combined variables from each object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">construct</span><span class="p">(</span>
        <span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">objects</span><span class="p">,</span>
            <span class="n">compat</span><span class="o">=</span><span class="s2">&quot;no_conflicts&quot;</span><span class="p">,</span>
            <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
            <span class="n">combine_attrs</span><span class="o">=</span><span class="s2">&quot;override&quot;</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">caseid</span><span class="o">=</span><span class="n">caseid</span><span class="p">,</span>
        <span class="n">alts</span><span class="o">=</span><span class="n">alts</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">choice_avail_summary</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">availability_co_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a summary of choice and availability statistics.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dataset : Dataset</span>
<span class="sd">        The loaded dataset to summarize, which should have</span>
<span class="sd">        `ch` and `av` variables.</span>
<span class="sd">    graph : NestingTree, optional</span>
<span class="sd">        The nesting graph.</span>
<span class="sd">    availability_co_vars : dict, optional</span>
<span class="sd">        Also attach the definition of the availability conditions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;ch&#39;</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
            <span class="n">ch_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;ch&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ch_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">av_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;av&#39;</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">..numba.cascading</span> <span class="kn">import</span> <span class="n">array_av_cascade</span><span class="p">,</span> <span class="n">array_ch_cascade</span>

        <span class="n">ch_</span> <span class="o">=</span> <span class="n">array_ch_cascade</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ch&#39;</span><span class="p">),</span> <span class="n">graph</span><span class="p">)</span>
        <span class="n">av_</span> <span class="o">=</span> <span class="n">array_av_cascade</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;av&#39;</span><span class="p">),</span> <span class="n">graph</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ch_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">ch_</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">av_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">av</span> <span class="o">=</span> <span class="n">av_</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">av</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">arr_wt</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;wt&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">arr_wt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ch_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ch_w</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">((</span><span class="n">ch_</span> <span class="o">*</span> <span class="n">arr_wt</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ch_w</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">av_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">av_w</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">((</span><span class="n">av_</span> <span class="o">*</span> <span class="n">arr_wt</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">av_w</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">show_wt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ch</span> <span class="o">!=</span> <span class="n">ch_w</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ch_w</span> <span class="o">=</span> <span class="n">ch</span>
        <span class="n">av_w</span> <span class="o">=</span> <span class="n">av</span>
        <span class="n">show_wt</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">av_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ch_</span><span class="p">[</span><span class="n">av_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">ch_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ch_</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ch_but_not_av</span> <span class="o">=</span> <span class="n">ch_</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arr_wt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ch_but_not_av_w</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">((</span><span class="n">ch_</span> <span class="o">*</span> <span class="n">arr_wt</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">ch_</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ch_but_not_av_w</span> <span class="o">=</span> <span class="n">ch_but_not_av</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ch_but_not_av</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ch_but_not_av_w</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
    <span class="n">od</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">standard_sort</span>
        <span class="n">od</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">standard_sort_names</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">dc</span><span class="o">.</span><span class="n">altids</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dataset</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;alt_names&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">od</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;alt_names&#39;</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">show_wt</span><span class="p">:</span>
        <span class="n">od</span><span class="p">[</span><span class="s1">&#39;chosen weighted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">ch_w</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">od</span><span class="p">[</span><span class="s1">&#39;chosen unweighted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">od</span><span class="p">[</span><span class="s1">&#39;available weighted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">av_w</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">od</span><span class="p">[</span><span class="s1">&#39;available unweighted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">od</span><span class="p">[</span><span class="s1">&#39;chosen&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">od</span><span class="p">[</span><span class="s1">&#39;available&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ch_but_not_av</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">show_wt</span><span class="p">:</span>
            <span class="n">od</span><span class="p">[</span><span class="s1">&#39;chosen but not available weighted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">ch_but_not_av_w</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">od</span><span class="p">[</span><span class="s1">&#39;chosen but not available unweighted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">ch_but_not_av</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">od</span><span class="p">[</span><span class="s1">&#39;chosen but not available&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">ch_but_not_av</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">availability_co_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">od</span><span class="p">[</span><span class="s1">&#39;availability condition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="n">availability_co_vars</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">availability_co_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
        <span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">od</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">totals</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">root_id</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">root_id</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">totals</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">tot</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="s1">&#39;chosen&#39;</span><span class="p">,</span>
            <span class="s1">&#39;chosen weighted&#39;</span><span class="p">,</span>
            <span class="s1">&#39;chosen unweighted&#39;</span><span class="p">,</span>
            <span class="s1">&#39;chosen but not available&#39;</span><span class="p">,</span>
            <span class="s1">&#39;chosen but not available weighted&#39;</span><span class="p">,</span>
            <span class="s1">&#39;chosen but not available unweighted&#39;</span><span class="p">,</span>
            <span class="s1">&#39;chosen thus available&#39;</span><span class="p">,</span>
            <span class="s1">&#39;not available so not chosen&#39;</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">tot</span> <span class="ow">in</span> <span class="n">totals</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;&lt; Total All Alternatives &gt;&#39;</span><span class="p">,</span> <span class="n">tot</span><span class="p">]</span> <span class="o">=</span> <span class="n">totals</span><span class="p">[</span><span class="n">tot</span><span class="p">]</span>

    <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;&lt; Total All Alternatives &gt;&#39;</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;&lt; Total All Alternatives &gt;&#39;</span><span class="p">,</span> <span class="p">:])]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">result</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;_root_&#39;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;availability condition&#39;</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;availability condition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;availability condition&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="s1">&#39;chosen&#39;</span><span class="p">,</span>
            <span class="s1">&#39;chosen but not available&#39;</span><span class="p">,</span>
            <span class="s1">&#39;chosen thus available&#39;</span><span class="p">,</span>
            <span class="s1">&#39;not available so not chosen&#39;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="s1">&#39;available&#39;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">result</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>



<span class="c1"># @nb.njit</span>
<span class="c1"># def ce_dissolve_zero_variance(ce_data, ce_caseptr):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#     Parameters</span>
<span class="c1">#     ----------</span>
<span class="c1">#     ce_data : array-like, shape [n_casealts] one-dim only</span>
<span class="c1">#     ce_altidx</span>
<span class="c1">#     ce_caseptr</span>
<span class="c1">#     n_alts</span>
<span class="c1">#</span>
<span class="c1">#     Returns</span>
<span class="c1">#     -------</span>
<span class="c1">#     out : ndarray</span>
<span class="c1">#     flag : int</span>
<span class="c1">#         1 if variance was detected, 0 if no variance was found and</span>
<span class="c1">#         the `out` array is valid.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     failed = 0</span>
<span class="c1">#     if ce_caseptr.ndim == 2:</span>
<span class="c1">#         ce_caseptr1 = ce_caseptr[:,-1]</span>
<span class="c1">#     else:</span>
<span class="c1">#         ce_caseptr1 = ce_caseptr[1:]</span>
<span class="c1">#     shape = (ce_caseptr1.shape[0], )</span>
<span class="c1">#     out = np.zeros(shape, dtype=ce_data.dtype)</span>
<span class="c1">#     c = 0</span>
<span class="c1">#     out[0] = ce_data[0]</span>
<span class="c1">#     for row in range(ce_data.shape[0]):</span>
<span class="c1">#         if row == ce_caseptr1[c]:</span>
<span class="c1">#             c += 1</span>
<span class="c1">#             out[c] = ce_data[row]</span>
<span class="c1">#         else:</span>
<span class="c1">#             if out[c] != ce_data[row]:</span>
<span class="c1">#                 failed = 1</span>
<span class="c1">#                 break</span>
<span class="c1">#     return out, failed</span>


<span class="c1"># @nb.njit</span>
<span class="c1"># def case_ptr_to_indexes(n_casealts, case_ptrs):</span>
<span class="c1">#     case_index = np.zeros(n_casealts, dtype=np.int64)</span>
<span class="c1">#     for c in range(case_ptrs.shape[0]-1):</span>
<span class="c1">#         case_index[case_ptrs[c]:case_ptrs[c + 1]] = c</span>
<span class="c1">#     return case_index</span>
</pre></div>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Jeffrey Newman<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>