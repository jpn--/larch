
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>xarray.core.dataset &#8212; v5.7.0</title>
    
  <link href="../../../_static/css/theme.css" rel="stylesheet">
  <link href="../../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/larch-book.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/togglebutton.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../../_static/sphinx-thebe.js"></script>
    <link rel="shortcut icon" href="../../../_static/larch_favicon.png"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    
      
      <link rel="icon" sizes="32x32" href="../../../_static/img/larch_favicon.png">
      
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../../_static/larch-logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">v5.7.0</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search these docs..." aria-label="Search these docs..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Users Guide
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../installation.html">
   Installing Larch
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../user-guide/choice-models.html">
   Choice Models
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../user-guide/data-fundamentals.html">
     Data Fundamentals
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../user-guide/linear-funcs.html">
     Linear Functions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../user-guide/machine-learning.html">
     Machine Learning
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../bibliography.html">
   References
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  API Reference
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../api/~data.html">
   Data
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../api/dataset.html">
     Dataset
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
    <label for="toctree-checkbox-3">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.Dataset.html">
       larch.Dataset
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.Dataset.construct.html">
       larch.Dataset.construct
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.Dataset.dims.html">
       larch.Dataset.dims
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.Dataset.sizes.html">
       larch.Dataset.sizes
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.Dataset.data_vars.html">
       larch.Dataset.data_vars
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.Dataset.coords.html">
       larch.Dataset.coords
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.Dataset.attrs.html">
       larch.Dataset.attrs
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.Dataset.encoding.html">
       larch.Dataset.encoding
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.Dataset.indexes.html">
       larch.Dataset.indexes
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.Dataset.chunks.html">
       larch.Dataset.chunks
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.Dataset.chunksizes.html">
       larch.Dataset.chunksizes
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.Dataset.nbytes.html">
       larch.Dataset.nbytes
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.Dataset.set_dtypes.html">
       larch.Dataset.set_dtypes
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../api/datatree.html">
     DataTree
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
    <label for="toctree-checkbox-4">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.DataTree.html">
       larch.DataTree
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.DataTree.root_node_name.html">
       larch.DataTree.root_node_name
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.DataTree.subspaces.html">
       larch.DataTree.subspaces
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.DataTree.relationships_are_digitized.html">
       larch.DataTree.relationships_are_digitized
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.DataTree.n_cases.html">
       larch.DataTree.n_cases
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.DataTree.n_alts.html">
       larch.DataTree.n_alts
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.DataTree.CASEID.html">
       larch.DataTree.CASEID
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.DataTree.ALTID.html">
       larch.DataTree.ALTID
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.DataTree.add_dataset.html">
       larch.DataTree.add_dataset
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.DataTree.add_relationship.html">
       larch.DataTree.add_relationship
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.DataTree.digitize_relationships.html">
       larch.DataTree.digitize_relationships
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.DataTree.query_cases.html">
       larch.DataTree.query_cases
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.DataTree.replace_datasets.html">
       larch.DataTree.replace_datasets
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.DataTree.setup_flow.html">
       larch.DataTree.setup_flow
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../api/dataframes.html">
     DataFrames
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
    <label for="toctree-checkbox-5">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.DataFrames.html">
       larch.DataFrames
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../api/~models.html">
   Models
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../api/model.html">
     Model
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
    <label for="toctree-checkbox-7">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.html">
       larch.numba.Model
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.datatree.html">
       larch.numba.Model.datatree
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.dataset.html">
       larch.numba.Model.dataset
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.n_cases.html">
       larch.numba.Model.n_cases
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.choice_ca_var.html">
       larch.numba.Model.choice_ca_var
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.choice_co_vars.html">
       larch.numba.Model.choice_co_vars
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.choice_co_code.html">
       larch.numba.Model.choice_co_code
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.availability_ca_var.html">
       larch.numba.Model.availability_ca_var
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.availability_co_vars.html">
       larch.numba.Model.availability_co_vars
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.utility_ca.html">
       larch.numba.Model.utility_ca
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.utility_co.html">
       larch.numba.Model.utility_co
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.quantity_ca.html">
       larch.numba.Model.quantity_ca
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.pf.html">
       larch.numba.Model.pf
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.most_recent_estimation_result.html">
       larch.numba.Model.most_recent_estimation_result
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.possible_overspecification.html">
       larch.numba.Model.possible_overspecification
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.set_values.html">
       larch.numba.Model.set_values
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.lock_value.html">
       larch.numba.Model.lock_value
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.set_cap.html">
       larch.numba.Model.set_cap
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.remove_unused_parameters.html">
       larch.numba.Model.remove_unused_parameters
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.maximize_loglike.html">
       larch.numba.Model.maximize_loglike
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.calculate_parameter_covariance.html">
       larch.numba.Model.calculate_parameter_covariance
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.loglike_nil.html">
       larch.numba.Model.loglike_nil
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.loglike_null.html">
       larch.numba.Model.loglike_null
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.rho_sq_nil.html">
       larch.numba.Model.rho_sq_nil
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.rho_sq_null.html">
       larch.numba.Model.rho_sq_null
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.parameter_summary.html">
       larch.numba.Model.parameter_summary
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.estimation_statistics.html">
       larch.numba.Model.estimation_statistics
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.to_xlsx.html">
       larch.numba.Model.to_xlsx
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.bhhh.html">
       larch.numba.Model.bhhh
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.check_d_loglike.html">
       larch.numba.Model.check_d_loglike
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.d_loglike.html">
       larch.numba.Model.d_loglike
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.d_loglike_casewise.html">
       larch.numba.Model.d_loglike_casewise
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.loglike.html">
       larch.numba.Model.loglike
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.loglike_casewise.html">
       larch.numba.Model.loglike_casewise
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.logsums.html">
       larch.numba.Model.logsums
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.probability.html">
       larch.numba.Model.probability
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.quantity.html">
       larch.numba.Model.quantity
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.total_weight.html">
       larch.numba.Model.total_weight
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.numba.Model.utility.html">
       larch.numba.Model.utility
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../api/linear.html">
     Linear Functions
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../api/nesting.html">
     NestingTree
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
    <label for="toctree-checkbox-8">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.model.tree.NestingTree.html">
       larch.model.tree.NestingTree
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.model.tree.NestingTree.new_node.html">
       larch.model.tree.NestingTree.new_node
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.model.tree.NestingTree.add_node.html">
       larch.model.tree.NestingTree.add_node
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.model.tree.NestingTree.remove_node.html">
       larch.model.tree.NestingTree.remove_node
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.model.tree.NestingTree.add_edge.html">
       larch.model.tree.NestingTree.add_edge
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.model.tree.NestingTree.remove_edge.html">
       larch.model.tree.NestingTree.remove_edge
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../api/modelgroup.html">
     ModelGroup
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
    <label for="toctree-checkbox-9">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.model.model_group.ModelGroup.html">
       larch.model.model_group.ModelGroup
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.model.model_group.ModelGroup.n_cases.html">
       larch.model.model_group.ModelGroup.n_cases
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.model.model_group.ModelGroup.set_values.html">
       larch.model.model_group.ModelGroup.set_values
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.model.model_group.ModelGroup.total_weight.html">
       larch.model.model_group.ModelGroup.total_weight
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.model.model_group.ModelGroup.loglike.html">
       larch.model.model_group.ModelGroup.loglike
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.model.model_group.ModelGroup.loglike2.html">
       larch.model.model_group.ModelGroup.loglike2
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../api/generated/larch.model.model_group.ModelGroup.to_xlsx.html">
       larch.model.model_group.ModelGroup.to_xlsx
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Examples
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../example/mtc.html">
   MTC Mode Choice
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../example/000_mtc_data.html">
     MTC Work Mode Choice Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../example/001_mnl.html">
     1: MTC MNL Mode Choice
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../example/002_mtc.html">
     2: MTC MNL Mode Choice, Motorized
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../example/017A_mnl_segmented.html">
     17a: Market Segmentatation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../example/017_mnl_final.html">
     17: MTC Expanded MNL Mode Choice
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../example/022-nl.html">
     22: MTC Motorized and Non-Motorized Nested Mode Choice
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../example/028-nl.html">
     28: MTC Motorized - Shared Ride - Non-Motorized Nested Mode Choice
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../example/swissmetro.html">
   Swissmetro
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/>
  <label for="toctree-checkbox-11">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../example/101_swissmetro_mnl.html">
     101: Swissmetro MNL Mode Choice
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../example/102-swissmetro-weighted.html">
     102: Swissmetro Weighted MNL Mode Choice
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../example/109-swissmetro-nl.html">
     109: Swissmetro Nested Logit Mode Choice
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../example/exampville.html">
   Exampville
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/>
  <label for="toctree-checkbox-12">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../example/200_exampville.html">
     200: Exampville Simulated Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../example/201_exville_mode_choice.html">
     201: Exampville Mode Choice
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../example/202_exville_mc_logsums.html">
     202: Exampville Mode Choice Logsums
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../example/203_exville_dest.html">
     203: Exampville Destination Choice
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../example/itinerary.html">
   Itinerary Choice
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/>
  <label for="toctree-checkbox-13">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../example/300_itinerary.html">
     300: Itinerary Choice Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../example/301_itin_mnl.html">
     301: Itinerary Choice using MNL
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../example/legacy.html">
   Legacy Examples
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" type="checkbox"/>
  <label for="toctree-checkbox-14">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../example/legacy/mtc.html">
     MTC Mode Choice Examples
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" type="checkbox"/>
    <label for="toctree-checkbox-15">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/000_mtc_data.html">
       MTC Work Mode Choice Data
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/001.mtc.html">
       1: MTC MNL Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/002_mtc.html">
       2: MTC MNL Mode Choice, Motorized
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/003_mtc.html">
       3: MTC MNL Mode Choice, Zeroed Shared
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/005_mtc.html">
       5: MTC MNL Mode Choice, Motorized Travel Time
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/006_mtc.html">
       6: MTC MNL Mode Choice, Motorized Times
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/007_mtc.html">
       7: MTC MNL Mode Choice, Diminishing OVTT by Distance
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/008_mtc.html">
       8: MTC MNL Mode Choice, TTR = 2.5
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/009_mtc.html">
       9: MTC MNL Mode Choice, TTR = 4.0
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/010_mtc.html">
       10: MTC MNL Mode Choice, Autos per Household
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/011_mtc.html">
       11: MTC MNL Mode Choice, Vehicle by Worker
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/012_mtc.html">
       12: MTC MNL Mode Choice, Autos per Adult
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/013_mtc.html">
       13: MTC MNL Mode Choice, CBD
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/014_mtc.html">
       14: MTC MNL Mode Choice, Work Zone Density
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/015_mtc.html">
       15: MTC MNL Mode Choice, CBD and Work Zone Density
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/016_mtc.html">
       16: MTC MNL Mode Choice, Cost by Income
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/017A_mtc.html">
       17A: MTC MNL Mode Choice, Segmented for 1 or fewer cars
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/017B_mtc.html">
       17B: MTC MNL Mode Choice, Segmented for 2 or more cars
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/017C_mtc.html">
       17C: MTC MNL Mode Choice, Segmented for Males
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/017D_mtc.html">
       17D: MTC MNL Mode Choice, Segmented for Females
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/017_mtc.html">
       17: MTC Expanded MNL Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/018_mtc.html">
       18: MTC Motorized Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/019_mtc.html">
       19: MTC Private Auto Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/020_mtc.html">
       20: MTC Shared Ride Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/021_mtc.html">
       21: MTC Non-Motorized Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/022_mtc.html">
       22: MTC Motorized and Non-Motorized Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/023_mtc.html">
       23W: MTC Private Auto - Non-Motorized Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/024_mtc.html">
       23W: MTC Shared Ride - Non-Motorized Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/025_mtc.html">
       25: MTC Private Auto - Motorized Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/026_mtc.html">
       26: MTC Shared Ride - Motorized Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/027_mtc.html">
       27: MTC Shared Ride - Private Auto Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/028_mtc.html">
       28: MTC Motorized - Shared Ride - Non-Motorized Nested Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/029_mtc.html">
       29: MTC Motorized - Shared Ride - Private Auto Nested Mode Choice
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../example/legacy/swissmetro.html">
     Swissmetro Examples
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" type="checkbox"/>
    <label for="toctree-checkbox-16">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/101_mnl.html">
       101: Swissmetro MNL Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/102_mnl_weighted.html">
       102: Swissmetro Weighted MNL Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/107_latent_class.html">
       107: Latent Class Models
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/109_nl.html">
       109: Swissmetro Nested Logit Mode Choice
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/111_cnl.html">
       111: Swissmetro Cross-Nested Logit Mode Choice
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../example/legacy/itinerary.html">
     Itinerary Choice Examples
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" type="checkbox"/>
    <label for="toctree-checkbox-17">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/300L_itinerary.html">
       300L: Itinerary Choice Data
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/301_itin_mnl.html">
       301: Itinerary Choice using MNL
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../example/legacy/302_itin_nl.html">
       302: Itinerary Choice using Simple Nested Logit
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/jpn--/larch"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/jpn--/larch/issues/new?title=Issue%20on%20page%20%2F_modules/xarray/core/dataset.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            
              <div>
                
  <h1>Source code for xarray.core.dataset</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">html</span> <span class="kn">import</span> <span class="n">escape</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">methodcaller</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">PathLike</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Collection</span><span class="p">,</span>
    <span class="n">DefaultDict</span><span class="p">,</span>
    <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">Literal</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">MutableMapping</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
    <span class="n">overload</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>

<span class="kn">from</span> <span class="nn">..coding.calendar_ops</span> <span class="kn">import</span> <span class="n">convert_calendar</span><span class="p">,</span> <span class="n">interp_calendar</span>
<span class="kn">from</span> <span class="nn">..coding.cftimeindex</span> <span class="kn">import</span> <span class="n">CFTimeIndex</span><span class="p">,</span> <span class="n">_parse_array_of_cftime_strings</span>
<span class="kn">from</span> <span class="nn">..plot.dataset_plot</span> <span class="kn">import</span> <span class="n">_Dataset_PlotMethods</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">alignment</span><span class="p">,</span>
    <span class="n">dtypes</span><span class="p">,</span>
    <span class="n">duck_array_ops</span><span class="p">,</span>
    <span class="n">formatting</span><span class="p">,</span>
    <span class="n">formatting_html</span><span class="p">,</span>
    <span class="n">groupby</span><span class="p">,</span>
    <span class="n">ops</span><span class="p">,</span>
    <span class="n">resample</span><span class="p">,</span>
    <span class="n">rolling</span><span class="p">,</span>
    <span class="n">utils</span><span class="p">,</span>
    <span class="n">weighted</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.alignment</span> <span class="kn">import</span> <span class="n">_broadcast_helper</span><span class="p">,</span> <span class="n">_get_broadcast_dims_map_common_coords</span><span class="p">,</span> <span class="n">align</span>
<span class="kn">from</span> <span class="nn">.arithmetic</span> <span class="kn">import</span> <span class="n">DatasetArithmetic</span>
<span class="kn">from</span> <span class="nn">.common</span> <span class="kn">import</span> <span class="n">DataWithCoords</span><span class="p">,</span> <span class="n">_contains_datetime_like_objects</span><span class="p">,</span> <span class="n">get_chunksizes</span>
<span class="kn">from</span> <span class="nn">.computation</span> <span class="kn">import</span> <span class="n">unify_chunks</span>
<span class="kn">from</span> <span class="nn">.coordinates</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DatasetCoordinates</span><span class="p">,</span>
    <span class="n">assert_coordinate_consistent</span><span class="p">,</span>
    <span class="n">remap_label_indexers</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.duck_array_ops</span> <span class="kn">import</span> <span class="n">datetime_to_numeric</span>
<span class="kn">from</span> <span class="nn">.indexes</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Index</span><span class="p">,</span>
    <span class="n">Indexes</span><span class="p">,</span>
    <span class="n">PandasIndex</span><span class="p">,</span>
    <span class="n">PandasMultiIndex</span><span class="p">,</span>
    <span class="n">default_indexes</span><span class="p">,</span>
    <span class="n">isel_variable_and_index</span><span class="p">,</span>
    <span class="n">propagate_indexes</span><span class="p">,</span>
    <span class="n">remove_unused_levels_categories</span><span class="p">,</span>
    <span class="n">roll_index</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.indexing</span> <span class="kn">import</span> <span class="n">is_fancy_indexer</span>
<span class="kn">from</span> <span class="nn">.merge</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">dataset_merge_method</span><span class="p">,</span>
    <span class="n">dataset_update_method</span><span class="p">,</span>
    <span class="n">merge_coordinates_without_align</span><span class="p">,</span>
    <span class="n">merge_data_and_coords</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.missing</span> <span class="kn">import</span> <span class="n">get_clean_interp_index</span>
<span class="kn">from</span> <span class="nn">.npcompat</span> <span class="kn">import</span> <span class="n">QUANTILE_METHODS</span><span class="p">,</span> <span class="n">ArrayLike</span>
<span class="kn">from</span> <span class="nn">.options</span> <span class="kn">import</span> <span class="n">OPTIONS</span><span class="p">,</span> <span class="n">_get_keep_attrs</span>
<span class="kn">from</span> <span class="nn">.pycompat</span> <span class="kn">import</span> <span class="n">is_duck_dask_array</span><span class="p">,</span> <span class="n">sparse_array_type</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Default</span><span class="p">,</span>
    <span class="n">Frozen</span><span class="p">,</span>
    <span class="n">HybridMappingProxy</span><span class="p">,</span>
    <span class="n">OrderedSet</span><span class="p">,</span>
    <span class="n">_default</span><span class="p">,</span>
    <span class="n">decode_numpy_dict_values</span><span class="p">,</span>
    <span class="n">drop_dims_from_indexers</span><span class="p">,</span>
    <span class="n">either_dict_or_kwargs</span><span class="p">,</span>
    <span class="n">hashable</span><span class="p">,</span>
    <span class="n">infix_dims</span><span class="p">,</span>
    <span class="n">is_dict_like</span><span class="p">,</span>
    <span class="n">is_scalar</span><span class="p">,</span>
    <span class="n">maybe_wrap_array</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.variable</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">IndexVariable</span><span class="p">,</span>
    <span class="n">Variable</span><span class="p">,</span>
    <span class="n">as_variable</span><span class="p">,</span>
    <span class="n">assert_unique_multiindex_level_names</span><span class="p">,</span>
    <span class="n">broadcast_variables</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">..backends</span> <span class="kn">import</span> <span class="n">AbstractDataStore</span><span class="p">,</span> <span class="n">ZarrStore</span>
    <span class="kn">from</span> <span class="nn">.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>
    <span class="kn">from</span> <span class="nn">.merge</span> <span class="kn">import</span> <span class="n">CoercibleMapping</span>
    <span class="kn">from</span> <span class="nn">.types</span> <span class="kn">import</span> <span class="n">T_Xarray</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">dask.delayed</span> <span class="kn">import</span> <span class="n">Delayed</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="n">Delayed</span> <span class="o">=</span> <span class="kc">None</span>


<span class="c1"># list of attributes of pd.DatetimeIndex that are ndarrays of time info</span>
<span class="n">_DATETIMEINDEX_COMPONENTS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;year&quot;</span><span class="p">,</span>
    <span class="s2">&quot;month&quot;</span><span class="p">,</span>
    <span class="s2">&quot;day&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hour&quot;</span><span class="p">,</span>
    <span class="s2">&quot;minute&quot;</span><span class="p">,</span>
    <span class="s2">&quot;second&quot;</span><span class="p">,</span>
    <span class="s2">&quot;microsecond&quot;</span><span class="p">,</span>
    <span class="s2">&quot;nanosecond&quot;</span><span class="p">,</span>
    <span class="s2">&quot;date&quot;</span><span class="p">,</span>
    <span class="s2">&quot;time&quot;</span><span class="p">,</span>
    <span class="s2">&quot;dayofyear&quot;</span><span class="p">,</span>
    <span class="s2">&quot;weekofyear&quot;</span><span class="p">,</span>
    <span class="s2">&quot;dayofweek&quot;</span><span class="p">,</span>
    <span class="s2">&quot;quarter&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="k">def</span> <span class="nf">_get_virtual_variable</span><span class="p">(</span>
    <span class="n">variables</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">level_vars</span><span class="p">:</span> <span class="n">Mapping</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">:</span> <span class="n">Mapping</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Get a virtual variable (e.g., &#39;time.year&#39; or a MultiIndex level)</span>
<span class="sd">    from a dict of xarray.Variable objects (if possible)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">level_vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">level_vars</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">dim_sizes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dim_sizes</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim_sizes</span><span class="p">[</span><span class="n">key</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">IndexVariable</span><span class="p">((</span><span class="n">key</span><span class="p">,),</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">variable</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="n">split_key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">var_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">ref_name</span><span class="p">,</span> <span class="n">var_name</span> <span class="o">=</span> <span class="n">split_key</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ref_name</span><span class="p">,</span> <span class="n">var_name</span> <span class="o">=</span> <span class="n">key</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ref_name</span> <span class="ow">in</span> <span class="n">level_vars</span><span class="p">:</span>
        <span class="n">dim_var</span> <span class="o">=</span> <span class="n">variables</span><span class="p">[</span><span class="n">level_vars</span><span class="p">[</span><span class="n">ref_name</span><span class="p">]]</span>
        <span class="n">ref_var</span> <span class="o">=</span> <span class="n">dim_var</span><span class="o">.</span><span class="n">to_index_variable</span><span class="p">()</span><span class="o">.</span><span class="n">get_level_variable</span><span class="p">(</span><span class="n">ref_name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ref_var</span> <span class="o">=</span> <span class="n">variables</span><span class="p">[</span><span class="n">ref_name</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">var_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">virtual_var</span> <span class="o">=</span> <span class="n">ref_var</span>
        <span class="n">var_name</span> <span class="o">=</span> <span class="n">key</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">_contains_datetime_like_objects</span><span class="p">(</span><span class="n">ref_var</span><span class="p">):</span>
            <span class="n">ref_var</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">ref_var</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ref_var</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ref_var</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
        <span class="n">virtual_var</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">ref_var</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ref_name</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">virtual_var</span>


<span class="k">def</span> <span class="nf">calculate_dimensions</span><span class="p">(</span><span class="n">variables</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Variable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Calculate the dimensions corresponding to a set of variables.</span>

<span class="sd">    Returns dictionary mapping from dimension names to sizes. Raises ValueError</span>
<span class="sd">    if any of the dimension sizes conflict.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">last_used</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">scalar_vars</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">scalar_vars</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;dimension </span><span class="si">{</span><span class="n">dim</span><span class="si">!r}</span><span class="s2"> already exists as a scalar variable&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
                <span class="n">dims</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>
                <span class="n">last_used</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">elif</span> <span class="n">dims</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">!=</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;conflicting sizes for dimension </span><span class="si">{</span><span class="n">dim</span><span class="si">!r}</span><span class="s2">: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;length </span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s2"> on </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> and length </span><span class="si">{</span><span class="n">dims</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="si">}</span><span class="s2"> on </span><span class="si">{</span><span class="n">last_used</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
    <span class="k">return</span> <span class="n">dims</span>


<span class="k">def</span> <span class="nf">merge_indexes</span><span class="p">(</span>
    <span class="n">indexes</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]],</span>
    <span class="n">variables</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Variable</span><span class="p">],</span>
    <span class="n">coord_names</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
    <span class="n">append</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Merge variables into multi-indexes.</span>

<span class="sd">    Not public API. Used in Dataset and DataArray set_index</span>
<span class="sd">    methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vars_to_replace</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">vars_to_remove</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dims_to_replace</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">error_msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not the name of an existing variable.&quot;</span>

    <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">var_names</span> <span class="ow">in</span> <span class="n">indexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">var_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">var_names</span><span class="p">]</span>

        <span class="n">names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">codes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">levels</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">current_index_variable</span> <span class="o">=</span> <span class="n">variables</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">var_names</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">variables</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">current_index_variable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="o">!=</span> <span class="n">current_index_variable</span><span class="o">.</span><span class="n">dims</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;dimension mismatch between </span><span class="si">{</span><span class="n">dim</span><span class="si">!r}</span><span class="s2"> </span><span class="si">{</span><span class="n">current_index_variable</span><span class="o">.</span><span class="n">dims</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">n</span><span class="si">!r}</span><span class="s2"> </span><span class="si">{</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">current_index_variable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">append</span><span class="p">:</span>
            <span class="n">current_index</span> <span class="o">=</span> <span class="n">current_index_variable</span><span class="o">.</span><span class="n">to_index</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
                <span class="n">names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">current_index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
                <span class="n">codes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">current_index</span><span class="o">.</span><span class="n">codes</span><span class="p">)</span>
                <span class="n">levels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">current_index</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">_level_0&quot;</span><span class="p">)</span>
                <span class="n">cat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">current_index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">codes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span><span class="p">)</span>
                <span class="n">levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">var_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="n">var_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># MultiIndex</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">var_names</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">var</span> <span class="o">=</span> <span class="n">variables</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">cat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">codes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span><span class="p">)</span>
                <span class="n">levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span>

            <span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">(</span><span class="n">levels</span><span class="p">,</span> <span class="n">codes</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="n">dims_to_replace</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span>

        <span class="n">vars_to_replace</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">IndexVariable</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="n">vars_to_remove</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">var_names</span><span class="p">)</span>

    <span class="n">new_variables</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vars_to_remove</span><span class="p">}</span>
    <span class="n">new_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">vars_to_replace</span><span class="p">)</span>

    <span class="c1"># update dimensions if necessary, GH: 3512</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">d</span> <span class="ow">in</span> <span class="n">dims_to_replace</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">new_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">dims_to_replace</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>
            <span class="n">new_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="n">new_dims</span><span class="p">)</span>
    <span class="n">new_coord_names</span> <span class="o">=</span> <span class="n">coord_names</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">vars_to_replace</span><span class="p">)</span>
    <span class="n">new_coord_names</span> <span class="o">-=</span> <span class="nb">set</span><span class="p">(</span><span class="n">vars_to_remove</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_variables</span><span class="p">,</span> <span class="n">new_coord_names</span>


<span class="k">def</span> <span class="nf">split_indexes</span><span class="p">(</span>
    <span class="n">dims_or_levels</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
    <span class="n">variables</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Variable</span><span class="p">],</span>
    <span class="n">coord_names</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
    <span class="n">level_coords</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">],</span>
    <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Extract (multi-)indexes (levels) as variables.</span>

<span class="sd">    Not public API. Used in Dataset and DataArray reset_index</span>
<span class="sd">    methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dims_or_levels</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dims_or_levels</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="n">dims_or_levels</span> <span class="o">=</span> <span class="p">[</span><span class="n">dims_or_levels</span><span class="p">]</span>

    <span class="n">dim_levels</span><span class="p">:</span> <span class="n">DefaultDict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dims_or_levels</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">level_coords</span><span class="p">:</span>
            <span class="n">dim_levels</span><span class="p">[</span><span class="n">level_coords</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="n">vars_to_replace</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">vars_to_create</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">vars_to_remove</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">variables</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">to_index</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">dim_levels</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vars_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">drop</span><span class="p">:</span>
                <span class="n">vars_to_create</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">variables</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">levs</span> <span class="ow">in</span> <span class="n">dim_levels</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">variables</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">to_index</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">levs</span><span class="p">)</span> <span class="o">==</span> <span class="n">index</span><span class="o">.</span><span class="n">nlevels</span><span class="p">:</span>
            <span class="n">vars_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vars_to_replace</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">IndexVariable</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="n">levs</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">drop</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">lev</span> <span class="ow">in</span> <span class="n">levs</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span>
                <span class="n">vars_to_create</span><span class="p">[</span><span class="n">idx</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">variables</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>

    <span class="n">new_variables</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">vars_to_remove</span><span class="p">):</span>
        <span class="k">del</span> <span class="n">new_variables</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
    <span class="n">new_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">vars_to_replace</span><span class="p">)</span>
    <span class="n">new_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">vars_to_create</span><span class="p">)</span>
    <span class="n">new_coord_names</span> <span class="o">=</span> <span class="p">(</span><span class="n">coord_names</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">vars_to_create</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">vars_to_remove</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_variables</span><span class="p">,</span> <span class="n">new_coord_names</span>


<span class="k">def</span> <span class="nf">_assert_empty</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">msg</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="n">args</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_chunks_compatibility</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">preferred_chunks</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">chunks</span> <span class="ow">or</span> <span class="p">(</span><span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">preferred_chunks</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="n">preferred_chunks_dim</span> <span class="o">=</span> <span class="n">preferred_chunks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">chunks_dim</span> <span class="o">=</span> <span class="n">chunks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunks_dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">chunks_dim</span> <span class="o">=</span> <span class="p">(</span><span class="n">chunks_dim</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chunks_dim</span> <span class="o">=</span> <span class="n">chunks_dim</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span> <span class="o">%</span> <span class="n">preferred_chunks_dim</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">chunks_dim</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Specified Dask chunks </span><span class="si">{</span><span class="n">chunks</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="si">}</span><span class="s2"> would separate &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;on disks chunk shape </span><span class="si">{</span><span class="n">preferred_chunks</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="si">}</span><span class="s2"> for dimension </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;This could degrade performance. &quot;</span>
                <span class="s2">&quot;Consider rechunking after loading instead.&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_chunk</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">chunks</span><span class="p">):</span>
    <span class="c1"># chunks need to be explicitly computed to take correctly into account</span>
    <span class="c1"># backend preferred chunking</span>
    <span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">IndexVariable</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">chunks</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">):</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)</span>

    <span class="n">preferred_chunks</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;preferred_chunks&quot;</span><span class="p">,</span> <span class="p">{})</span>
    <span class="n">preferred_chunks_list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">preferred_chunks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="n">chunks_list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">chunks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">preferred_chunks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span>
    <span class="p">]</span>

    <span class="n">output_chunks_list</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">normalize_chunks</span><span class="p">(</span>
        <span class="n">chunks_list</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">var</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">previous_chunks</span><span class="o">=</span><span class="n">preferred_chunks_list</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">output_chunks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">output_chunks_list</span><span class="p">))</span>
    <span class="n">_check_chunks_compatibility</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">output_chunks</span><span class="p">,</span> <span class="n">preferred_chunks</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output_chunks</span>


<span class="k">def</span> <span class="nf">_maybe_chunk</span><span class="p">(</span>
    <span class="n">name</span><span class="p">,</span>
    <span class="n">var</span><span class="p">,</span>
    <span class="n">chunks</span><span class="p">,</span>
    <span class="n">token</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">lock</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">name_prefix</span><span class="o">=</span><span class="s2">&quot;xarray-&quot;</span><span class="p">,</span>
    <span class="n">overwrite_encoded_chunks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="kn">from</span> <span class="nn">dask.base</span> <span class="kn">import</span> <span class="n">tokenize</span>

    <span class="k">if</span> <span class="n">chunks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="n">chunks</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="c1"># when rechunking by different amounts, make sure dask names change</span>
        <span class="c1"># by provinding chunks as an input to tokenize.</span>
        <span class="c1"># subtle bugs result otherwise. see GH3350</span>
        <span class="n">token2</span> <span class="o">=</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">token</span> <span class="k">if</span> <span class="n">token</span> <span class="k">else</span> <span class="n">var</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)</span>
        <span class="n">name2</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name_prefix</span><span class="si">}{</span><span class="n">name</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">token2</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="n">lock</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">overwrite_encoded_chunks</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">chunks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">var</span><span class="o">.</span><span class="n">encoding</span><span class="p">[</span><span class="s2">&quot;chunks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">var</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">var</span>


<span class="k">def</span> <span class="nf">as_dataset</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Cast the given object to a Dataset.</span>

<span class="sd">    Handles Datasets, DataArrays and dictionaries of variables. A new Dataset</span>
<span class="sd">    object is only created if the provided object is not already one.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;to_dataset&quot;</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span>


<span class="k">def</span> <span class="nf">_get_func_args</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">param_names</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Use `inspect.signature` to try accessing `func` args. Otherwise, ensure</span>
<span class="sd">    they are provided by user.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">func_args</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">func_args</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">param_names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Unable to inspect `func` signature, and `param_names` was not provided.&quot;</span>
            <span class="p">)</span>
    <span class="k">if</span> <span class="n">param_names</span><span class="p">:</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">param_names</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">func_args</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">func_args</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`param_names` must be provided because `func` takes variable length arguments.&quot;</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">func_args</span>


<span class="k">def</span> <span class="nf">_initialize_curvefit_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">func_args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set initial guess and bounds for curvefit.</span>
<span class="sd">    Priority: 1) passed args 2) func signature 3) scipy defaults</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_initialize_feasible</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">):</span>
        <span class="c1"># Mimics functionality of scipy.optimize.minpack._initialize_feasible</span>
        <span class="n">lb_finite</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span>
        <span class="n">ub_finite</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">lb</span> <span class="o">+</span> <span class="n">ub</span><span class="p">)</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">lb_finite</span> <span class="o">&amp;</span> <span class="n">ub_finite</span><span class="p">),</span>
                <span class="p">(</span><span class="n">lb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">lb_finite</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ub_finite</span><span class="p">),</span>
                <span class="p">(</span><span class="n">ub</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="o">~</span><span class="n">lb_finite</span> <span class="o">&amp;</span> <span class="n">ub_finite</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">p0</span>

    <span class="n">param_defaults</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">}</span>
    <span class="n">bounds_defaults</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">func_args</span> <span class="ow">and</span> <span class="n">func_args</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">func_args</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">param_defaults</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">func_args</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">default</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">:</span>
            <span class="n">bounds_defaults</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">param_defaults</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bounds</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">param_defaults</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">bounds</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">param_defaults</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_initialize_feasible</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">p0</span><span class="p">:</span>
            <span class="n">param_defaults</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">p0</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">param_defaults</span><span class="p">,</span> <span class="n">bounds_defaults</span>


<span class="k">class</span> <span class="nc">DataVariables</span><span class="p">(</span><span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">]):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_dataset&quot;</span><span class="p">,)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span> <span class="o">=</span> <span class="n">dataset</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">key</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">_variables</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">_coord_names</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">_variables</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">_variables</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">_coord_names</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataArray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;DataArray&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">formatting</span><span class="o">.</span><span class="n">data_vars_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]:</span>
        <span class="n">all_variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">variables</span>
        <span class="k">return</span> <span class="n">Frozen</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">all_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">_ipython_key_completions_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Provide method for the key-autocompletions in IPython.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">key</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">_ipython_key_completions_</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">_coord_names</span>
        <span class="p">]</span>


<span class="k">class</span> <span class="nc">_LocIndexer</span><span class="p">:</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dataset&quot;</span><span class="p">,)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;can only lookup dictionaries from Dataset.loc&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;can only set locations defined by dictionaries from Dataset.loc.&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; Got: </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># set new values</span>
        <span class="n">pos_indexers</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">remap_label_indexers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="n">pos_indexers</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>


<div class="viewcode-block" id="Dataset"><a class="viewcode-back" href="../../../api/generated/larch.Dataset.html#larch.Dataset">[docs]</a><span class="k">class</span> <span class="nc">Dataset</span><span class="p">(</span><span class="n">DataWithCoords</span><span class="p">,</span> <span class="n">DatasetArithmetic</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A multi-dimensional, in memory, array database.</span>

<span class="sd">    A dataset resembles an in-memory representation of a NetCDF file,</span>
<span class="sd">    and consists of variables, coordinates and attributes which</span>
<span class="sd">    together form a self describing dataset.</span>

<span class="sd">    Dataset implements the mapping interface with keys given by variable</span>
<span class="sd">    names and values given by DataArray objects for each variable name.</span>

<span class="sd">    One dimensional variables with name equal to their dimension are</span>
<span class="sd">    index coordinates used for label based indexing.</span>

<span class="sd">    To load data from a file or file-like object, use the `open_dataset`</span>
<span class="sd">    function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_vars : dict-like, optional</span>
<span class="sd">        A mapping from variable names to :py:class:`~xarray.DataArray`</span>
<span class="sd">        objects, :py:class:`~xarray.Variable` objects or to tuples of</span>
<span class="sd">        the form ``(dims, data[, attrs])`` which can be used as</span>
<span class="sd">        arguments to create a new ``Variable``. Each dimension must</span>
<span class="sd">        have the same length in all variables in which it appears.</span>

<span class="sd">        The following notations are accepted:</span>

<span class="sd">        - mapping {var name: DataArray}</span>
<span class="sd">        - mapping {var name: Variable}</span>
<span class="sd">        - mapping {var name: (dimension name, array-like)}</span>
<span class="sd">        - mapping {var name: (tuple of dimension names, array-like)}</span>
<span class="sd">        - mapping {dimension name: array-like}</span>
<span class="sd">          (it will be automatically moved to coords, see below)</span>

<span class="sd">        Each dimension must have the same length in all variables in</span>
<span class="sd">        which it appears.</span>
<span class="sd">    coords : dict-like, optional</span>
<span class="sd">        Another mapping in similar form as the `data_vars` argument,</span>
<span class="sd">        except the each item is saved on the dataset as a &quot;coordinate&quot;.</span>
<span class="sd">        These variables have an associated meaning: they describe</span>
<span class="sd">        constant/fixed/independent quantities, unlike the</span>
<span class="sd">        varying/measured/dependent quantities that belong in</span>
<span class="sd">        `variables`. Coordinates values may be given by 1-dimensional</span>
<span class="sd">        arrays or scalars, in which case `dims` do not need to be</span>
<span class="sd">        supplied: 1D arrays will be assumed to give index values along</span>
<span class="sd">        the dimension with the same name.</span>

<span class="sd">        The following notations are accepted:</span>

<span class="sd">        - mapping {coord name: DataArray}</span>
<span class="sd">        - mapping {coord name: Variable}</span>
<span class="sd">        - mapping {coord name: (dimension name, array-like)}</span>
<span class="sd">        - mapping {coord name: (tuple of dimension names, array-like)}</span>
<span class="sd">        - mapping {dimension name: array-like}</span>
<span class="sd">          (the dimension name is implicitly set to be the same as the</span>
<span class="sd">          coord name)</span>

<span class="sd">        The last notation implies that the coord name is the same as</span>
<span class="sd">        the dimension name.</span>

<span class="sd">    attrs : dict-like, optional</span>
<span class="sd">        Global attributes to save on this dataset.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create data:</span>

<span class="sd">    &gt;&gt;&gt; np.random.seed(0)</span>
<span class="sd">    &gt;&gt;&gt; temperature = 15 + 8 * np.random.randn(2, 2, 3)</span>
<span class="sd">    &gt;&gt;&gt; precipitation = 10 * np.random.rand(2, 2, 3)</span>
<span class="sd">    &gt;&gt;&gt; lon = [[-99.83, -99.32], [-99.79, -99.23]]</span>
<span class="sd">    &gt;&gt;&gt; lat = [[42.25, 42.21], [42.63, 42.59]]</span>
<span class="sd">    &gt;&gt;&gt; time = pd.date_range(&quot;2014-09-06&quot;, periods=3)</span>
<span class="sd">    &gt;&gt;&gt; reference_time = pd.Timestamp(&quot;2014-09-05&quot;)</span>

<span class="sd">    Initialize a dataset with multiple dimensions:</span>

<span class="sd">    &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">    ...     data_vars=dict(</span>
<span class="sd">    ...         temperature=([&quot;x&quot;, &quot;y&quot;, &quot;time&quot;], temperature),</span>
<span class="sd">    ...         precipitation=([&quot;x&quot;, &quot;y&quot;, &quot;time&quot;], precipitation),</span>
<span class="sd">    ...     ),</span>
<span class="sd">    ...     coords=dict(</span>
<span class="sd">    ...         lon=([&quot;x&quot;, &quot;y&quot;], lon),</span>
<span class="sd">    ...         lat=([&quot;x&quot;, &quot;y&quot;], lat),</span>
<span class="sd">    ...         time=time,</span>
<span class="sd">    ...         reference_time=reference_time,</span>
<span class="sd">    ...     ),</span>
<span class="sd">    ...     attrs=dict(description=&quot;Weather related data.&quot;),</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; ds</span>
<span class="sd">    &lt;xarray.Dataset&gt;</span>
<span class="sd">    Dimensions:         (x: 2, y: 2, time: 3)</span>
<span class="sd">    Coordinates:</span>
<span class="sd">        lon             (x, y) float64 -99.83 -99.32 -99.79 -99.23</span>
<span class="sd">        lat             (x, y) float64 42.25 42.21 42.63 42.59</span>
<span class="sd">      * time            (time) datetime64[ns] 2014-09-06 2014-09-07 2014-09-08</span>
<span class="sd">        reference_time  datetime64[ns] 2014-09-05</span>
<span class="sd">    Dimensions without coordinates: x, y</span>
<span class="sd">    Data variables:</span>
<span class="sd">        temperature     (x, y, time) float64 29.11 18.2 22.83 ... 18.28 16.15 26.63</span>
<span class="sd">        precipitation   (x, y, time) float64 5.68 9.256 0.7104 ... 7.992 4.615 7.805</span>
<span class="sd">    Attributes:</span>
<span class="sd">        description:  Weather related data.</span>

<span class="sd">    Find out where the coldest temperature was and what values the</span>
<span class="sd">    other variables had:</span>

<span class="sd">    &gt;&gt;&gt; ds.isel(ds.temperature.argmin(...))</span>
<span class="sd">    &lt;xarray.Dataset&gt;</span>
<span class="sd">    Dimensions:         ()</span>
<span class="sd">    Coordinates:</span>
<span class="sd">        lon             float64 -99.32</span>
<span class="sd">        lat             float64 42.21</span>
<span class="sd">        time            datetime64[ns] 2014-09-08</span>
<span class="sd">        reference_time  datetime64[ns] 2014-09-05</span>
<span class="sd">    Data variables:</span>
<span class="sd">        temperature     float64 7.182</span>
<span class="sd">        precipitation   float64 8.326</span>
<span class="sd">    Attributes:</span>
<span class="sd">        description:  Weather related data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_attrs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
    <span class="n">_coord_names</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span>
    <span class="n">_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="n">_encoding</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">_close</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">_indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">_variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;_attrs&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_cache&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_coord_names&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_dims&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_encoding&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_close&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_indexes&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_variables&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__weakref__&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">_groupby_cls</span> <span class="o">=</span> <span class="n">groupby</span><span class="o">.</span><span class="n">DatasetGroupBy</span>
    <span class="n">_rolling_cls</span> <span class="o">=</span> <span class="n">rolling</span><span class="o">.</span><span class="n">DatasetRolling</span>
    <span class="n">_coarsen_cls</span> <span class="o">=</span> <span class="n">rolling</span><span class="o">.</span><span class="n">DatasetCoarsen</span>
    <span class="n">_resample_cls</span> <span class="o">=</span> <span class="n">resample</span><span class="o">.</span><span class="n">DatasetResample</span>
    <span class="n">_weighted_cls</span> <span class="o">=</span> <span class="n">weighted</span><span class="o">.</span><span class="n">DatasetWeighted</span>

<div class="viewcode-block" id="Dataset.__init__"><a class="viewcode-back" href="../../../api/generated/larch.Dataset.html#larch.Dataset.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="c1"># could make a VariableArgs to use more generally, and refine these</span>
        <span class="c1"># categories</span>
        <span class="n">data_vars</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">coords</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">attrs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># TODO(shoyer): expose indexes as a public argument in __init__</span>

        <span class="k">if</span> <span class="n">data_vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_vars</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">both_data_and_coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">data_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">both_data_and_coords</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;variables </span><span class="si">{</span><span class="n">both_data_and_coords</span><span class="si">!r}</span><span class="s2"> are found in both data_vars and coords&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">variables</span>

        <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">merge_data_and_coords</span><span class="p">(</span>
            <span class="n">data_vars</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">compat</span><span class="o">=</span><span class="s2">&quot;broadcast_equals&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span> <span class="k">if</span> <span class="n">attrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">=</span> <span class="n">coord_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span> <span class="o">=</span> <span class="n">dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span> <span class="o">=</span> <span class="n">indexes</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_store</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">store</span><span class="p">,</span> <span class="n">decoder</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a new dataset from the contents of a backends.*DataStore</span>
<span class="sd">        object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span><span class="p">,</span> <span class="n">attributes</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">decoder</span><span class="p">:</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">attributes</span> <span class="o">=</span> <span class="n">decoder</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">attributes</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attributes</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">set_close</span><span class="p">(</span><span class="n">store</span><span class="o">.</span><span class="n">close</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Low level interface to Dataset contents as dict of Variable objects.</span>

<span class="sd">        This ordered dictionary is frozen to prevent mutation that could</span>
<span class="sd">        violate Dataset invariants. It contains all variable objects</span>
<span class="sd">        constituting the Dataset, including both data variables and</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Frozen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Dictionary of global attributes on this dataset&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span>

    <span class="nd">@attrs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Dictionary of global encoding attributes on this dataset&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span>

    <span class="nd">@encoding</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dims</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Mapping from dimension names to lengths.</span>

<span class="sd">        Cannot be modified directly, but is updated when adding new variables.</span>

<span class="sd">        Note that type of this object differs from `DataArray.dims`.</span>
<span class="sd">        See `Dataset.sizes` and `DataArray.sizes` for consistently named</span>
<span class="sd">        properties.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Frozen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Mapping from dimension names to lengths.</span>

<span class="sd">        Cannot be modified directly, but is updated when adding new variables.</span>

<span class="sd">        This is an alias for `Dataset.dims` provided for the benefit of</span>
<span class="sd">        consistency with `DataArray.sizes`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.sizes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span>

    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Manually trigger loading and/or computation of this dataset&#39;s data</span>
<span class="sd">        from disk or a remote source into memory and return this dataset.</span>
<span class="sd">        Unlike compute, the original dataset is modified and returned.</span>

<span class="sd">        Normally, it should not be necessary to call this method in user code,</span>
<span class="sd">        because all xarray functions should either work on deferred data or</span>
<span class="sd">        load data automatically. However, this method can be necessary when</span>
<span class="sd">        working with many file objects on disk.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional keyword arguments passed on to ``dask.compute``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dask.compute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># access .data to coerce everything to numpy or dask arrays</span>
        <span class="n">lazy_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">_data</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">is_duck_dask_array</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">lazy_data</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>

            <span class="c1"># evaluate all the dask arrays simultaneously</span>
            <span class="n">evaluated_data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="o">*</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lazy_data</span><span class="p">,</span> <span class="n">evaluated_data</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="c1"># load everything else sequentially</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lazy_data</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__dask_tokenize__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">dask.base</span> <span class="kn">import</span> <span class="n">normalize_token</span>

        <span class="k">return</span> <span class="n">normalize_token</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__dask_graph__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">graphs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">__dask_graph__</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">graphs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graphs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">graphs</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">dask.highlevelgraph</span> <span class="kn">import</span> <span class="n">HighLevelGraph</span>

                <span class="k">return</span> <span class="n">HighLevelGraph</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="o">*</span><span class="n">graphs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">dask</span> <span class="kn">import</span> <span class="n">sharedict</span>

                <span class="k">return</span> <span class="n">sharedict</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="o">*</span><span class="n">graphs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__dask_keys__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">dask</span>

        <span class="k">return</span> <span class="p">[</span>
            <span class="n">v</span><span class="o">.</span><span class="n">__dask_keys__</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">dask</span><span class="o">.</span><span class="n">is_dask_collection</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__dask_layers__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">dask</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">v</span><span class="o">.</span><span class="n">__dask_layers__</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">dask</span><span class="o">.</span><span class="n">is_dask_collection</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="p">(),</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">__dask_optimize__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>

        <span class="k">return</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="o">.</span><span class="n">__dask_optimize__</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">__dask_scheduler__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>

        <span class="k">return</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="o">.</span><span class="n">__dask_scheduler__</span>

    <span class="k">def</span> <span class="nf">__dask_postcompute__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dask_postcompute</span><span class="p">,</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">__dask_postpersist__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dask_postpersist</span><span class="p">,</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">_dask_postcompute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Variable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">dask</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">results_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">dask</span><span class="o">.</span><span class="n">is_dask_collection</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                <span class="n">rebuild</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">__dask_postcompute__</span><span class="p">()</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">rebuild</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">results_iter</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">return</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">_construct_direct</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_dask_postpersist</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dsk</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">rename</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">dask</span> <span class="kn">import</span> <span class="n">is_dask_collection</span>
        <span class="kn">from</span> <span class="nn">dask.highlevelgraph</span> <span class="kn">import</span> <span class="n">HighLevelGraph</span>
        <span class="kn">from</span> <span class="nn">dask.optimization</span> <span class="kn">import</span> <span class="n">cull</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dask_collection</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dsk</span><span class="p">,</span> <span class="n">HighLevelGraph</span><span class="p">):</span>
                <span class="c1"># dask &gt;= 2021.3</span>
                <span class="c1"># __dask_postpersist__() was called by dask.highlevelgraph.</span>
                <span class="c1"># Don&#39;t use dsk.cull(), as we need to prevent partial layers:</span>
                <span class="c1"># https://github.com/dask/dask/issues/7137</span>
                <span class="n">layers</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">__dask_layers__</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">rename</span><span class="p">:</span>
                    <span class="n">layers</span> <span class="o">=</span> <span class="p">[</span><span class="n">rename</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">]</span>
                <span class="n">dsk2</span> <span class="o">=</span> <span class="n">dsk</span><span class="o">.</span><span class="n">cull_layers</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">rename</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
                <span class="c1"># At the moment of writing, this is only for forward compatibility.</span>
                <span class="c1"># replace_name_in_key requires dask &gt;= 2021.3.</span>
                <span class="kn">from</span> <span class="nn">dask.base</span> <span class="kn">import</span> <span class="n">flatten</span><span class="p">,</span> <span class="n">replace_name_in_key</span>

                <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">replace_name_in_key</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">rename</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">flatten</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">__dask_keys__</span><span class="p">())</span>
                <span class="p">]</span>
                <span class="n">dsk2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cull</span><span class="p">(</span><span class="n">dsk</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># __dask_postpersist__() was called by dask.optimize or dask.persist</span>
                <span class="n">dsk2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cull</span><span class="p">(</span><span class="n">dsk</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">__dask_keys__</span><span class="p">())</span>

            <span class="n">rebuild</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">__dask_postpersist__</span><span class="p">()</span>
            <span class="c1"># rename was added in dask 2021.3</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;rename&quot;</span><span class="p">:</span> <span class="n">rename</span><span class="p">}</span> <span class="k">if</span> <span class="n">rename</span> <span class="k">else</span> <span class="p">{}</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">rebuild</span><span class="p">(</span><span class="n">dsk2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">_construct_direct</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Manually trigger loading and/or computation of this dataset&#39;s data</span>
<span class="sd">        from disk or a remote source into memory and return a new dataset.</span>
<span class="sd">        Unlike load, the original dataset is left unaltered.</span>

<span class="sd">        Normally, it should not be necessary to call this method in user code,</span>
<span class="sd">        because all xarray functions should either work on deferred data or</span>
<span class="sd">        load data automatically. However, this method can be necessary when</span>
<span class="sd">        working with many file objects on disk.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional keyword arguments passed on to ``dask.compute``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dask.compute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_persist_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Persist all Dask arrays in memory&quot;&quot;&quot;</span>
        <span class="c1"># access .data to coerce everything to numpy or dask arrays</span>
        <span class="n">lazy_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">_data</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">is_duck_dask_array</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">lazy_data</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">dask</span>

            <span class="c1"># evaluate all the dask arrays simultaneously</span>
            <span class="n">evaluated_data</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">persist</span><span class="p">(</span><span class="o">*</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lazy_data</span><span class="p">,</span> <span class="n">evaluated_data</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">persist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Trigger computation, keeping data as dask arrays</span>

<span class="sd">        This operation can be used to trigger computation on underlying dask</span>
<span class="sd">        arrays, similar to ``.compute()`` or ``.load()``.  However this</span>
<span class="sd">        operation keeps the data as dask arrays. This is particularly useful</span>
<span class="sd">        when using the dask.distributed scheduler and you want to load a large</span>
<span class="sd">        amount of data into distributed memory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional keyword arguments passed on to ``dask.persist``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dask.persist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span><span class="o">.</span><span class="n">_persist_inplace</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_construct_direct</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Variable</span><span class="p">],</span>
        <span class="n">coord_names</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
        <span class="n">dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">attrs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">close</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Shortcut around __init__ for internal use when we want to skip</span>
<span class="sd">        costly validation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="n">calculate_dimensions</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_variables</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">=</span> <span class="n">coord_names</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_dims</span> <span class="o">=</span> <span class="n">dims</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_indexes</span> <span class="o">=</span> <span class="n">indexes</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_attrs</span> <span class="o">=</span> <span class="n">attrs</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_close</span> <span class="o">=</span> <span class="n">close</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="n">encoding</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_replace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">coord_names</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">attrs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Default</span> <span class="o">=</span> <span class="n">_default</span><span class="p">,</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Default</span> <span class="o">=</span> <span class="n">_default</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Default</span> <span class="o">=</span> <span class="n">_default</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Fastpath constructor for internal use.</span>

<span class="sd">        Returns an object with optionally with replaced attributes.</span>

<span class="sd">        Explicitly passed arguments are *not* copied when placed on the new</span>
<span class="sd">        dataset. It is up to the caller to ensure that they have the right type</span>
<span class="sd">        and are not used elsewhere.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span> <span class="o">=</span> <span class="n">variables</span>
            <span class="k">if</span> <span class="n">coord_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">=</span> <span class="n">coord_names</span>
            <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span> <span class="o">=</span> <span class="n">dims</span>
            <span class="k">if</span> <span class="n">attrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_default</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="o">=</span> <span class="n">attrs</span>
            <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_default</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span> <span class="o">=</span> <span class="n">indexes</span>
            <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_default</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="n">encoding</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">coord_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">coord_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">attrs</span> <span class="ow">is</span> <span class="n">_default</span><span class="p">:</span>
                <span class="n">attrs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="n">_default</span><span class="p">:</span>
                <span class="n">indexes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="n">_default</span><span class="p">:</span>
                <span class="n">encoding</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_direct</span><span class="p">(</span>
                <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">encoding</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_replace_with_new_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">],</span>
        <span class="n">coord_names</span><span class="p">:</span> <span class="nb">set</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">attrs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Default</span> <span class="o">=</span> <span class="n">_default</span><span class="p">,</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Default</span> <span class="o">=</span> <span class="n">_default</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Replace variables with recalculated dimensions.&quot;&quot;&quot;</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">calculate_dimensions</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_replace_vars_and_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">],</span>
        <span class="n">coord_names</span><span class="p">:</span> <span class="nb">set</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">attrs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Default</span> <span class="o">=</span> <span class="n">_default</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Deprecated version of _replace_with_new_dims().</span>

<span class="sd">        Unlike _replace_with_new_dims(), this method always recalculates</span>
<span class="sd">        indexes from variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="n">calculate_dimensions</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_overwrite_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexes</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Index</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">indexes</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_indexes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">IndexVariable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="o">.</span><span class="n">to_pandas_index</span><span class="p">())</span>
            <span class="n">new_indexes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">new_indexes</span><span class="p">)</span>

        <span class="c1"># switch from dimension to level names, if necessary</span>
        <span class="n">dim_names</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">pd_idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">to_pandas_index</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pd_idx</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="n">pd_idx</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
                <span class="n">dim_names</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd_idx</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">dim_names</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">dim_names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a copy of this dataset.</span>

<span class="sd">        If `deep=True`, a deep copy is made of each of the component variables.</span>
<span class="sd">        Otherwise, a shallow copy of each of the component variable is made, so</span>
<span class="sd">        that the underlying memory region of the new dataset is the same as in</span>
<span class="sd">        the original dataset.</span>

<span class="sd">        Use `data` to create a new object with the same structure as</span>
<span class="sd">        original but entirely new data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deep : bool, optional</span>
<span class="sd">            Whether each component variable is loaded into memory and copied onto</span>
<span class="sd">            the new object. Default is False.</span>
<span class="sd">        data : dict-like, optional</span>
<span class="sd">            Data to use in the new object. Each item in `data` must have same</span>
<span class="sd">            shape as corresponding data variable in original. When `data` is</span>
<span class="sd">            used, `deep` is ignored for the data variables and only used for</span>
<span class="sd">            coords.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object : Dataset</span>
<span class="sd">            New object with dimensions, attributes, coordinates, name, encoding,</span>
<span class="sd">            and optionally data copied from original.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Shallow copy versus deep copy</span>

<span class="sd">        &gt;&gt;&gt; da = xr.DataArray(np.random.randn(2, 3))</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     {&quot;foo&quot;: da, &quot;bar&quot;: (&quot;x&quot;, [-1, 2])},</span>
<span class="sd">        ...     coords={&quot;x&quot;: [&quot;one&quot;, &quot;two&quot;]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds.copy()</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (dim_0: 2, dim_1: 3, x: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) &lt;U3 &#39;one&#39; &#39;two&#39;</span>
<span class="sd">        Dimensions without coordinates: dim_0, dim_1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (dim_0, dim_1) float64 1.764 0.4002 0.9787 2.241 1.868 -0.9773</span>
<span class="sd">            bar      (x) int64 -1 2</span>

<span class="sd">        &gt;&gt;&gt; ds_0 = ds.copy(deep=False)</span>
<span class="sd">        &gt;&gt;&gt; ds_0[&quot;foo&quot;][0, 0] = 7</span>
<span class="sd">        &gt;&gt;&gt; ds_0</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (dim_0: 2, dim_1: 3, x: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) &lt;U3 &#39;one&#39; &#39;two&#39;</span>
<span class="sd">        Dimensions without coordinates: dim_0, dim_1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (dim_0, dim_1) float64 7.0 0.4002 0.9787 2.241 1.868 -0.9773</span>
<span class="sd">            bar      (x) int64 -1 2</span>

<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (dim_0: 2, dim_1: 3, x: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) &lt;U3 &#39;one&#39; &#39;two&#39;</span>
<span class="sd">        Dimensions without coordinates: dim_0, dim_1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (dim_0, dim_1) float64 7.0 0.4002 0.9787 2.241 1.868 -0.9773</span>
<span class="sd">            bar      (x) int64 -1 2</span>

<span class="sd">        Changing the data using the ``data`` argument maintains the</span>
<span class="sd">        structure of the original object, but with the new data. Original</span>
<span class="sd">        object is unaffected.</span>

<span class="sd">        &gt;&gt;&gt; ds.copy(data={&quot;foo&quot;: np.arange(6).reshape(2, 3), &quot;bar&quot;: [&quot;a&quot;, &quot;b&quot;]})</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (dim_0: 2, dim_1: 3, x: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) &lt;U3 &#39;one&#39; &#39;two&#39;</span>
<span class="sd">        Dimensions without coordinates: dim_0, dim_1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (dim_0, dim_1) int64 0 1 2 3 4 5</span>
<span class="sd">            bar      (x) &lt;U1 &#39;a&#39; &#39;b&#39;</span>

<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (dim_0: 2, dim_1: 3, x: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) &lt;U3 &#39;one&#39; &#39;two&#39;</span>
<span class="sd">        Dimensions without coordinates: dim_0, dim_1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (dim_0, dim_1) float64 7.0 0.4002 0.9787 2.241 1.868 -0.9773</span>
<span class="sd">            bar      (x) int64 -1 2</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.DataFrame.copy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data must be dict-like&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">data_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">keys_not_in_vars</span> <span class="o">=</span> <span class="n">data_keys</span> <span class="o">-</span> <span class="n">var_keys</span>
            <span class="k">if</span> <span class="n">keys_not_in_vars</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Data must only contain variables in original &quot;</span>
                    <span class="s2">&quot;dataset. Extra variables: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">keys_not_in_vars</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="n">keys_missing_from_data</span> <span class="o">=</span> <span class="n">var_keys</span> <span class="o">-</span> <span class="n">data_keys</span>
            <span class="k">if</span> <span class="n">keys_missing_from_data</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Data must contain all variables in original &quot;</span>
                    <span class="s2">&quot;dataset. Data is missing </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">keys_missing_from_data</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>

        <span class="n">attrs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">)</span> <span class="k">if</span> <span class="n">deep</span> <span class="k">else</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Coerces wrapped data and coordinates into numpy arrays, returning a Dataset.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.as_numpy</span>
<span class="sd">        DataArray.to_numpy : Returns only the data as a numpy.ndarray object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numpy_variables</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">as_numpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="o">=</span><span class="n">numpy_variables</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_level_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return a mapping of all MultiIndex levels and their corresponding</span>
<span class="sd">        coordinate name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">level_coords</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># TODO: benbovy - flexible indexes: update when MultIndex has its own xarray class.</span>
            <span class="n">pd_index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">to_pandas_index</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pd_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
                <span class="n">level_names</span> <span class="o">=</span> <span class="n">pd_index</span><span class="o">.</span><span class="n">names</span>
                <span class="p">(</span><span class="n">dim</span><span class="p">,)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span>
                <span class="n">level_coords</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">lname</span><span class="p">:</span> <span class="n">dim</span> <span class="k">for</span> <span class="n">lname</span> <span class="ow">in</span> <span class="n">level_names</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">level_coords</span>

    <span class="k">def</span> <span class="nf">_copy_listed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a new Dataset with the listed variables from this dataset and</span>
<span class="sd">        the all relevant coordinates. Skips all validation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">ref_name</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">_get_virtual_variable</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_level_coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span>
                <span class="p">)</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
                <span class="k">if</span> <span class="n">ref_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="ow">or</span> <span class="n">ref_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="n">coord_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">var_name</span><span class="p">,)</span> <span class="o">==</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="n">indexes</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">_to_xindex</span><span class="p">()</span>

        <span class="n">needed_dims</span><span class="p">:</span> <span class="n">OrderedSet</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedSet</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">needed_dims</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>

        <span class="n">dims</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">needed_dims</span><span class="p">}</span>

        <span class="c1"># preserves ordering of coordinates</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">needed_dims</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">coord_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">:</span>
                    <span class="n">indexes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_construct_dataarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Construct a DataArray by indexing this dataset&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">variable</span> <span class="o">=</span> <span class="n">_get_virtual_variable</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_level_coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span>
            <span class="p">)</span>

        <span class="n">needed_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>

        <span class="n">coords</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># preserve ordering</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">needed_dims</span><span class="p">:</span>
                <span class="n">coords</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">DataArray</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="c1"># memo does nothing but is required for compatibility with</span>
        <span class="c1"># copy.deepcopy</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_attr_sources</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Places to look-up items for attribute-style access&quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_item_sources</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_item_sources</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Places to look-up items for key-completion&quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span>
        <span class="k">yield</span> <span class="n">HybridMappingProxy</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

        <span class="c1"># virtual coordinates</span>
        <span class="k">yield</span> <span class="n">HybridMappingProxy</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># uses empty dict -- everything here can already be found in self.coords.</span>
        <span class="k">yield</span> <span class="n">HybridMappingProxy</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_level_coords</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{})</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The &#39;in&#39; operator will return true or false depending on whether</span>
<span class="sd">        &#39;key&#39; is an array in the dataset or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;cannot directly convert an xarray.Dataset into a &quot;</span>
            <span class="s2">&quot;numpy array. Instead, create an xarray.DataArray &quot;</span>
            <span class="s2">&quot;first, either with indexing on the Dataset or by &quot;</span>
            <span class="s2">&quot;invoking the `to_array()` method.&quot;</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">nbytes</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_LocIndexer</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Attribute for location based indexing. Only supports __getitem__,</span>
<span class="sd">        and only when the key is a dict of the form {dim: labels}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_LocIndexer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># FIXME https://github.com/python/mypy/issues/7328</span>
    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>  <span class="c1"># type: ignore[misc]</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataArray</span><span class="p">:</span>  <span class="c1"># type: ignore[misc]</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Access variables or coordinates this dataset as a</span>
<span class="sd">        :py:class:`~xarray.DataArray`.</span>

<span class="sd">        Indexing with a list of names will return a new ``Dataset`` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="o">**</span><span class="n">cast</span><span class="p">(</span><span class="n">Mapping</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">hashable</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_dataarray</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_listed</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add an array to this dataset.</span>
<span class="sd">        Multiple arrays can be added at the same time, in which case each of</span>
<span class="sd">        the following operations is applied to the respective value.</span>

<span class="sd">        If key is a dictionary, update all variables in the dataset</span>
<span class="sd">        one by one with the given value at the given location.</span>
<span class="sd">        If the given value is also a dataset, select corresponding variables</span>
<span class="sd">        in the given value and in the dataset to be changed.</span>

<span class="sd">        If value is a `DataArray`, call its `select_vars()` method, rename it</span>
<span class="sd">        to `key` and merge the contents of the resulting dataset into this</span>
<span class="sd">        dataset.</span>

<span class="sd">        If value is a `Variable` object (or tuple of form</span>
<span class="sd">        ``(dims, data[, attrs])``), add it to this dataset as a new</span>
<span class="sd">        variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="c1"># check for consistency and convert value to dataset</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setitem_check</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="c1"># loop over dataset variables and set new values</span>
            <span class="n">processed</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">var</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="n">processed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">processed</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                            <span class="s2">&quot;An error occurred while setting values of the&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; variable &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;. The following variables have&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; been successfully updated:</span><span class="se">\n</span><span class="si">{</span><span class="n">processed</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">e</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Empty list of variables to be set&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">value</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Different lengths of variables to be set &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="si">}</span><span class="s2">) and data used as input for &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;setting (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot assign single DataArray to multiple keys&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot assign a Dataset to a single key - only a DataArray or Variable object can be stored under&quot;</span>
                    <span class="s2">&quot;a single key.&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">_setitem_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Consistency check for __setitem__</span>

<span class="sd">        When assigning values to a subset of a Dataset, do consistency check beforehand</span>
<span class="sd">        to avoid leaving the dataset in a partially updated state when an error occurs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="n">missing_vars</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">data_vars</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">missing_vars</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Variables </span><span class="si">{</span><span class="n">missing_vars</span><span class="si">}</span><span class="s2"> in new values&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; not available in original dataset:</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">[</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">Number</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Dataset assignment only accepts DataArrays, Datasets, and scalars.&quot;</span>
            <span class="p">)</span>

        <span class="n">new_value</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># test indexing</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">var_k</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Variable &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;: indexer </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> not available&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">):</span>
                <span class="c1"># check consistency of dimensions</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var_k</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Variable &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;: dimension &#39;</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">&#39; appears in new values &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;but not in the indexed original data&quot;</span>
                        <span class="p">)</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">var_k</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dims</span> <span class="o">!=</span> <span class="n">val</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Variable &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;: dimension order differs between&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot; original and new data:</span><span class="se">\n</span><span class="si">{</span><span class="n">dims</span><span class="si">}</span><span class="se">\n</span><span class="s2">vs.</span><span class="se">\n</span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">dims</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="c1"># type conversion</span>
            <span class="n">new_value</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">var_k</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># check consistency of dimension sizes and dimension coordinates</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">value</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;exact&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_value</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove a variable from this dataset.&quot;&quot;&quot;</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span> <span class="o">=</span> <span class="n">calculate_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">)</span>

    <span class="c1"># mutable objects should not be hashable</span>
    <span class="c1"># https://github.com/python/mypy/issues/4266</span>
    <span class="fm">__hash__</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore[assignment]</span>

    <span class="k">def</span> <span class="nf">_all_compat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">compat_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Helper function for equals and identical&quot;&quot;&quot;</span>

        <span class="c1"># some stores (e.g., scipy) do not seem to preserve order, so don&#39;t</span>
        <span class="c1"># require matching order for equality</span>
        <span class="k">def</span> <span class="nf">compat</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">Variable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">compat_str</span><span class="p">)(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_coord_names</span> <span class="ow">and</span> <span class="n">utils</span><span class="o">.</span><span class="n">dict_equiv</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="n">compat</span><span class="o">=</span><span class="n">compat</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">broadcast_equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Two Datasets are broadcast equal if they are equal after</span>
<span class="sd">        broadcasting all variables against each other.</span>

<span class="sd">        For example, variables that are scalar in one dataset but non-scalar in</span>
<span class="sd">        the other dataset can still be broadcast equal if the the non-scalar</span>
<span class="sd">        variable is a constant.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.equals</span>
<span class="sd">        Dataset.identical</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_compat</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;broadcast_equals&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Two Datasets are equal if they have matching variables and</span>
<span class="sd">        coordinates, all of which are equal.</span>

<span class="sd">        Datasets can still be equal (like pandas objects) if they have NaN</span>
<span class="sd">        values in the same locations.</span>

<span class="sd">        This method is necessary because `v1 == v2` for ``Dataset``</span>
<span class="sd">        does element-wise comparisons (like numpy.ndarrays).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.broadcast_equals</span>
<span class="sd">        Dataset.identical</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_compat</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;equals&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">identical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Like equals, but also checks all dataset attributes and the</span>
<span class="sd">        attributes on all variables and coordinates.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.broadcast_equals</span>
<span class="sd">        Dataset.equals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">dict_equiv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_compat</span><span class="p">(</span>
                <span class="n">other</span><span class="p">,</span> <span class="s2">&quot;identical&quot;</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Indexes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Mapping of pandas.Index objects used for label based indexing.</span>

<span class="sd">        Raises an error if this Dataset has indexes that cannot be coerced</span>
<span class="sd">        to pandas.Index objects.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.xindexes</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Indexes</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">idx</span><span class="o">.</span><span class="n">to_pandas_index</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xindexes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Indexes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Mapping of xarray Index objects used for label based indexing.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span> <span class="o">=</span> <span class="n">default_indexes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Indexes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatasetCoordinates</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Dictionary of xarray.DataArray objects corresponding to coordinate</span>
<span class="sd">        variables</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DatasetCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataVariables</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Dictionary of DataArray objects corresponding to data variables&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataVariables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Given names of one or more variables, set them as coordinates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : hashable or iterable of hashable</span>
<span class="sd">            Name(s) of variables in this dataset to convert into coordinates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.swap_dims</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: allow inserting new coordinates with this method, like</span>
        <span class="c1"># DataFrame.set_index?</span>
        <span class="c1"># nb. check in self._variables, not self.data_vars to insure that the</span>
        <span class="c1"># operation is idempotent</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_all_in_dataset</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_coord_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">reset_coords</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">names</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Given names of coordinates, reset them to become variables</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : hashable or iterable of hashable, optional</span>
<span class="sd">            Name(s) of non-index coordinates in this dataset to reset into</span>
<span class="sd">            variables. By default, all non-index coordinates are reset.</span>
<span class="sd">        drop : bool, optional</span>
<span class="sd">            If True, remove coordinates instead of converting them into</span>
<span class="sd">            variables.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_assert_all_in_dataset</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
            <span class="n">bad_coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bad_coords</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;cannot remove index coordinates with reset_coords: </span><span class="si">{</span><span class="n">bad_coords</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_coord_names</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">drop</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">obj</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">dump_to_store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="p">:</span> <span class="n">AbstractDataStore</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Store dataset contents to a backends.*DataStore object.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..backends.api</span> <span class="kn">import</span> <span class="n">dump_to_store</span>

        <span class="c1"># TODO: rename and/or cleanup this method to make it more consistent</span>
        <span class="c1"># with to_netcdf()</span>
        <span class="n">dump_to_store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_netcdf</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span>
        <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">group</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">engine</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="n">Mapping</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unlimited_dims</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">compute</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">invalid_netcdf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="n">Delayed</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Write dataset contents to a netCDF file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str, path-like or file-like, optional</span>
<span class="sd">            Path to which to save this dataset. File-like objects are only</span>
<span class="sd">            supported by the scipy engine. If no path is provided, this</span>
<span class="sd">            function returns the resulting netCDF file as bytes; in this case,</span>
<span class="sd">            we need to use scipy, which does not support netCDF version 4 (the</span>
<span class="sd">            default format becomes NETCDF3_64BIT).</span>
<span class="sd">        mode : {&quot;w&quot;, &quot;a&quot;}, default: &quot;w&quot;</span>
<span class="sd">            Write (&#39;w&#39;) or append (&#39;a&#39;) mode. If mode=&#39;w&#39;, any existing file at</span>
<span class="sd">            this location will be overwritten. If mode=&#39;a&#39;, existing variables</span>
<span class="sd">            will be overwritten.</span>
<span class="sd">        format : {&quot;NETCDF4&quot;, &quot;NETCDF4_CLASSIC&quot;, &quot;NETCDF3_64BIT&quot;, \</span>
<span class="sd">                  &quot;NETCDF3_CLASSIC&quot;}, optional</span>
<span class="sd">            File format for the resulting netCDF file:</span>

<span class="sd">            * NETCDF4: Data is stored in an HDF5 file, using netCDF4 API</span>
<span class="sd">              features.</span>
<span class="sd">            * NETCDF4_CLASSIC: Data is stored in an HDF5 file, using only</span>
<span class="sd">              netCDF 3 compatible API features.</span>
<span class="sd">            * NETCDF3_64BIT: 64-bit offset version of the netCDF 3 file format,</span>
<span class="sd">              which fully supports 2+ GB files, but is only compatible with</span>
<span class="sd">              clients linked against netCDF version 3.6.0 or later.</span>
<span class="sd">            * NETCDF3_CLASSIC: The classic netCDF 3 file format. It does not</span>
<span class="sd">              handle 2+ GB files very well.</span>

<span class="sd">            All formats are supported by the netCDF4-python library.</span>
<span class="sd">            scipy.io.netcdf only supports the last two formats.</span>

<span class="sd">            The default format is NETCDF4 if you are saving a file to disk and</span>
<span class="sd">            have the netCDF4-python library available. Otherwise, xarray falls</span>
<span class="sd">            back to using scipy to write netCDF files and defaults to the</span>
<span class="sd">            NETCDF3_64BIT format (scipy does not support netCDF4).</span>
<span class="sd">        group : str, optional</span>
<span class="sd">            Path to the netCDF4 group in the given file to open (only works for</span>
<span class="sd">            format=&#39;NETCDF4&#39;). The group(s) will be created if necessary.</span>
<span class="sd">        engine : {&quot;netcdf4&quot;, &quot;scipy&quot;, &quot;h5netcdf&quot;}, optional</span>
<span class="sd">            Engine to use when writing netCDF files. If not provided, the</span>
<span class="sd">            default engine is chosen based on available dependencies, with a</span>
<span class="sd">            preference for &#39;netcdf4&#39; if writing to a file on disk.</span>
<span class="sd">        encoding : dict, optional</span>
<span class="sd">            Nested dictionary with variable names as keys and dictionaries of</span>
<span class="sd">            variable specific encodings as values, e.g.,</span>
<span class="sd">            ``{&quot;my_variable&quot;: {&quot;dtype&quot;: &quot;int16&quot;, &quot;scale_factor&quot;: 0.1,</span>
<span class="sd">            &quot;zlib&quot;: True}, ...}``</span>

<span class="sd">            The `h5netcdf` engine supports both the NetCDF4-style compression</span>
<span class="sd">            encoding parameters ``{&quot;zlib&quot;: True, &quot;complevel&quot;: 9}`` and the h5py</span>
<span class="sd">            ones ``{&quot;compression&quot;: &quot;gzip&quot;, &quot;compression_opts&quot;: 9}``.</span>
<span class="sd">            This allows using any compression plugin installed in the HDF5</span>
<span class="sd">            library, e.g. LZF.</span>

<span class="sd">        unlimited_dims : iterable of hashable, optional</span>
<span class="sd">            Dimension(s) that should be serialized as unlimited dimensions.</span>
<span class="sd">            By default, no dimensions are treated as unlimited dimensions.</span>
<span class="sd">            Note that unlimited_dims may also be set via</span>
<span class="sd">            ``dataset.encoding[&quot;unlimited_dims&quot;]``.</span>
<span class="sd">        compute: bool, default: True</span>
<span class="sd">            If true compute immediately, otherwise return a</span>
<span class="sd">            ``dask.delayed.Delayed`` object that can be computed later.</span>
<span class="sd">        invalid_netcdf: bool, default: False</span>
<span class="sd">            Only valid along with ``engine=&quot;h5netcdf&quot;``. If True, allow writing</span>
<span class="sd">            hdf5 files which are invalid netcdf as described in</span>
<span class="sd">            https://github.com/h5netcdf/h5netcdf.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">encoding</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="kn">from</span> <span class="nn">..backends.api</span> <span class="kn">import</span> <span class="n">to_netcdf</span>

        <span class="k">return</span> <span class="n">to_netcdf</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">path</span><span class="p">,</span>
            <span class="n">mode</span><span class="p">,</span>
            <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span>
            <span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">,</span>
            <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
            <span class="n">unlimited_dims</span><span class="o">=</span><span class="n">unlimited_dims</span><span class="p">,</span>
            <span class="n">compute</span><span class="o">=</span><span class="n">compute</span><span class="p">,</span>
            <span class="n">invalid_netcdf</span><span class="o">=</span><span class="n">invalid_netcdf</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_zarr</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">store</span><span class="p">:</span> <span class="n">MutableMapping</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">PathLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chunk_store</span><span class="p">:</span> <span class="n">MutableMapping</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">PathLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">synchronizer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">group</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="n">Mapping</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">compute</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">consolidated</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">append_dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">region</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">slice</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">safe_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">storage_options</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ZarrStore</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Write dataset contents to a zarr group.</span>

<span class="sd">        Zarr chunks are determined in the following way:</span>

<span class="sd">        - From the ``chunks`` attribute in each variable&#39;s ``encoding``</span>
<span class="sd">        - If the variable is a Dask array, from the dask chunks</span>
<span class="sd">        - If neither Dask chunks nor encoding chunks are present, chunks will</span>
<span class="sd">          be determined automatically by Zarr</span>
<span class="sd">        - If both Dask chunks and encoding chunks are present, encoding chunks</span>
<span class="sd">          will be used, provided that there is a many-to-one relationship between</span>
<span class="sd">          encoding chunks and dask chunks (i.e. Dask chunks are bigger than and</span>
<span class="sd">          evenly divide encoding chunks); otherwise raise a ``ValueError``.</span>
<span class="sd">          This restriction ensures that no synchronization / locks are required</span>
<span class="sd">          when writing. To disable this restriction, use ``safe_chunks=False``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        store : MutableMapping, str or path-like, optional</span>
<span class="sd">            Store or path to directory in local or remote file system.</span>
<span class="sd">        chunk_store : MutableMapping, str or path-like, optional</span>
<span class="sd">            Store or path to directory in local or remote file system only for Zarr</span>
<span class="sd">            array chunks. Requires zarr-python v2.4.0 or later.</span>
<span class="sd">        mode : {&quot;w&quot;, &quot;w-&quot;, &quot;a&quot;, &quot;r+&quot;, None}, optional</span>
<span class="sd">            Persistence mode: &quot;w&quot; means create (overwrite if exists);</span>
<span class="sd">            &quot;w-&quot; means create (fail if exists);</span>
<span class="sd">            &quot;a&quot; means override existing variables (create if does not exist);</span>
<span class="sd">            &quot;r+&quot; means modify existing array *values* only (raise an error if</span>
<span class="sd">            any metadata or shapes would change).</span>
<span class="sd">            The default mode is &quot;a&quot; if ``append_dim`` is set. Otherwise, it is</span>
<span class="sd">            &quot;r+&quot; if ``region`` is set and ``w-`` otherwise.</span>
<span class="sd">        synchronizer : object, optional</span>
<span class="sd">            Zarr array synchronizer.</span>
<span class="sd">        group : str, optional</span>
<span class="sd">            Group path. (a.k.a. `path` in zarr terminology.)</span>
<span class="sd">        encoding : dict, optional</span>
<span class="sd">            Nested dictionary with variable names as keys and dictionaries of</span>
<span class="sd">            variable specific encodings as values, e.g.,</span>
<span class="sd">            ``{&quot;my_variable&quot;: {&quot;dtype&quot;: &quot;int16&quot;, &quot;scale_factor&quot;: 0.1,}, ...}``</span>
<span class="sd">        compute : bool, optional</span>
<span class="sd">            If True write array data immediately, otherwise return a</span>
<span class="sd">            ``dask.delayed.Delayed`` object that can be computed to write</span>
<span class="sd">            array data later. Metadata is always updated eagerly.</span>
<span class="sd">        consolidated : bool, optional</span>
<span class="sd">            If True, apply zarr&#39;s `consolidate_metadata` function to the store</span>
<span class="sd">            after writing metadata and read existing stores with consolidated</span>
<span class="sd">            metadata; if False, do not. The default (`consolidated=None`) means</span>
<span class="sd">            write consolidated metadata and attempt to read consolidated</span>
<span class="sd">            metadata for existing stores (falling back to non-consolidated).</span>
<span class="sd">        append_dim : hashable, optional</span>
<span class="sd">            If set, the dimension along which the data will be appended. All</span>
<span class="sd">            other dimensions on overridden variables must remain the same size.</span>
<span class="sd">        region : dict, optional</span>
<span class="sd">            Optional mapping from dimension names to integer slices along</span>
<span class="sd">            dataset dimensions to indicate the region of existing zarr array(s)</span>
<span class="sd">            in which to write this dataset&#39;s data. For example,</span>
<span class="sd">            ``{&#39;x&#39;: slice(0, 1000), &#39;y&#39;: slice(10000, 11000)}`` would indicate</span>
<span class="sd">            that values should be written to the region ``0:1000`` along ``x``</span>
<span class="sd">            and ``10000:11000`` along ``y``.</span>

<span class="sd">            Two restrictions apply to the use of ``region``:</span>

<span class="sd">            - If ``region`` is set, _all_ variables in a dataset must have at</span>
<span class="sd">              least one dimension in common with the region. Other variables</span>
<span class="sd">              should be written in a separate call to ``to_zarr()``.</span>
<span class="sd">            - Dimensions cannot be included in both ``region`` and</span>
<span class="sd">              ``append_dim`` at the same time. To create empty arrays to fill</span>
<span class="sd">              in with ``region``, use a separate call to ``to_zarr()`` with</span>
<span class="sd">              ``compute=False``. See &quot;Appending to existing Zarr stores&quot; in</span>
<span class="sd">              the reference documentation for full details.</span>
<span class="sd">        safe_chunks : bool, optional</span>
<span class="sd">            If True, only allow writes to when there is a many-to-one relationship</span>
<span class="sd">            between Zarr chunks (specified in encoding) and Dask chunks.</span>
<span class="sd">            Set False to override this restriction; however, data may become corrupted</span>
<span class="sd">            if Zarr arrays are written in parallel. This option may be useful in combination</span>
<span class="sd">            with ``compute=False`` to initialize a Zarr from an existing</span>
<span class="sd">            Dataset with arbitrary chunk structure.</span>
<span class="sd">        storage_options : dict, optional</span>
<span class="sd">            Any additional parameters for the storage backend (ignored for local</span>
<span class="sd">            paths).</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        https://zarr.readthedocs.io/</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Zarr chunking behavior:</span>
<span class="sd">            If chunks are found in the encoding argument or attribute</span>
<span class="sd">            corresponding to any DataArray, those chunks are used.</span>
<span class="sd">            If a DataArray is a dask array, it is written with those chunks.</span>
<span class="sd">            If not other chunks are found, Zarr uses its own heuristics to</span>
<span class="sd">            choose automatic chunk sizes.</span>

<span class="sd">        encoding:</span>
<span class="sd">            The encoding attribute (if exists) of the DataArray(s) will be</span>
<span class="sd">            used. Override any existing encodings by providing the ``encoding`` kwarg.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :ref:`io.zarr`</span>
<span class="sd">            The I/O user guide, with more details and examples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..backends.api</span> <span class="kn">import</span> <span class="n">to_zarr</span>

        <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">encoding</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="n">to_zarr</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">store</span><span class="o">=</span><span class="n">store</span><span class="p">,</span>
            <span class="n">chunk_store</span><span class="o">=</span><span class="n">chunk_store</span><span class="p">,</span>
            <span class="n">storage_options</span><span class="o">=</span><span class="n">storage_options</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">synchronizer</span><span class="o">=</span><span class="n">synchronizer</span><span class="p">,</span>
            <span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
            <span class="n">compute</span><span class="o">=</span><span class="n">compute</span><span class="p">,</span>
            <span class="n">consolidated</span><span class="o">=</span><span class="n">consolidated</span><span class="p">,</span>
            <span class="n">append_dim</span><span class="o">=</span><span class="n">append_dim</span><span class="p">,</span>
            <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span>
            <span class="n">safe_chunks</span><span class="o">=</span><span class="n">safe_chunks</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">formatting</span><span class="o">.</span><span class="n">dataset_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">OPTIONS</span><span class="p">[</span><span class="s2">&quot;display_style&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;text&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;pre&gt;</span><span class="si">{</span><span class="n">escape</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="si">}</span><span class="s2">&lt;/pre&gt;&quot;</span>
        <span class="k">return</span> <span class="n">formatting_html</span><span class="o">.</span><span class="n">dataset_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concise summary of a Dataset variables and attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        buf : file-like, default: sys.stdout</span>
<span class="sd">            writable buffer</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.DataFrame.assign</span>
<span class="sd">        ncdump : netCDF&#39;s ncdump</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">buf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;xarray.Dataset {&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;dimensions:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s2"> ;&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">variables:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">da</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">{</span><span class="n">da</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">dims</span><span class="si">}</span><span class="s2">) ;&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> ;&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">// global attributes:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">:</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> ;&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;}&quot;</span><span class="p">)</span>

        <span class="n">buf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">chunks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mapping from dimension names to block lengths for this dataset&#39;s data, or None if</span>
<span class="sd">        the underlying data is not a dask array.</span>
<span class="sd">        Cannot be modified directly, but can be modified by calling .chunk().</span>

<span class="sd">        Same as Dataset.chunksizes, but maintained for backwards compatibility.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.chunk</span>
<span class="sd">        Dataset.chunksizes</span>
<span class="sd">        xarray.unify_chunks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_chunksizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">chunksizes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mapping from dimension names to block lengths for this dataset&#39;s data, or None if</span>
<span class="sd">        the underlying data is not a dask array.</span>
<span class="sd">        Cannot be modified directly, but can be modified by calling .chunk().</span>

<span class="sd">        Same as Dataset.chunks.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.chunk</span>
<span class="sd">        Dataset.chunks</span>
<span class="sd">        xarray.unify_chunks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_chunksizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">chunk</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">chunks</span><span class="p">:</span> <span class="p">(</span>
            <span class="nb">int</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;auto&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span>
        <span class="p">)</span> <span class="o">=</span> <span class="p">{},</span>  <span class="c1"># {} even though it&#39;s technically unsafe, is being used intentionally here (#4667)</span>
        <span class="n">name_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;xarray-&quot;</span><span class="p">,</span>
        <span class="n">token</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lock</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Coerce all arrays in this dataset into dask arrays with the given</span>
<span class="sd">        chunks.</span>

<span class="sd">        Non-dask arrays in this dataset will be converted to dask arrays. Dask</span>
<span class="sd">        arrays will be rechunked to the given chunk sizes.</span>

<span class="sd">        If neither chunks is not provided for one or more dimensions, chunk</span>
<span class="sd">        sizes along that dimension will not be updated; non-dask arrays will be</span>
<span class="sd">        converted into dask arrays with a single block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chunks : int, &quot;auto&quot; or mapping of hashable to int, optional</span>
<span class="sd">            Chunk sizes along each dimension, e.g., ``5``, ``&quot;auto&quot;``, or</span>
<span class="sd">            ``{&quot;x&quot;: 5, &quot;y&quot;: 5}``.</span>
<span class="sd">        name_prefix : str, optional</span>
<span class="sd">            Prefix for the name of any new dask arrays.</span>
<span class="sd">        token : str, optional</span>
<span class="sd">            Token uniquely identifying this dataset.</span>
<span class="sd">        lock : optional</span>
<span class="sd">            Passed on to :py:func:`dask.array.from_array`, if the array is not</span>
<span class="sd">            already as dask array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        chunked : xarray.Dataset</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.chunks</span>
<span class="sd">        Dataset.chunksizes</span>
<span class="sd">        xarray.unify_chunks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">chunks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;None value for &#39;chunks&#39; is deprecated. &quot;</span>
                <span class="s2">&quot;It will raise an error in the future. Use instead &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)</span>

        <span class="n">bad_dims</span> <span class="o">=</span> <span class="n">chunks</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">bad_dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;some chunks keys are not dimensions on this object: </span><span class="si">{</span><span class="n">bad_dims</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">_maybe_chunk</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">name_prefix</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_indexers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">missing_dims</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">slice</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">Variable</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Here we make sure</span>
<span class="sd">        + indexer has a valid keys</span>
<span class="sd">        + indexer is in a valid data type</span>
<span class="sd">        + string indexers are cast to the appropriate date type if the</span>
<span class="sd">          associated index is a DatetimeIndex or CFTimeIndex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>

        <span class="n">indexers</span> <span class="o">=</span> <span class="n">drop_dims_from_indexers</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">missing_dims</span><span class="p">)</span>

        <span class="c1"># all indexers should be int, slice, np.ndarrays, or Variable</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)):</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">variable</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">as_variable</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot use a Dataset as an indexer&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;US&quot;</span><span class="p">:</span>
                    <span class="c1"># TODO: benbovy - flexible indexes</span>
                    <span class="c1"># update when CFTimeIndex has its own xarray index class</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">to_pandas_index</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;datetime64[ns]&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">CFTimeIndex</span><span class="p">):</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">_parse_array_of_cftime_strings</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">date_type</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                        <span class="s2">&quot;Unlabeled multi-dimensional array cannot be &quot;</span>
                        <span class="s2">&quot;used for indexing: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">_validate_interp_indexers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Variant of _validate_indexers to be used for interpolation&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_indexers</span><span class="p">(</span><span class="n">indexers</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">to_index_variable</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">Variable</span><span class="p">((),</span> <span class="n">v</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">Variable</span><span class="p">((),</span> <span class="n">v</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">IndexVariable</span><span class="p">((</span><span class="n">k</span><span class="p">,),</span> <span class="n">v</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">()</span>  <span class="c1"># Already tested by _validate_indexers</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_indexers_coords_and_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract coordinates and indexes from indexers.</span>

<span class="sd">        Only coordinate with a name different from any of self.variables will</span>
<span class="sd">        be attached.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>

        <span class="n">coords_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># we only support 1-d boolean array</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;</span><span class="si">{:d}</span><span class="s2">d-boolean array is used for indexing along &quot;</span>
                            <span class="s2">&quot;dimension </span><span class="si">{!r}</span><span class="s2">, but only 1d boolean arrays are &quot;</span>
                            <span class="s2">&quot;supported.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="c1"># Make sure in case of boolean DataArray, its</span>
                    <span class="c1"># coordinate also should be indexed.</span>
                    <span class="n">v_coords</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">coords</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v_coords</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">coords</span>
                <span class="n">coords_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_coords</span><span class="p">)</span>

        <span class="c1"># we don&#39;t need to call align() explicitly or check indexes for</span>
        <span class="c1"># alignment, because merge_variables already checks for exact alignment</span>
        <span class="c1"># between dimension coordinates</span>
        <span class="n">coords</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="n">merge_coordinates_without_align</span><span class="p">(</span><span class="n">coords_list</span><span class="p">)</span>
        <span class="n">assert_coordinate_consistent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>

        <span class="c1"># silently drop the conflicted variables.</span>
        <span class="n">attached_coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">}</span>
        <span class="n">attached_indexes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">attached_coords</span><span class="p">,</span> <span class="n">attached_indexes</span>

    <span class="k">def</span> <span class="nf">isel</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">missing_dims</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a new dataset with each array indexed along the specified</span>
<span class="sd">        dimension(s).</span>

<span class="sd">        This method selects values from each array using its `__getitem__`</span>
<span class="sd">        method, except this method does not require knowing the order of</span>
<span class="sd">        each array&#39;s dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexers : dict, optional</span>
<span class="sd">            A dict with keys matching dimensions and values given</span>
<span class="sd">            by integers, slice objects or arrays.</span>
<span class="sd">            indexer can be a integer, slice, array-like or DataArray.</span>
<span class="sd">            If DataArrays are passed as indexers, xarray-style indexing will be</span>
<span class="sd">            carried out. See :ref:`indexing` for the details.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>
<span class="sd">        drop : bool, optional</span>
<span class="sd">            If ``drop=True``, drop coordinates variables indexed by integers</span>
<span class="sd">            instead of making them scalar.</span>
<span class="sd">        missing_dims : {&quot;raise&quot;, &quot;warn&quot;, &quot;ignore&quot;}, default: &quot;raise&quot;</span>
<span class="sd">            What to do if dimensions that should be selected from are not present in the</span>
<span class="sd">            Dataset:</span>
<span class="sd">            - &quot;raise&quot;: raise an exception</span>
<span class="sd">            - &quot;warning&quot;: raise a warning, and ignore the missing dimensions</span>
<span class="sd">            - &quot;ignore&quot;: ignore the missing dimensions</span>
<span class="sd">        **indexers_kwargs : {dim: indexer, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``indexers``.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : Dataset</span>
<span class="sd">            A new Dataset with the same contents as this dataset, except each</span>
<span class="sd">            array and dimension is indexed by the appropriate indexers.</span>
<span class="sd">            If indexer DataArrays have coordinates that do not conflict with</span>
<span class="sd">            this object, then these coordinates will be attached.</span>
<span class="sd">            In general, each array&#39;s data will be a view of the array&#39;s data</span>
<span class="sd">            in this dataset, unless vectorized indexing was triggered by using</span>
<span class="sd">            an array indexer, in which case the data will be a copy.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.sel</span>
<span class="sd">        DataArray.isel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">indexers_kwargs</span><span class="p">,</span> <span class="s2">&quot;isel&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">is_fancy_indexer</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isel_fancy</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="n">drop</span><span class="p">,</span> <span class="n">missing_dims</span><span class="o">=</span><span class="n">missing_dims</span><span class="p">)</span>

        <span class="c1"># Much faster algorithm for when all indexers are ints, slices, one-dimensional</span>
        <span class="c1"># lists, or zero or one-dimensional np.ndarray&#39;s</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="n">drop_dims_from_indexers</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">missing_dims</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">var_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">var_indexers</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var_value</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">var_indexers</span><span class="p">:</span>
                <span class="n">var_value</span> <span class="o">=</span> <span class="n">var_value</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">var_indexers</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">drop</span> <span class="ow">and</span> <span class="n">var_value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">coord_names</span><span class="p">:</span>
                    <span class="n">coord_names</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">var_name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">indexes</span><span class="p">:</span>
                        <span class="n">indexes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">indexes</span> <span class="ow">and</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">var_value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">indexes</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var_value</span><span class="o">.</span><span class="n">_to_xindex</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">indexes</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var_value</span>
            <span class="n">dims</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">var_value</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">var_value</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_direct</span><span class="p">(</span>
            <span class="n">variables</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span>
            <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">,</span>
            <span class="n">close</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_close</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_isel_fancy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">missing_dims</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="c1"># Note: we need to preserve the original indexers variable in order to merge the</span>
        <span class="c1"># coords below</span>
        <span class="n">indexers_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_validate_indexers</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">missing_dims</span><span class="p">))</span>

        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">var_indexers</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexers_list</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">drop</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">var_indexers</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># drop this variable</span>

            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">:</span>
                <span class="n">new_var</span><span class="p">,</span> <span class="n">new_index</span> <span class="o">=</span> <span class="n">isel_variable_and_index</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">var_indexers</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">new_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">indexes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_index</span>
            <span class="k">elif</span> <span class="n">var_indexers</span><span class="p">:</span>
                <span class="n">new_var</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">indexers</span><span class="o">=</span><span class="n">var_indexers</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_var</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_var</span>

        <span class="n">coord_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">&amp;</span> <span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="p">)</span>

        <span class="c1"># Extract coordinates from indexers</span>
        <span class="n">coord_vars</span><span class="p">,</span> <span class="n">new_indexes</span> <span class="o">=</span> <span class="n">selected</span><span class="o">.</span><span class="n">_get_indexers_coords_and_indexes</span><span class="p">(</span><span class="n">indexers</span><span class="p">)</span>
        <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">coord_vars</span><span class="p">)</span>
        <span class="n">indexes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_indexes</span><span class="p">)</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">&amp;</span> <span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">|</span> <span class="n">coord_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sel</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a new dataset with each array indexed by tick labels</span>
<span class="sd">        along the specified dimension(s).</span>

<span class="sd">        In contrast to `Dataset.isel`, indexers for this method should use</span>
<span class="sd">        labels instead of integers.</span>

<span class="sd">        Under the hood, this method is powered by using pandas&#39;s powerful Index</span>
<span class="sd">        objects. This makes label based indexing essentially just as fast as</span>
<span class="sd">        using integer indexing.</span>

<span class="sd">        It also means this method uses pandas&#39;s (well documented) logic for</span>
<span class="sd">        indexing. This means you can use string shortcuts for datetime indexes</span>
<span class="sd">        (e.g., &#39;2000-01&#39; to select all values in January 2000). It also means</span>
<span class="sd">        that slices are treated as inclusive of both the start and stop values,</span>
<span class="sd">        unlike normal Python indexing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexers : dict, optional</span>
<span class="sd">            A dict with keys matching dimensions and values given</span>
<span class="sd">            by scalars, slices or arrays of tick labels. For dimensions with</span>
<span class="sd">            multi-index, the indexer may also be a dict-like object with keys</span>
<span class="sd">            matching index level names.</span>
<span class="sd">            If DataArrays are passed as indexers, xarray-style indexing will be</span>
<span class="sd">            carried out. See :ref:`indexing` for the details.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>
<span class="sd">        method : {None, &quot;nearest&quot;, &quot;pad&quot;, &quot;ffill&quot;, &quot;backfill&quot;, &quot;bfill&quot;}, optional</span>
<span class="sd">            Method to use for inexact matches:</span>

<span class="sd">            * None (default): only exact matches</span>
<span class="sd">            * pad / ffill: propagate last valid index value forward</span>
<span class="sd">            * backfill / bfill: propagate next valid index value backward</span>
<span class="sd">            * nearest: use nearest valid index value</span>
<span class="sd">        tolerance : optional</span>
<span class="sd">            Maximum distance between original and new labels for inexact</span>
<span class="sd">            matches. The values of the index at the matching locations must</span>
<span class="sd">            satisfy the equation ``abs(index[indexer] - target) &lt;= tolerance``.</span>
<span class="sd">        drop : bool, optional</span>
<span class="sd">            If ``drop=True``, drop coordinates variables in `indexers` instead</span>
<span class="sd">            of making them scalar.</span>
<span class="sd">        **indexers_kwargs : {dim: indexer, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``indexers``.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : Dataset</span>
<span class="sd">            A new Dataset with the same contents as this dataset, except each</span>
<span class="sd">            variable and dimension is indexed by the appropriate indexers.</span>
<span class="sd">            If indexer DataArrays have coordinates that do not conflict with</span>
<span class="sd">            this object, then these coordinates will be attached.</span>
<span class="sd">            In general, each array&#39;s data will be a view of the array&#39;s data</span>
<span class="sd">            in this dataset, unless vectorized indexing was triggered by using</span>
<span class="sd">            an array indexer, in which case the data will be a copy.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.isel</span>
<span class="sd">        DataArray.sel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">indexers_kwargs</span><span class="p">,</span> <span class="s2">&quot;sel&quot;</span><span class="p">)</span>
        <span class="n">pos_indexers</span><span class="p">,</span> <span class="n">new_indexes</span> <span class="o">=</span> <span class="n">remap_label_indexers</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">indexers</span><span class="o">=</span><span class="n">indexers</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span>
        <span class="p">)</span>
        <span class="c1"># TODO: benbovy - flexible indexes: also use variables returned by Index.query</span>
        <span class="c1"># (temporary dirty fix).</span>
        <span class="n">new_indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">indexers</span><span class="o">=</span><span class="n">pos_indexers</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="n">drop</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">_overwrite_indexes</span><span class="p">(</span><span class="n">new_indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">head</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a new dataset with the first `n` values of each array</span>
<span class="sd">        for the specified dimension(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexers : dict or int, default: 5</span>
<span class="sd">            A dict with keys matching dimensions and integer values `n`</span>
<span class="sd">            or a single integer `n` applied over all dimensions.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>
<span class="sd">        **indexers_kwargs : {dim: n, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``indexers``.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.tail</span>
<span class="sd">        Dataset.thin</span>
<span class="sd">        DataArray.head</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">indexers_kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">indexers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">indexers</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">indexers</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;indexers must be either dict-like or a single integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">indexers</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="n">indexers</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">indexers_kwargs</span><span class="p">,</span> <span class="s2">&quot;head&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;expected integer type indexer for &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;dimension </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">, found </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;expected positive integer as indexer &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;for dimension </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">, found </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="n">indexers_slices</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">indexers_slices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tail</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a new dataset with the last `n` values of each array</span>
<span class="sd">        for the specified dimension(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexers : dict or int, default: 5</span>
<span class="sd">            A dict with keys matching dimensions and integer values `n`</span>
<span class="sd">            or a single integer `n` applied over all dimensions.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>
<span class="sd">        **indexers_kwargs : {dim: n, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``indexers``.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.head</span>
<span class="sd">        Dataset.thin</span>
<span class="sd">        DataArray.tail</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">indexers_kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">indexers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">indexers</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">indexers</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;indexers must be either dict-like or a single integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">indexers</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="n">indexers</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">indexers_kwargs</span><span class="p">,</span> <span class="s2">&quot;tail&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;expected integer type indexer for &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;dimension </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">, found </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;expected positive integer as indexer &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;for dimension </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">, found </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="n">indexers_slices</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="n">val</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">indexers_slices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">thin</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a new dataset with each array indexed along every `n`-th</span>
<span class="sd">        value for the specified dimension(s)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexers : dict or int</span>
<span class="sd">            A dict with keys matching dimensions and integer values `n`</span>
<span class="sd">            or a single integer `n` applied over all dimensions.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>
<span class="sd">        **indexers_kwargs : {dim: n, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``indexers``.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.head</span>
<span class="sd">        Dataset.tail</span>
<span class="sd">        DataArray.thin</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">indexers_kwargs</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">indexers</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;indexers must be either dict-like or a single integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">indexers</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="n">indexers</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">indexers_kwargs</span><span class="p">,</span> <span class="s2">&quot;thin&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;expected integer type indexer for &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;dimension </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">, found </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;expected positive integer as indexer &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;for dimension </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">, found </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;step cannot be zero&quot;</span><span class="p">)</span>
        <span class="n">indexers_slices</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">indexers_slices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">broadcast_like</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">|</span> <span class="n">DataArray</span><span class="p">,</span> <span class="n">exclude</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Broadcast this DataArray against another Dataset or DataArray.</span>
<span class="sd">        This is equivalent to xr.broadcast(other, self)[1]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Dataset or DataArray</span>
<span class="sd">            Object against which to broadcast this array.</span>
<span class="sd">        exclude : iterable of hashable, optional</span>
<span class="sd">            Dimensions that must not be broadcasted</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">)</span>

        <span class="n">dims_map</span><span class="p">,</span> <span class="n">common_coords</span> <span class="o">=</span> <span class="n">_get_broadcast_dims_map_common_coords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">exclude</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_broadcast_helper</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">exclude</span><span class="p">,</span> <span class="n">dims_map</span><span class="p">,</span> <span class="n">common_coords</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reindex_like</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">|</span> <span class="n">DataArray</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Conform this object onto the indexes of another object, filling in</span>
<span class="sd">        missing values with ``fill_value``. The default fill value is NaN.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Dataset or DataArray</span>
<span class="sd">            Object with an &#39;indexes&#39; attribute giving a mapping from dimension</span>
<span class="sd">            names to pandas.Index objects, which provides coordinates upon</span>
<span class="sd">            which to index the variables in this dataset. The indexes on this</span>
<span class="sd">            other object need not be the same as the indexes on this</span>
<span class="sd">            dataset. Any mis-matched index values will be filled in with</span>
<span class="sd">            NaN, and any mis-matched dimension names will simply be ignored.</span>
<span class="sd">        method : {None, &quot;nearest&quot;, &quot;pad&quot;, &quot;ffill&quot;, &quot;backfill&quot;, &quot;bfill&quot;}, optional</span>
<span class="sd">            Method to use for filling index values from other not found in this</span>
<span class="sd">            dataset:</span>

<span class="sd">            * None (default): don&#39;t fill gaps</span>
<span class="sd">            * pad / ffill: propagate last valid index value forward</span>
<span class="sd">            * backfill / bfill: propagate next valid index value backward</span>
<span class="sd">            * nearest: use nearest valid index value</span>
<span class="sd">        tolerance : optional</span>
<span class="sd">            Maximum distance between original and new labels for inexact</span>
<span class="sd">            matches. The values of the index at the matching locations must</span>
<span class="sd">            satisfy the equation ``abs(index[indexer] - target) &lt;= tolerance``.</span>
<span class="sd">            Tolerance may be a scalar value, which applies the same tolerance</span>
<span class="sd">            to all values, or list-like, which applies variable tolerance per</span>
<span class="sd">            element. List-like must be the same size as the index and its dtype</span>
<span class="sd">            must exactly match the index’s type.</span>
<span class="sd">        copy : bool, optional</span>
<span class="sd">            If ``copy=True``, data in the return value is always copied. If</span>
<span class="sd">            ``copy=False`` and reindexing is unnecessary, or can be performed</span>
<span class="sd">            with only slice operations, then the output may share memory with</span>
<span class="sd">            the input. In either case, a new xarray object is always returned.</span>
<span class="sd">        fill_value : scalar or dict-like, optional</span>
<span class="sd">            Value to use for newly missing values. If a dict-like maps</span>
<span class="sd">            variable names to fill values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reindexed : Dataset</span>
<span class="sd">            Another dataset, with this dataset&#39;s data but coordinates from the</span>
<span class="sd">            other object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.reindex</span>
<span class="sd">        align</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">reindex_like_indexers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
            <span class="n">indexers</span><span class="o">=</span><span class="n">indexers</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Conform this object onto a new set of indexes, filling in</span>
<span class="sd">        missing values with ``fill_value``. The default fill value is NaN.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexers : dict, optional</span>
<span class="sd">            Dictionary with keys given by dimension names and values given by</span>
<span class="sd">            arrays of coordinates tick labels. Any mis-matched coordinate</span>
<span class="sd">            values will be filled in with NaN, and any mis-matched dimension</span>
<span class="sd">            names will simply be ignored.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>
<span class="sd">        method : {None, &quot;nearest&quot;, &quot;pad&quot;, &quot;ffill&quot;, &quot;backfill&quot;, &quot;bfill&quot;}, optional</span>
<span class="sd">            Method to use for filling index values in ``indexers`` not found in</span>
<span class="sd">            this dataset:</span>

<span class="sd">            * None (default): don&#39;t fill gaps</span>
<span class="sd">            * pad / ffill: propagate last valid index value forward</span>
<span class="sd">            * backfill / bfill: propagate next valid index value backward</span>
<span class="sd">            * nearest: use nearest valid index value</span>
<span class="sd">        tolerance : optional</span>
<span class="sd">            Maximum distance between original and new labels for inexact</span>
<span class="sd">            matches. The values of the index at the matching locations must</span>
<span class="sd">            satisfy the equation ``abs(index[indexer] - target) &lt;= tolerance``.</span>
<span class="sd">            Tolerance may be a scalar value, which applies the same tolerance</span>
<span class="sd">            to all values, or list-like, which applies variable tolerance per</span>
<span class="sd">            element. List-like must be the same size as the index and its dtype</span>
<span class="sd">            must exactly match the index’s type.</span>
<span class="sd">        copy : bool, optional</span>
<span class="sd">            If ``copy=True``, data in the return value is always copied. If</span>
<span class="sd">            ``copy=False`` and reindexing is unnecessary, or can be performed</span>
<span class="sd">            with only slice operations, then the output may share memory with</span>
<span class="sd">            the input. In either case, a new xarray object is always returned.</span>
<span class="sd">        fill_value : scalar or dict-like, optional</span>
<span class="sd">            Value to use for newly missing values. If a dict-like,</span>
<span class="sd">            maps variable names (including coordinates) to fill values.</span>
<span class="sd">        sparse : bool, default: False</span>
<span class="sd">            use sparse-array.</span>
<span class="sd">        **indexers_kwargs : {dim: indexer, ...}, optional</span>
<span class="sd">            Keyword arguments in the same form as ``indexers``.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reindexed : Dataset</span>
<span class="sd">            Another dataset, with this dataset&#39;s data but replaced coordinates.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.reindex_like</span>
<span class="sd">        align</span>
<span class="sd">        pandas.Index.get_indexer</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a dataset with some fictional data.</span>

<span class="sd">        &gt;&gt;&gt; x = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;temperature&quot;: (&quot;station&quot;, 20 * np.random.rand(4)),</span>
<span class="sd">        ...         &quot;pressure&quot;: (&quot;station&quot;, 500 * np.random.rand(4)),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;station&quot;: [&quot;boston&quot;, &quot;nyc&quot;, &quot;seattle&quot;, &quot;denver&quot;]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:      (station: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * station      (station) &lt;U7 &#39;boston&#39; &#39;nyc&#39; &#39;seattle&#39; &#39;denver&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (station) float64 10.98 14.3 12.06 10.9</span>
<span class="sd">            pressure     (station) float64 211.8 322.9 218.8 445.9</span>
<span class="sd">        &gt;&gt;&gt; x.indexes</span>
<span class="sd">        station: Index([&#39;boston&#39;, &#39;nyc&#39;, &#39;seattle&#39;, &#39;denver&#39;], dtype=&#39;object&#39;, name=&#39;station&#39;)</span>

<span class="sd">        Create a new index and reindex the dataset. By default values in the new index that</span>
<span class="sd">        do not have corresponding records in the dataset are assigned `NaN`.</span>

<span class="sd">        &gt;&gt;&gt; new_index = [&quot;boston&quot;, &quot;austin&quot;, &quot;seattle&quot;, &quot;lincoln&quot;]</span>
<span class="sd">        &gt;&gt;&gt; x.reindex({&quot;station&quot;: new_index})</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:      (station: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * station      (station) &lt;U7 &#39;boston&#39; &#39;austin&#39; &#39;seattle&#39; &#39;lincoln&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (station) float64 10.98 nan 12.06 nan</span>
<span class="sd">            pressure     (station) float64 211.8 nan 218.8 nan</span>

<span class="sd">        We can fill in the missing values by passing a value to the keyword `fill_value`.</span>

<span class="sd">        &gt;&gt;&gt; x.reindex({&quot;station&quot;: new_index}, fill_value=0)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:      (station: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * station      (station) &lt;U7 &#39;boston&#39; &#39;austin&#39; &#39;seattle&#39; &#39;lincoln&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (station) float64 10.98 0.0 12.06 0.0</span>
<span class="sd">            pressure     (station) float64 211.8 0.0 218.8 0.0</span>

<span class="sd">        We can also use different fill values for each variable.</span>

<span class="sd">        &gt;&gt;&gt; x.reindex(</span>
<span class="sd">        ...     {&quot;station&quot;: new_index}, fill_value={&quot;temperature&quot;: 0, &quot;pressure&quot;: 100}</span>
<span class="sd">        ... )</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:      (station: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * station      (station) &lt;U7 &#39;boston&#39; &#39;austin&#39; &#39;seattle&#39; &#39;lincoln&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (station) float64 10.98 0.0 12.06 0.0</span>
<span class="sd">            pressure     (station) float64 211.8 100.0 218.8 100.0</span>

<span class="sd">        Because the index is not monotonically increasing or decreasing, we cannot use arguments</span>
<span class="sd">        to the keyword method to fill the `NaN` values.</span>

<span class="sd">        &gt;&gt;&gt; x.reindex({&quot;station&quot;: new_index}, method=&quot;nearest&quot;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">            raise ValueError(&#39;index must be monotonic increasing or decreasing&#39;)</span>
<span class="sd">        ValueError: index must be monotonic increasing or decreasing</span>

<span class="sd">        To further illustrate the filling functionality in reindex, we will create a</span>
<span class="sd">        dataset with a monotonically increasing index (for example, a sequence of dates).</span>

<span class="sd">        &gt;&gt;&gt; x2 = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;temperature&quot;: (</span>
<span class="sd">        ...             &quot;time&quot;,</span>
<span class="sd">        ...             [15.57, 12.77, np.nan, 0.3081, 16.59, 15.12],</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...         &quot;pressure&quot;: (&quot;time&quot;, 500 * np.random.rand(6)),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;time&quot;: pd.date_range(&quot;01/01/2019&quot;, periods=6, freq=&quot;D&quot;)},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; x2</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:      (time: 6)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time         (time) datetime64[ns] 2019-01-01 2019-01-02 ... 2019-01-06</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time) float64 15.57 12.77 nan 0.3081 16.59 15.12</span>
<span class="sd">            pressure     (time) float64 481.8 191.7 395.9 264.4 284.0 462.8</span>

<span class="sd">        Suppose we decide to expand the dataset to cover a wider date range.</span>

<span class="sd">        &gt;&gt;&gt; time_index2 = pd.date_range(&quot;12/29/2018&quot;, periods=10, freq=&quot;D&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x2.reindex({&quot;time&quot;: time_index2})</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:      (time: 10)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time         (time) datetime64[ns] 2018-12-29 2018-12-30 ... 2019-01-07</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time) float64 nan nan nan 15.57 ... 0.3081 16.59 15.12 nan</span>
<span class="sd">            pressure     (time) float64 nan nan nan 481.8 ... 264.4 284.0 462.8 nan</span>

<span class="sd">        The index entries that did not have a value in the original data frame (for example, `2018-12-29`)</span>
<span class="sd">        are by default filled with NaN. If desired, we can fill in the missing values using one of several options.</span>

<span class="sd">        For example, to back-propagate the last valid value to fill the `NaN` values,</span>
<span class="sd">        pass `bfill` as an argument to the `method` keyword.</span>

<span class="sd">        &gt;&gt;&gt; x3 = x2.reindex({&quot;time&quot;: time_index2}, method=&quot;bfill&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x3</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:      (time: 10)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time         (time) datetime64[ns] 2018-12-29 2018-12-30 ... 2019-01-07</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time) float64 15.57 15.57 15.57 15.57 ... 16.59 15.12 nan</span>
<span class="sd">            pressure     (time) float64 481.8 481.8 481.8 481.8 ... 284.0 462.8 nan</span>

<span class="sd">        Please note that the `NaN` value present in the original dataset (at index value `2019-01-03`)</span>
<span class="sd">        will not be filled by any of the value propagation schemes.</span>

<span class="sd">        &gt;&gt;&gt; x2.where(x2.temperature.isnull(), drop=True)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:      (time: 1)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time         (time) datetime64[ns] 2019-01-03</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time) float64 nan</span>
<span class="sd">            pressure     (time) float64 395.9</span>
<span class="sd">        &gt;&gt;&gt; x3.where(x3.temperature.isnull(), drop=True)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:      (time: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time         (time) datetime64[ns] 2019-01-03 2019-01-07</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time) float64 nan nan</span>
<span class="sd">            pressure     (time) float64 395.9 nan</span>

<span class="sd">        This is because filling while reindexing does not look at dataset values, but only compares</span>
<span class="sd">        the original and desired indexes. If you do want to fill in the `NaN` values present in the</span>
<span class="sd">        original dataset, use the :py:meth:`~Dataset.fillna()` method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex</span><span class="p">(</span>
            <span class="n">indexers</span><span class="p">,</span>
            <span class="n">method</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="p">,</span>
            <span class="n">copy</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="p">,</span>
            <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
        <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        same to _reindex but support sparse option</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">indexers_kwargs</span><span class="p">,</span> <span class="s2">&quot;reindex&quot;</span><span class="p">)</span>

        <span class="n">bad_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">indexers</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bad_dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid reindex dimensions: </span><span class="si">{</span><span class="n">bad_dims</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">variables</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">reindex_variables</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">,</span>
            <span class="n">indexers</span><span class="p">,</span>
            <span class="n">method</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="n">sparse</span><span class="o">=</span><span class="n">sparse</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">)</span>
        <span class="n">coord_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">indexers</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">interp</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coords</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">assume_sorted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method_non_numeric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">coords_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Multidimensional interpolation of Dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords : dict, optional</span>
<span class="sd">            Mapping from dimension names to the new coordinates.</span>
<span class="sd">            New coordinate can be a scalar, array-like or DataArray.</span>
<span class="sd">            If DataArrays are passed as new coordinates, their dimensions are</span>
<span class="sd">            used for the broadcasting. Missing values are skipped.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            {&quot;linear&quot;, &quot;nearest&quot;} for multidimensional array,</span>
<span class="sd">            {&quot;linear&quot;, &quot;nearest&quot;, &quot;zero&quot;, &quot;slinear&quot;, &quot;quadratic&quot;, &quot;cubic&quot;}</span>
<span class="sd">            for 1-dimensional array. &quot;linear&quot; is used by default.</span>
<span class="sd">        assume_sorted : bool, optional</span>
<span class="sd">            If False, values of coordinates that are interpolated over can be</span>
<span class="sd">            in any order and they are sorted first. If True, interpolated</span>
<span class="sd">            coordinates are assumed to be an array of monotonically increasing</span>
<span class="sd">            values.</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to scipy&#39;s interpolator. Valid</span>
<span class="sd">            options and their behavior depend on if 1-dimensional or</span>
<span class="sd">            multi-dimensional interpolation is used.</span>
<span class="sd">        method_non_numeric : {&quot;nearest&quot;, &quot;pad&quot;, &quot;ffill&quot;, &quot;backfill&quot;, &quot;bfill&quot;}, optional</span>
<span class="sd">            Method for non-numeric types. Passed on to :py:meth:`Dataset.reindex`.</span>
<span class="sd">            ``&quot;nearest&quot;`` is used by default.</span>
<span class="sd">        **coords_kwargs : {dim: coordinate, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``coords``.</span>
<span class="sd">            One of coords or coords_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        interpolated : Dataset</span>
<span class="sd">            New dataset on the new coordinates.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        scipy is required.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        scipy.interpolate.interp1d</span>
<span class="sd">        scipy.interpolate.interpn</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     data_vars={</span>
<span class="sd">        ...         &quot;a&quot;: (&quot;x&quot;, [5, 7, 4]),</span>
<span class="sd">        ...         &quot;b&quot;: (</span>
<span class="sd">        ...             (&quot;x&quot;, &quot;y&quot;),</span>
<span class="sd">        ...             [[1, 4, 2, 9], [2, 7, 6, np.nan], [6, np.nan, 5, 8]],</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;x&quot;: [0, 1, 2], &quot;y&quot;: [10, 12, 14, 16]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 3, y: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 0 1 2</span>
<span class="sd">          * y        (y) int64 10 12 14 16</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) int64 5 7 4</span>
<span class="sd">            b        (x, y) float64 1.0 4.0 2.0 9.0 2.0 7.0 6.0 nan 6.0 nan 5.0 8.0</span>

<span class="sd">        1D interpolation with the default method (linear):</span>

<span class="sd">        &gt;&gt;&gt; ds.interp(x=[0, 0.75, 1.25, 1.75])</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 4, y: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) int64 10 12 14 16</span>
<span class="sd">          * x        (x) float64 0.0 0.75 1.25 1.75</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) float64 5.0 6.5 6.25 4.75</span>
<span class="sd">            b        (x, y) float64 1.0 4.0 2.0 nan 1.75 6.25 ... nan 5.0 nan 5.25 nan</span>

<span class="sd">        1D interpolation with a different method:</span>

<span class="sd">        &gt;&gt;&gt; ds.interp(x=[0, 0.75, 1.25, 1.75], method=&quot;nearest&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 4, y: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) int64 10 12 14 16</span>
<span class="sd">          * x        (x) float64 0.0 0.75 1.25 1.75</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) float64 5.0 7.0 7.0 4.0</span>
<span class="sd">            b        (x, y) float64 1.0 4.0 2.0 9.0 2.0 7.0 ... 6.0 nan 6.0 nan 5.0 8.0</span>

<span class="sd">        1D extrapolation:</span>

<span class="sd">        &gt;&gt;&gt; ds.interp(</span>
<span class="sd">        ...     x=[1, 1.5, 2.5, 3.5],</span>
<span class="sd">        ...     method=&quot;linear&quot;,</span>
<span class="sd">        ...     kwargs={&quot;fill_value&quot;: &quot;extrapolate&quot;},</span>
<span class="sd">        ... )</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 4, y: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) int64 10 12 14 16</span>
<span class="sd">          * x        (x) float64 1.0 1.5 2.5 3.5</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) float64 7.0 5.5 2.5 -0.5</span>
<span class="sd">            b        (x, y) float64 2.0 7.0 6.0 nan 4.0 nan ... 4.5 nan 12.0 nan 3.5 nan</span>

<span class="sd">        2D interpolation:</span>

<span class="sd">        &gt;&gt;&gt; ds.interp(x=[0, 0.75, 1.25, 1.75], y=[11, 13, 15], method=&quot;linear&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 4, y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) float64 0.0 0.75 1.25 1.75</span>
<span class="sd">          * y        (y) int64 11 13 15</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) float64 5.0 6.5 6.25 4.75</span>
<span class="sd">            b        (x, y) float64 2.5 3.0 nan 4.0 5.625 nan nan nan nan nan nan nan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">missing</span>

        <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">coords_kwargs</span><span class="p">,</span> <span class="s2">&quot;interp&quot;</span><span class="p">)</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_validate_interp_indexers</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">coords</span><span class="p">:</span>
            <span class="c1"># This avoids broadcasting over coordinates that are both in</span>
            <span class="c1"># the original array AND in the indexing array. It essentially</span>
            <span class="c1"># forces interpolation along the shared coordinates.</span>
            <span class="n">sdims</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
                <span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="k">for</span> <span class="n">nx</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
                <span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="p">)</span>
            <span class="n">indexers</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">d</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sdims</span><span class="p">})</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">assume_sorted</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">sortby</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">maybe_variable</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="c1"># workaround to get variable for dimension without coordinate.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">as_variable</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="n">k</span><span class="p">])))</span>

        <span class="k">def</span> <span class="nf">_validate_interp_indexer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">new_x</span><span class="p">):</span>
            <span class="c1"># In the case of datetimes, the restrictions placed on indexers</span>
            <span class="c1"># used with interp are stronger than those which are placed on</span>
            <span class="c1"># isel, so we need an additional check after _validate_indexers.</span>
            <span class="k">if</span> <span class="n">_contains_datetime_like_objects</span><span class="p">(</span>
                <span class="n">x</span>
            <span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_contains_datetime_like_objects</span><span class="p">(</span><span class="n">new_x</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;When interpolating over a datetime-like &quot;</span>
                    <span class="s2">&quot;coordinate, the coordinates to &quot;</span>
                    <span class="s2">&quot;interpolate to must be either datetime &quot;</span>
                    <span class="s2">&quot;strings or datetimes. &quot;</span>
                    <span class="s2">&quot;Instead got</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">new_x</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">new_x</span>

        <span class="n">validated_indexers</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">_validate_interp_indexer</span><span class="p">(</span><span class="n">maybe_variable</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1"># optimization: subset to coordinate range of the target index</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">validated_indexers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">obj</span><span class="p">,</span> <span class="n">newidx</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">_localize</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">})</span>
                <span class="n">validated_indexers</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">newidx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="c1"># optimization: create dask coordinate arrays once per Dataset</span>
        <span class="c1"># rather than once per Variable when dask.array.unify_chunks is called later</span>
        <span class="c1"># GH4739</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">__dask_graph__</span><span class="p">():</span>
            <span class="n">dask_indexers</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">to_base_variable</span><span class="p">()</span><span class="o">.</span><span class="n">chunk</span><span class="p">(),</span> <span class="n">dest</span><span class="o">.</span><span class="n">to_base_variable</span><span class="p">()</span><span class="o">.</span><span class="n">chunk</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span> <span class="ow">in</span> <span class="n">validated_indexers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>

        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">to_reindex</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">indexers</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">is_duck_dask_array</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
                <span class="n">use_indexers</span> <span class="o">=</span> <span class="n">dask_indexers</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">use_indexers</span> <span class="o">=</span> <span class="n">validated_indexers</span>

            <span class="n">dtype_kind</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span>
            <span class="k">if</span> <span class="n">dtype_kind</span> <span class="ow">in</span> <span class="s2">&quot;uifc&quot;</span><span class="p">:</span>
                <span class="c1"># For normal number types do the interpolation:</span>
                <span class="n">var_indexers</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">use_indexers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">var_indexers</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dtype_kind</span> <span class="ow">in</span> <span class="s2">&quot;ObU&quot;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">use_indexers</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
                <span class="c1"># For types that we do not understand do stepwise</span>
                <span class="c1"># interpolation to avoid modifying the elements.</span>
                <span class="c1"># Use reindex_variables instead because it supports</span>
                <span class="c1"># booleans and objects and retains the dtype but inside</span>
                <span class="c1"># this loop there might be some duplicate code that slows it</span>
                <span class="c1"># down, therefore collect these signals and run it later:</span>
                <span class="n">to_reindex</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indexers</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
                <span class="c1"># For anything else we can only keep variables if they</span>
                <span class="c1"># are not dependent on any coords that are being</span>
                <span class="c1"># interpolated along:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="k">if</span> <span class="n">to_reindex</span><span class="p">:</span>
            <span class="c1"># Reindex variables:</span>
            <span class="n">variables_reindex</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">reindex_variables</span><span class="p">(</span>
                <span class="n">variables</span><span class="o">=</span><span class="n">to_reindex</span><span class="p">,</span>
                <span class="n">sizes</span><span class="o">=</span><span class="n">obj</span><span class="o">.</span><span class="n">sizes</span><span class="p">,</span>
                <span class="n">indexes</span><span class="o">=</span><span class="n">obj</span><span class="o">.</span><span class="n">xindexes</span><span class="p">,</span>
                <span class="n">indexers</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">validated_indexers</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method_non_numeric</span><span class="p">,</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">variables_reindex</span><span class="p">)</span>

        <span class="c1"># Get the coords that also exist in the variables:</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">&amp;</span> <span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># Get the indexes that are not being interpolated along:</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indexers</span><span class="p">}</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">variables</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span>
        <span class="p">)</span>

        <span class="c1"># Attach indexer as coordinate</span>
        <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">indexers</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span> <span class="o">==</span> <span class="p">(</span><span class="n">k</span><span class="p">,):</span>
                <span class="n">indexes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">_to_xindex</span><span class="p">()</span>

        <span class="c1"># Extract coordinates from indexers</span>
        <span class="n">coord_vars</span><span class="p">,</span> <span class="n">new_indexes</span> <span class="o">=</span> <span class="n">selected</span><span class="o">.</span><span class="n">_get_indexers_coords_and_indexes</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">coord_vars</span><span class="p">)</span>
        <span class="n">indexes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_indexes</span><span class="p">)</span>

        <span class="n">coord_names</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">&amp;</span> <span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">|</span> <span class="n">coord_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">interp_like</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">|</span> <span class="n">DataArray</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">assume_sorted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method_non_numeric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Interpolate this object onto the coordinates of another object,</span>
<span class="sd">        filling the out of range values with NaN.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Dataset or DataArray</span>
<span class="sd">            Object with an &#39;indexes&#39; attribute giving a mapping from dimension</span>
<span class="sd">            names to an 1d array-like, which provides coordinates upon</span>
<span class="sd">            which to index the variables in this dataset. Missing values are skipped.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            {&quot;linear&quot;, &quot;nearest&quot;} for multidimensional array,</span>
<span class="sd">            {&quot;linear&quot;, &quot;nearest&quot;, &quot;zero&quot;, &quot;slinear&quot;, &quot;quadratic&quot;, &quot;cubic&quot;}</span>
<span class="sd">            for 1-dimensional array. &#39;linear&#39; is used by default.</span>
<span class="sd">        assume_sorted : bool, optional</span>
<span class="sd">            If False, values of coordinates that are interpolated over can be</span>
<span class="sd">            in any order and they are sorted first. If True, interpolated</span>
<span class="sd">            coordinates are assumed to be an array of monotonically increasing</span>
<span class="sd">            values.</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            Additional keyword passed to scipy&#39;s interpolator.</span>
<span class="sd">        method_non_numeric : {&quot;nearest&quot;, &quot;pad&quot;, &quot;ffill&quot;, &quot;backfill&quot;, &quot;bfill&quot;}, optional</span>
<span class="sd">            Method for non-numeric types. Passed on to :py:meth:`Dataset.reindex`.</span>
<span class="sd">            ``&quot;nearest&quot;`` is used by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        interpolated : Dataset</span>
<span class="sd">            Another dataset by interpolating this dataset&#39;s data along the</span>
<span class="sd">            coordinates of the other object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        scipy is required.</span>
<span class="sd">        If the dataset has object-type coordinates, reindex is used for these</span>
<span class="sd">        coordinates instead of the interpolation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.interp</span>
<span class="sd">        Dataset.reindex_like</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">reindex_like_indexers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="n">numeric_coords</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">object_coords</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;uifcMm&quot;</span><span class="p">:</span>
                <span class="n">numeric_coords</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">object_coords</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">object_coords</span><span class="p">:</span>
            <span class="c1"># We do not support interpolation along object coordinate.</span>
            <span class="c1"># reindex instead.</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">object_coords</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ds</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">numeric_coords</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">assume_sorted</span><span class="o">=</span><span class="n">assume_sorted</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="n">method_non_numeric</span><span class="o">=</span><span class="n">method_non_numeric</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Helper methods for rename()</span>
    <span class="k">def</span> <span class="nf">_rename_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_dict</span><span class="p">,</span> <span class="n">dims_dict</span><span class="p">):</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dims_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;the new name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> conflicts&quot;</span><span class="p">)</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">:</span>
                <span class="n">coord_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span>

    <span class="k">def</span> <span class="nf">_rename_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">name_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">def</span> <span class="nf">_rename_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_dict</span><span class="p">,</span> <span class="n">dims_set</span><span class="p">):</span>
        <span class="c1"># TODO: benbovy - flexible indexes: https://github.com/pydata/xarray/issues/5645</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="n">name_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims_set</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
                <span class="n">new_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>
                <span class="n">indexes</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">PandasMultiIndex</span><span class="p">(</span>
                    <span class="n">v</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">new_names</span><span class="p">),</span> <span class="n">new_name</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indexes</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">PandasIndex</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">new_name</span><span class="p">),</span> <span class="n">new_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">indexes</span>

    <span class="k">def</span> <span class="nf">_rename_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_dict</span><span class="p">,</span> <span class="n">dims_dict</span><span class="p">):</span>
        <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename_vars</span><span class="p">(</span><span class="n">name_dict</span><span class="p">,</span> <span class="n">dims_dict</span><span class="p">)</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename_dims</span><span class="p">(</span><span class="n">dims_dict</span><span class="p">)</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename_indexes</span><span class="p">(</span><span class="n">name_dict</span><span class="p">,</span> <span class="n">dims</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">indexes</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name_dict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">names</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a new object with renamed variables and dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name_dict : dict-like, optional</span>
<span class="sd">            Dictionary whose keys are current variable or dimension names and</span>
<span class="sd">            whose values are the desired names.</span>
<span class="sd">        **names : optional</span>
<span class="sd">            Keyword form of ``name_dict``.</span>
<span class="sd">            One of name_dict or names must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        renamed : Dataset</span>
<span class="sd">            Dataset with renamed variables and dimensions.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.swap_dims</span>
<span class="sd">        Dataset.rename_vars</span>
<span class="sd">        Dataset.rename_dims</span>
<span class="sd">        DataArray.rename</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name_dict</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">name_dict</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="s2">&quot;rename&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">name_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;cannot rename </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> because it is not a &quot;</span>
                    <span class="s2">&quot;variable or dimension in this dataset&quot;</span>
                <span class="p">)</span>

        <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename_all</span><span class="p">(</span>
            <span class="n">name_dict</span><span class="o">=</span><span class="n">name_dict</span><span class="p">,</span> <span class="n">dims_dict</span><span class="o">=</span><span class="n">name_dict</span>
        <span class="p">)</span>
        <span class="n">assert_unique_multiindex_level_names</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dims_dict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">dims</span><span class="p">:</span> <span class="n">Hashable</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a new object with renamed dimensions only.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dims_dict : dict-like, optional</span>
<span class="sd">            Dictionary whose keys are current dimension names and</span>
<span class="sd">            whose values are the desired names. The desired names must</span>
<span class="sd">            not be the name of an existing dimension or Variable in the Dataset.</span>
<span class="sd">        **dims : optional</span>
<span class="sd">            Keyword form of ``dims_dict``.</span>
<span class="sd">            One of dims_dict or dims must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        renamed : Dataset</span>
<span class="sd">            Dataset with renamed dimensions.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.swap_dims</span>
<span class="sd">        Dataset.rename</span>
<span class="sd">        Dataset.rename_vars</span>
<span class="sd">        DataArray.rename</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dims_dict</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">dims_dict</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="s2">&quot;rename_dims&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dims_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;cannot rename </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> because it is not a &quot;</span>
                    <span class="s2">&quot;dimension in this dataset&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="ow">or</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot rename </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> because </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> already exists. &quot;</span>
                    <span class="s2">&quot;Try using swap_dims instead.&quot;</span>
                <span class="p">)</span>

        <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename_all</span><span class="p">(</span>
            <span class="n">name_dict</span><span class="o">=</span><span class="p">{},</span> <span class="n">dims_dict</span><span class="o">=</span><span class="n">dims_dict</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">sizes</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename_vars</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name_dict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">names</span><span class="p">:</span> <span class="n">Hashable</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a new object with renamed variables including coordinates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name_dict : dict-like, optional</span>
<span class="sd">            Dictionary whose keys are current variable or coordinate names and</span>
<span class="sd">            whose values are the desired names.</span>
<span class="sd">        **names : optional</span>
<span class="sd">            Keyword form of ``name_dict``.</span>
<span class="sd">            One of name_dict or names must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        renamed : Dataset</span>
<span class="sd">            Dataset with renamed variables including coordinates</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.swap_dims</span>
<span class="sd">        Dataset.rename</span>
<span class="sd">        Dataset.rename_dims</span>
<span class="sd">        DataArray.rename</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name_dict</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">name_dict</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="s2">&quot;rename_vars&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">name_dict</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;cannot rename </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> because it is not a &quot;</span>
                    <span class="s2">&quot;variable or coordinate in this dataset&quot;</span>
                <span class="p">)</span>
        <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename_all</span><span class="p">(</span>
            <span class="n">name_dict</span><span class="o">=</span><span class="n">name_dict</span><span class="p">,</span> <span class="n">dims_dict</span><span class="o">=</span><span class="p">{}</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">swap_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dims_dict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">dims_kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a new object with swapped dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dims_dict : dict-like</span>
<span class="sd">            Dictionary whose keys are current dimension names and whose values</span>
<span class="sd">            are new names.</span>
<span class="sd">        **dims_kwargs : {existing_dim: new_dim, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``dims_dict``.</span>
<span class="sd">            One of dims_dict or dims_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        swapped : Dataset</span>
<span class="sd">            Dataset with swapped dimensions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     data_vars={&quot;a&quot;: (&quot;x&quot;, [5, 7]), &quot;b&quot;: (&quot;x&quot;, [0.1, 2.4])},</span>
<span class="sd">        ...     coords={&quot;x&quot;: [&quot;a&quot;, &quot;b&quot;], &quot;y&quot;: (&quot;x&quot;, [0, 1])},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) &lt;U1 &#39;a&#39; &#39;b&#39;</span>
<span class="sd">            y        (x) int64 0 1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) int64 5 7</span>
<span class="sd">            b        (x) float64 0.1 2.4</span>

<span class="sd">        &gt;&gt;&gt; ds.swap_dims({&quot;x&quot;: &quot;y&quot;})</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (y: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">            x        (y) &lt;U1 &#39;a&#39; &#39;b&#39;</span>
<span class="sd">          * y        (y) int64 0 1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (y) int64 5 7</span>
<span class="sd">            b        (y) float64 0.1 2.4</span>

<span class="sd">        &gt;&gt;&gt; ds.swap_dims({&quot;x&quot;: &quot;z&quot;})</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (z: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">            x        (z) &lt;U1 &#39;a&#39; &#39;b&#39;</span>
<span class="sd">            y        (z) int64 0 1</span>
<span class="sd">        Dimensions without coordinates: z</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (z) int64 5 7</span>
<span class="sd">            b        (z) float64 0.1 2.4</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.rename</span>
<span class="sd">        DataArray.swap_dims</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: deprecate this method in favor of a (less confusing)</span>
        <span class="c1"># rename_dims() method that only renames dimensions.</span>

        <span class="n">dims_dict</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">dims_dict</span><span class="p">,</span> <span class="n">dims_kwargs</span><span class="p">,</span> <span class="s2">&quot;swap_dims&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dims_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;cannot swap from dimension </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> because it is &quot;</span>
                    <span class="s2">&quot;not an existing dimension&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span> <span class="o">!=</span> <span class="p">(</span><span class="n">k</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;replacement dimension </span><span class="si">{</span><span class="n">v</span><span class="si">!r}</span><span class="s2"> is not a 1D &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;variable along the old dimension </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="n">result_dims</span> <span class="o">=</span> <span class="p">{</span><span class="n">dims_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>

        <span class="n">coord_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">coord_names</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">})</span>

        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dims_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">result_dims</span><span class="p">:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">to_index_variable</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">:</span>
                    <span class="n">indexes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_index</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">to_index</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">new_index</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># make sure index name matches dimension name</span>
                        <span class="n">new_index</span> <span class="o">=</span> <span class="n">new_index</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
                        <span class="n">indexes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">PandasMultiIndex</span><span class="p">(</span><span class="n">new_index</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">indexes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">PandasIndex</span><span class="p">(</span><span class="n">new_index</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">to_base_variable</span><span class="p">()</span>
            <span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="n">dims</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">expand_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">dim_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new object with an additional axis (or axes) inserted at</span>
<span class="sd">        the corresponding position in the array shape.  The new object is a</span>
<span class="sd">        view into the underlying array, not a copy.</span>

<span class="sd">        If dim is already a scalar coordinate, it will be promoted to a 1D</span>
<span class="sd">        coordinate consisting of a single value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : hashable, sequence of hashable, mapping, or None</span>
<span class="sd">            Dimensions to include on the new variable. If provided as hashable</span>
<span class="sd">            or sequence of hashable, then dimensions are inserted with length</span>
<span class="sd">            1. If provided as a mapping, then the keys are the new dimensions</span>
<span class="sd">            and the values are either integers (giving the length of the new</span>
<span class="sd">            dimensions) or array-like (giving the coordinates of the new</span>
<span class="sd">            dimensions).</span>
<span class="sd">        axis : int, sequence of int, or None</span>
<span class="sd">            Axis position(s) where new axis is to be inserted (position(s) on</span>
<span class="sd">            the result array). If a list (or tuple) of integers is passed,</span>
<span class="sd">            multiple axes are inserted. In this case, dim arguments should be</span>
<span class="sd">            same length list. If axis=None is passed, all the axes will be</span>
<span class="sd">            inserted to the start of the result array.</span>
<span class="sd">        **dim_kwargs : int or sequence or ndarray</span>
<span class="sd">            The keywords are arbitrary dimensions being inserted and the values</span>
<span class="sd">            are either the lengths of the new dims (if int is given), or their</span>
<span class="sd">            coordinates. Note, this is an alternative to passing a dict to the</span>
<span class="sd">            dim kwarg and will only be used if dim is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        expanded : same type as caller</span>
<span class="sd">            This object, but with an additional dimension(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="c1"># We&#39;re later going to modify dim in place; don&#39;t tamper with</span>
            <span class="c1"># the input</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;dim should be hashable or sequence of hashables or mapping&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dim</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dims should not contain duplicate values.&quot;</span><span class="p">)</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="p">:</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dim</span><span class="p">}</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim_kwargs</span><span class="p">,</span> <span class="s2">&quot;expand_dims&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">MutableMapping</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;lengths of dim and axis should be identical.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dim</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dimension </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2"> already exists.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_scalar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">d</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{dim}</span><span class="s2"> already exists as coordinate or&quot;</span>
                    <span class="s2">&quot; variable name.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># If dim is a dict, then ensure that the values are either integers</span>
        <span class="c1"># or iterables.</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dim</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
                <span class="c1"># If the value for the new dimension is an iterable, then</span>
                <span class="c1"># save the coordinates to the variables dict, and set the</span>
                <span class="c1"># value within the dim dict to the length of the iterable</span>
                <span class="c1"># for later use.</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">IndexVariable</span><span class="p">((</span><span class="n">k</span><span class="p">,),</span> <span class="n">v</span><span class="p">)</span>
                <span class="n">coord_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">dim</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">pass</span>  <span class="c1"># Do nothing if the dimensions value is just an int</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;The value of new dimension </span><span class="si">{k}</span><span class="s2"> must be &quot;</span>
                    <span class="s2">&quot;an iterable or an int&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dim</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coord_names</span><span class="p">:</span>  <span class="c1"># Do not change coordinates</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">result_ndim</span> <span class="ow">or</span> <span class="n">result_ndim</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Axis </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2"> of variable </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> is out of bounds of the &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;expanded dimension size </span><span class="si">{</span><span class="n">result_ndim</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>

                    <span class="n">axis_pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">result_ndim</span> <span class="o">+</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis_pos</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axis_pos</span><span class="p">)):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;axis should not contain duplicate values&quot;</span><span class="p">)</span>
                    <span class="c1"># We need to sort them to make sure `axis` equals to the</span>
                    <span class="c1"># axis positions of the result array.</span>
                    <span class="n">zip_axis_dim</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">axis_pos</span><span class="p">,</span> <span class="n">dim</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

                    <span class="n">all_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">zip_axis_dim</span><span class="p">:</span>
                        <span class="n">all_dims</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">set_dims</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">all_dims</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If dims includes a label of a non-dimension coordinate,</span>
                <span class="c1"># it will be promoted to a 1D coordinate with a single value.</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">set_dims</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">to_index_variable</span><span class="p">()</span>

        <span class="n">new_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_dims</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_vars_and_dims</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">new_dims</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">append</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexes_kwargs</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set Dataset (multi-)indexes using one or more existing coordinates</span>
<span class="sd">        or variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexes : {dim: index, ...}</span>
<span class="sd">            Mapping from names matching dimensions and values given</span>
<span class="sd">            by (lists of) the names of existing coordinates or variables to set</span>
<span class="sd">            as new (multi-)index.</span>
<span class="sd">        append : bool, optional</span>
<span class="sd">            If True, append the supplied index(es) to the existing index(es).</span>
<span class="sd">            Otherwise replace the existing index(es) (default).</span>
<span class="sd">        **indexes_kwargs : optional</span>
<span class="sd">            The keyword arguments form of ``indexes``.</span>
<span class="sd">            One of indexes or indexes_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : Dataset</span>
<span class="sd">            Another dataset, with this dataset&#39;s data but replaced coordinates.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; arr = xr.DataArray(</span>
<span class="sd">        ...     data=np.ones((2, 3)),</span>
<span class="sd">        ...     dims=[&quot;x&quot;, &quot;y&quot;],</span>
<span class="sd">        ...     coords={&quot;x&quot;: range(2), &quot;y&quot;: range(3), &quot;a&quot;: (&quot;x&quot;, [3, 4])},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;v&quot;: arr})</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 2, y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 0 1</span>
<span class="sd">          * y        (y) int64 0 1 2</span>
<span class="sd">            a        (x) int64 3 4</span>
<span class="sd">        Data variables:</span>
<span class="sd">            v        (x, y) float64 1.0 1.0 1.0 1.0 1.0 1.0</span>
<span class="sd">        &gt;&gt;&gt; ds.set_index(x=&quot;a&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 2, y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 3 4</span>
<span class="sd">          * y        (y) int64 0 1 2</span>
<span class="sd">        Data variables:</span>
<span class="sd">            v        (x, y) float64 1.0 1.0 1.0 1.0 1.0 1.0</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.reset_index</span>
<span class="sd">        Dataset.swap_dims</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">indexes_kwargs</span><span class="p">,</span> <span class="s2">&quot;set_index&quot;</span><span class="p">)</span>
        <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span> <span class="o">=</span> <span class="n">merge_indexes</span><span class="p">(</span>
            <span class="n">indexes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="n">append</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_vars_and_dims</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dims_or_levels</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Reset the specified index(es) or multi-index level(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dims_or_levels : str or list</span>
<span class="sd">            Name(s) of the dimension(s) and/or multi-index level(s) that will</span>
<span class="sd">            be reset.</span>
<span class="sd">        drop : bool, optional</span>
<span class="sd">            If True, remove the specified indexes and/or multi-index levels</span>
<span class="sd">            instead of extracting them as new coordinates (default: False).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : Dataset</span>
<span class="sd">            Another dataset, with this dataset&#39;s data but replaced coordinates.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.set_index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span> <span class="o">=</span> <span class="n">split_indexes</span><span class="p">(</span>
            <span class="n">dims_or_levels</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">,</span>
            <span class="n">cast</span><span class="p">(</span><span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_level_coords</span><span class="p">),</span>
            <span class="n">drop</span><span class="o">=</span><span class="n">drop</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_vars_and_dims</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reorder_levels</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim_order</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">dim_order_kwargs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Rearrange index levels using input order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim_order : optional</span>
<span class="sd">            Mapping from names matching dimensions and values given</span>
<span class="sd">            by lists representing new level orders. Every given dimension</span>
<span class="sd">            must have a multi-index.</span>
<span class="sd">        **dim_order_kwargs : optional</span>
<span class="sd">            The keyword arguments form of ``dim_order``.</span>
<span class="sd">            One of dim_order or dim_order_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : Dataset</span>
<span class="sd">            Another dataset, with this dataset&#39;s data but replaced</span>
<span class="sd">            coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim_order</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">dim_order</span><span class="p">,</span> <span class="n">dim_order_kwargs</span><span class="p">,</span> <span class="s2">&quot;reorder_levels&quot;</span><span class="p">)</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">order</span> <span class="ow">in</span> <span class="n">dim_order</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="c1"># TODO: benbovy - flexible indexes: update when MultiIndex</span>
            <span class="c1"># has its own class inherited from xarray.Index</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">to_pandas_index</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;coordinate </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> has no MultiIndex&quot;</span><span class="p">)</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">reorder_levels</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">IndexVariable</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">new_index</span><span class="p">)</span>
            <span class="n">indexes</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">PandasMultiIndex</span><span class="p">(</span><span class="n">new_index</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_stack_once</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">new_dim</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="o">==</span> <span class="o">...</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please use [...] for dims, rather than just ...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="o">...</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">infix_dims</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">))</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">d</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">):</span>
                    <span class="n">add_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>
                    <span class="n">vdims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">+</span> <span class="n">add_dims</span>
                    <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">vdims</span><span class="p">]</span>
                    <span class="n">exp_var</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">set_dims</span><span class="p">(</span><span class="n">vdims</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
                    <span class="n">stacked_var</span> <span class="o">=</span> <span class="n">exp_var</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">new_dim</span><span class="p">:</span> <span class="n">dims</span><span class="p">})</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">stacked_var</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># consider dropping levels that are unused?</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">multiindex_from_product_levels</span><span class="p">(</span><span class="n">levels</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">variables</span><span class="p">[</span><span class="n">new_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">IndexVariable</span><span class="p">(</span><span class="n">new_dim</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

        <span class="n">coord_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">|</span> <span class="p">{</span><span class="n">new_dim</span><span class="p">}</span>

        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">}</span>
        <span class="n">indexes</span><span class="p">[</span><span class="n">new_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">PandasMultiIndex</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">new_dim</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">stack</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dimensions</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">dimensions_kwargs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stack any number of existing dimensions into a single new dimension.</span>

<span class="sd">        New dimensions will be added at the end, and the corresponding</span>
<span class="sd">        coordinate variables will be combined into a MultiIndex.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dimensions : mapping of hashable to sequence of hashable</span>
<span class="sd">            Mapping of the form `new_name=(dim1, dim2, ...)`. Names of new</span>
<span class="sd">            dimensions, and the existing dimensions that they replace. An</span>
<span class="sd">            ellipsis (`...`) will be replaced by all unlisted dimensions.</span>
<span class="sd">            Passing a list containing an ellipsis (`stacked_dim=[...]`) will stack over</span>
<span class="sd">            all dimensions.</span>
<span class="sd">        **dimensions_kwargs</span>
<span class="sd">            The keyword arguments form of ``dimensions``.</span>
<span class="sd">            One of dimensions or dimensions_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stacked : Dataset</span>
<span class="sd">            Dataset with stacked data.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.unstack</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">dimensions_kwargs</span><span class="p">,</span> <span class="s2">&quot;stack&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">new_dim</span><span class="p">,</span> <span class="n">dims</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_stack_once</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">new_dim</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">to_stacked_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
        <span class="n">sample_dims</span><span class="p">:</span> <span class="n">Collection</span><span class="p">,</span>
        <span class="n">variable_dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Combine variables of differing dimensionality into a DataArray</span>
<span class="sd">        without broadcasting.</span>

<span class="sd">        This method is similar to Dataset.to_array but does not broadcast the</span>
<span class="sd">        variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_dim : hashable</span>
<span class="sd">            Name of the new stacked coordinate</span>
<span class="sd">        sample_dims : Collection of hashables</span>
<span class="sd">            List of dimensions that **will not** be stacked. Each array in the</span>
<span class="sd">            dataset must share these dimensions. For machine learning</span>
<span class="sd">            applications, these define the dimensions over which samples are</span>
<span class="sd">            drawn.</span>
<span class="sd">        variable_dim : hashable, optional</span>
<span class="sd">            Name of the level in the stacked coordinate which corresponds to</span>
<span class="sd">            the variables.</span>
<span class="sd">        name : hashable, optional</span>
<span class="sd">            Name of the new data array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stacked : DataArray</span>
<span class="sd">            DataArray with the specified dimensions and data variables</span>
<span class="sd">            stacked together. The stacked coordinate is named ``new_dim``</span>
<span class="sd">            and represented by a MultiIndex object with a level containing the</span>
<span class="sd">            data variable names. The name of this level is controlled using</span>
<span class="sd">            the ``variable_dim`` argument.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.to_array</span>
<span class="sd">        Dataset.stack</span>
<span class="sd">        DataArray.to_unstacked_dataset</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; data = xr.Dataset(</span>
<span class="sd">        ...     data_vars={</span>
<span class="sd">        ...         &quot;a&quot;: ((&quot;x&quot;, &quot;y&quot;), [[0, 1, 2], [3, 4, 5]]),</span>
<span class="sd">        ...         &quot;b&quot;: (&quot;x&quot;, [6, 7]),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;y&quot;: [&quot;u&quot;, &quot;v&quot;, &quot;w&quot;]},</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; data</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 2, y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) &lt;U1 &#39;u&#39; &#39;v&#39; &#39;w&#39;</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x, y) int64 0 1 2 3 4 5</span>
<span class="sd">            b        (x) int64 6 7</span>

<span class="sd">        &gt;&gt;&gt; data.to_stacked_array(&quot;z&quot;, sample_dims=[&quot;x&quot;])</span>
<span class="sd">        &lt;xarray.DataArray &#39;a&#39; (x: 2, z: 4)&gt;</span>
<span class="sd">        array([[0, 1, 2, 6],</span>
<span class="sd">               [3, 4, 5, 7]])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * z         (z) MultiIndex</span>
<span class="sd">          - variable  (z) object &#39;a&#39; &#39;a&#39; &#39;a&#39; &#39;b&#39;</span>
<span class="sd">          - y         (z) object &#39;u&#39; &#39;v&#39; &#39;w&#39; nan</span>
<span class="sd">        Dimensions without coordinates: x</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stacking_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sample_dims</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span>
            <span class="n">dims_include_sample_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sample_dims</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dims_include_sample_dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;All variables in the dataset must contain the &quot;</span>
                    <span class="s2">&quot;dimensions </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">def</span> <span class="nf">ensure_stackable</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">assign_coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">variable_dim</span><span class="p">:</span> <span class="n">val</span><span class="o">.</span><span class="n">name</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">stacking_dims</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="n">assign_coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">expand_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">stacking_dims</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">dims</span><span class="p">))</span>
            <span class="n">expand_dims</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">variable_dim</span><span class="p">)</span>
            <span class="c1"># must be list for .expand_dims</span>
            <span class="n">expand_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">expand_dims</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span>
                <span class="n">val</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="o">**</span><span class="n">assign_coords</span><span class="p">)</span>
                <span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">expand_dims</span><span class="p">)</span>
                <span class="o">.</span><span class="n">stack</span><span class="p">({</span><span class="n">new_dim</span><span class="p">:</span> <span class="p">(</span><span class="n">variable_dim</span><span class="p">,)</span> <span class="o">+</span> <span class="n">stacking_dims</span><span class="p">})</span>
            <span class="p">)</span>

        <span class="c1"># concatenate the arrays</span>
        <span class="n">stackable_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">ensure_stackable</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">]</span>
        <span class="n">data_array</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">stackable_vars</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">new_dim</span><span class="p">)</span>

        <span class="c1"># coerce the levels of the MultiIndex to have the same type as the</span>
        <span class="c1"># input dimensions. This code is messy, so it might be better to just</span>
        <span class="c1"># input a dummy value for the singleton dimension.</span>
        <span class="c1"># TODO: benbovy - flexible indexes: update when MultIndex has its own</span>
        <span class="c1"># class inheriting from xarray.Index</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">data_array</span><span class="o">.</span><span class="n">xindexes</span><span class="p">[</span><span class="n">new_dim</span><span class="p">]</span><span class="o">.</span><span class="n">to_pandas_index</span><span class="p">()</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span>
            <span class="n">level</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">level</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="n">idx</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="p">]</span>
        <span class="n">new_idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">set_levels</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
        <span class="n">data_array</span><span class="p">[</span><span class="n">new_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">IndexVariable</span><span class="p">(</span><span class="n">new_dim</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_array</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">return</span> <span class="n">data_array</span>

    <span class="k">def</span> <span class="nf">_unstack_once</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">remove_unused_levels_categories</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
                        <span class="n">fill_value_</span> <span class="o">=</span> <span class="n">fill_value</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fill_value_</span> <span class="o">=</span> <span class="n">fill_value</span>

                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">_unstack_once</span><span class="p">(</span>
                        <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value_</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="n">sparse</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">lev</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">levels</span><span class="p">):</span>
            <span class="n">idx</span><span class="p">,</span> <span class="n">idx_vars</span> <span class="o">=</span> <span class="n">PandasIndex</span><span class="o">.</span><span class="n">from_pandas_index</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">indexes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>

        <span class="n">coord_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">)</span> <span class="o">-</span> <span class="p">{</span><span class="n">dim</span><span class="p">}</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_unstack_full_reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">remove_unused_levels_categories</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">full_idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">levels</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

        <span class="c1"># take a shortcut in case the MultiIndex was not modified.</span>
        <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">full_idx</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex</span><span class="p">(</span>
                <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="n">full_idx</span><span class="p">},</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="n">sparse</span>
            <span class="p">)</span>

        <span class="n">new_dim_names</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">names</span>
        <span class="n">new_dim_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">lev</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">lev</span> <span class="ow">in</span> <span class="n">index</span><span class="o">.</span><span class="n">levels</span><span class="p">]</span>

        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="n">new_dims</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">new_dim_names</span><span class="p">,</span> <span class="n">new_dim_sizes</span><span class="p">))</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">unstack</span><span class="p">({</span><span class="n">dim</span><span class="p">:</span> <span class="n">new_dims</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">lev</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_dim_names</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">levels</span><span class="p">):</span>
            <span class="n">idx</span><span class="p">,</span> <span class="n">idx_vars</span> <span class="o">=</span> <span class="n">PandasIndex</span><span class="o">.</span><span class="n">from_pandas_index</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">indexes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>

        <span class="n">coord_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">)</span> <span class="o">-</span> <span class="p">{</span><span class="n">dim</span><span class="p">}</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_dim_names</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">unstack</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
        <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unstack existing dimensions corresponding to MultiIndexes into</span>
<span class="sd">        multiple new dimensions.</span>

<span class="sd">        New dimensions will be added at the end.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : hashable or iterable of hashable, optional</span>
<span class="sd">            Dimension(s) over which to unstack. By default unstacks all</span>
<span class="sd">            MultiIndexes.</span>
<span class="sd">        fill_value : scalar or dict-like, default: nan</span>
<span class="sd">            value to be filled. If a dict-like, maps variable names to</span>
<span class="sd">            fill values. If not provided or if the dict-like does not</span>
<span class="sd">            contain all variables, the dtype&#39;s NA value will be used.</span>
<span class="sd">        sparse : bool, default: False</span>
<span class="sd">            use sparse-array if True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unstacked : Dataset</span>
<span class="sd">            Dataset with unstacked data.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.stack</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

            <span class="n">missing_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">missing_dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Dataset does not contain the dimensions: </span><span class="si">{</span><span class="n">missing_dims</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="n">non_multi_dims</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">non_multi_dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;cannot unstack dimensions that do not &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;have a MultiIndex: </span><span class="si">{</span><span class="n">non_multi_dims</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># we want to avoid allocating an object-dtype ndarray for a MultiIndex,</span>
        <span class="c1"># so we can&#39;t just access self.variables[v].data for every variable.</span>
        <span class="c1"># We only check the non-index variables.</span>
        <span class="c1"># https://github.com/pydata/xarray/issues/5902</span>
        <span class="n">nonindexes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="c1"># Notes for each of these cases:</span>
        <span class="c1"># 1. Dask arrays don&#39;t support assignment by index, which the fast unstack</span>
        <span class="c1">#    function requires.</span>
        <span class="c1">#    https://github.com/pydata/xarray/pull/4746#issuecomment-753282125</span>
        <span class="c1"># 2. Sparse doesn&#39;t currently support (though we could special-case it)</span>
        <span class="c1">#    https://github.com/pydata/sparse/issues/422</span>
        <span class="c1"># 3. pint requires checking if it&#39;s a NumPy array until</span>
        <span class="c1">#    https://github.com/pydata/xarray/pull/4751 is resolved,</span>
        <span class="c1">#    Once that is resolved, explicitly exclude pint arrays.</span>
        <span class="c1">#    pint doesn&#39;t implement `np.full_like` in a way that&#39;s</span>
        <span class="c1">#    currently compatible.</span>
        <span class="n">needs_full_reindex</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
            <span class="n">is_duck_dask_array</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sparse_array_type</span><span class="p">)</span>
            <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nonindexes</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">needs_full_reindex</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_unstack_full_reindex</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">sparse</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_unstack_once</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">sparse</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">CoercibleMapping</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update this dataset&#39;s variables with those from another dataset.</span>

<span class="sd">        Just like :py:meth:`dict.update` this is a in-place operation.</span>
<span class="sd">        For a non-inplace version, see :py:meth:`Dataset.merge`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Dataset or mapping</span>
<span class="sd">            Variables with which to update this dataset. One of:</span>

<span class="sd">            - Dataset</span>
<span class="sd">            - mapping {var name: DataArray}</span>
<span class="sd">            - mapping {var name: Variable}</span>
<span class="sd">            - mapping {var name: (dimension name, array-like)}</span>
<span class="sd">            - mapping {var name: (tuple of dimension names, array-like)}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        updated : Dataset</span>
<span class="sd">            Updated dataset. Note that since the update is in-place this is the input</span>
<span class="sd">            dataset.</span>

<span class="sd">            It is deprecated since version 0.17 and scheduled to be removed in 0.21.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any dimensions would have inconsistent sizes in the updated</span>
<span class="sd">            dataset.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.assign</span>
<span class="sd">        Dataset.merge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">merge_result</span> <span class="o">=</span> <span class="n">dataset_update_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">merge_result</span><span class="o">.</span><span class="n">_asdict</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">CoercibleMapping</span> <span class="o">|</span> <span class="n">DataArray</span><span class="p">,</span>
        <span class="n">overwrite_vars</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(),</span>
        <span class="n">compat</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;no_conflicts&quot;</span><span class="p">,</span>
        <span class="n">join</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;outer&quot;</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
        <span class="n">combine_attrs</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;override&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Merge the arrays of two datasets into a single dataset.</span>

<span class="sd">        This method generally does not allow for overriding data, with the</span>
<span class="sd">        exception of attributes, which are ignored on the second dataset.</span>
<span class="sd">        Variables with the same name are checked for conflicts via the equals</span>
<span class="sd">        or identical methods.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Dataset or mapping</span>
<span class="sd">            Dataset or variables to merge with this dataset.</span>
<span class="sd">        overwrite_vars : hashable or iterable of hashable, optional</span>
<span class="sd">            If provided, update variables of these name(s) without checking for</span>
<span class="sd">            conflicts in this dataset.</span>
<span class="sd">        compat : {&quot;broadcast_equals&quot;, &quot;equals&quot;, &quot;identical&quot;, \</span>
<span class="sd">                  &quot;no_conflicts&quot;}, optional</span>
<span class="sd">            String indicating how to compare variables of the same name for</span>
<span class="sd">            potential conflicts:</span>

<span class="sd">            - &#39;broadcast_equals&#39;: all values must be equal when variables are</span>
<span class="sd">              broadcast against each other to ensure common dimensions.</span>
<span class="sd">            - &#39;equals&#39;: all values and dimensions must be the same.</span>
<span class="sd">            - &#39;identical&#39;: all values, dimensions and attributes must be the</span>
<span class="sd">              same.</span>
<span class="sd">            - &#39;no_conflicts&#39;: only values which are not null in both datasets</span>
<span class="sd">              must be equal. The returned dataset then contains the combination</span>
<span class="sd">              of all non-null values.</span>
<span class="sd">        join : {&quot;outer&quot;, &quot;inner&quot;, &quot;left&quot;, &quot;right&quot;, &quot;exact&quot;}, optional</span>
<span class="sd">            Method for joining ``self`` and ``other`` along shared dimensions:</span>

<span class="sd">            - &#39;outer&#39;: use the union of the indexes</span>
<span class="sd">            - &#39;inner&#39;: use the intersection of the indexes</span>
<span class="sd">            - &#39;left&#39;: use indexes from ``self``</span>
<span class="sd">            - &#39;right&#39;: use indexes from ``other``</span>
<span class="sd">            - &#39;exact&#39;: error instead of aligning non-equal indexes</span>
<span class="sd">        fill_value : scalar or dict-like, optional</span>
<span class="sd">            Value to use for newly missing values. If a dict-like, maps</span>
<span class="sd">            variable names (including coordinates) to fill values.</span>
<span class="sd">        combine_attrs : {&quot;drop&quot;, &quot;identical&quot;, &quot;no_conflicts&quot;, &quot;drop_conflicts&quot;, \</span>
<span class="sd">                        &quot;override&quot;}, default: &quot;override&quot;</span>
<span class="sd">            String indicating how to combine attrs of the objects being merged:</span>

<span class="sd">            - &quot;drop&quot;: empty attrs on returned Dataset.</span>
<span class="sd">            - &quot;identical&quot;: all attrs must be the same on every object.</span>
<span class="sd">            - &quot;no_conflicts&quot;: attrs from all objects are combined, any that have</span>
<span class="sd">              the same name must also have the same value.</span>
<span class="sd">            - &quot;drop_conflicts&quot;: attrs from all objects are combined, any that have</span>
<span class="sd">              the same name but different values are dropped.</span>
<span class="sd">            - &quot;override&quot;: skip comparing and copy attrs from the first dataset to</span>
<span class="sd">              the result.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        merged : Dataset</span>
<span class="sd">            Merged dataset.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        MergeError</span>
<span class="sd">            If any variables conflict (see ``compat``).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.update</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)</span> <span class="k">else</span> <span class="n">other</span>
        <span class="n">merge_result</span> <span class="o">=</span> <span class="n">dataset_merge_method</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">overwrite_vars</span><span class="o">=</span><span class="n">overwrite_vars</span><span class="p">,</span>
            <span class="n">compat</span><span class="o">=</span><span class="n">compat</span><span class="p">,</span>
            <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="n">combine_attrs</span><span class="o">=</span><span class="n">combine_attrs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="o">**</span><span class="n">merge_result</span><span class="o">.</span><span class="n">_asdict</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_assert_all_in_dataset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span> <span class="n">virtual_okay</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bad_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">virtual_okay</span><span class="p">:</span>
            <span class="n">bad_names</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_variables</span>
        <span class="k">if</span> <span class="n">bad_names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;One or more of the specified variables &quot;</span>
                <span class="s2">&quot;cannot be found in this dataset&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">drop_vars</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span> <span class="o">*</span><span class="p">,</span> <span class="n">errors</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Drop variables from this dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : hashable or iterable of hashable</span>
<span class="sd">            Name(s) of variables to drop.</span>
<span class="sd">        errors : {&quot;raise&quot;, &quot;ignore&quot;}, optional</span>
<span class="sd">            If &#39;raise&#39; (default), raises a ValueError error if any of the variable</span>
<span class="sd">            passed are not in the dataset. If &#39;ignore&#39;, any given names that are in the</span>
<span class="sd">            dataset are dropped and no error is raised.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dropped : Dataset</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># the Iterable check is required for mypy</span>
        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">{</span><span class="n">names</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_assert_all_in_dataset</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">}</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">}</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">labels_kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Backward compatible method based on `drop_vars` and `drop_sel`</span>

<span class="sd">        Using either `drop_vars` or `drop_sel` is encouraged</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.drop_vars</span>
<span class="sd">        Dataset.drop_sel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">errors</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="s2">&quot;ignore&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;errors must be either &quot;raise&quot; or &quot;ignore&quot;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;dropping coordinates using `drop` is be deprecated; use drop_vars.&quot;</span><span class="p">,</span>
                <span class="ne">FutureWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">labels_kwargs</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot specify dim and dict-like arguments.&quot;</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">labels_kwargs</span><span class="p">,</span> <span class="s2">&quot;drop&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;dropping variables using `drop` will be deprecated; using drop_vars is encouraged.&quot;</span><span class="p">,</span>
                <span class="ne">PendingDeprecationWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;dropping labels using list-like labels is deprecated; using &quot;</span>
                <span class="s2">&quot;dict-like arguments with `drop_sel`, e.g. `ds.drop_sel(dim=[labels]).&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_sel</span><span class="p">({</span><span class="n">dim</span><span class="p">:</span> <span class="n">labels</span><span class="p">},</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span> <span class="o">**</span><span class="n">labels_kwargs</span><span class="p">)</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;dropping labels using `drop` will be deprecated; using drop_sel is encouraged.&quot;</span><span class="p">,</span>
            <span class="ne">PendingDeprecationWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_sel</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">drop_sel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">labels_kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Drop index labels from this dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : mapping of hashable to Any</span>
<span class="sd">            Index labels to drop</span>
<span class="sd">        errors : {&quot;raise&quot;, &quot;ignore&quot;}, optional</span>
<span class="sd">            If &#39;raise&#39; (default), raises a ValueError error if</span>
<span class="sd">            any of the index labels passed are not</span>
<span class="sd">            in the dataset. If &#39;ignore&#39;, any given labels that are in the</span>
<span class="sd">            dataset are dropped and no error is raised.</span>
<span class="sd">        **labels_kwargs : {dim: label, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``dim`` and ``labels``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dropped : Dataset</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; data = np.arange(6).reshape(2, 3)</span>
<span class="sd">        &gt;&gt;&gt; labels = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;A&quot;: ([&quot;x&quot;, &quot;y&quot;], data), &quot;y&quot;: labels})</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 2, y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) &lt;U1 &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x, y) int64 0 1 2 3 4 5</span>
<span class="sd">        &gt;&gt;&gt; ds.drop_sel(y=[&quot;a&quot;, &quot;c&quot;])</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 2, y: 1)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) &lt;U1 &#39;b&#39;</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x, y) int64 1 4</span>
<span class="sd">        &gt;&gt;&gt; ds.drop_sel(y=&quot;b&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 2, y: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) &lt;U1 &#39;a&#39; &#39;c&#39;</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x, y) int64 0 2 3 5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">errors</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="s2">&quot;ignore&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;errors must be either &quot;raise&quot; or &quot;ignore&quot;&#39;</span><span class="p">)</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">labels_kwargs</span><span class="p">,</span> <span class="s2">&quot;drop_sel&quot;</span><span class="p">)</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">labels_for_dim</span> <span class="ow">in</span> <span class="n">labels</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Don&#39;t cast to set, as it would harm performance when labels</span>
            <span class="c1"># is a large numpy array</span>
            <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">labels_for_dim</span><span class="p">):</span>
                <span class="n">labels_for_dim</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels_for_dim</span><span class="p">]</span>
            <span class="n">labels_for_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">labels_for_dim</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dimension </span><span class="si">{</span><span class="n">dim</span><span class="si">!r}</span><span class="s2"> does not have coordinate labels&quot;</span><span class="p">)</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels_for_dim</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">loc</span><span class="p">[{</span><span class="n">dim</span><span class="p">:</span> <span class="n">new_index</span><span class="p">}]</span>
        <span class="k">return</span> <span class="n">ds</span>

    <span class="k">def</span> <span class="nf">drop_isel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Drop index positions from this Dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexers : mapping of hashable to Any</span>
<span class="sd">            Index locations to drop</span>
<span class="sd">        **indexers_kwargs : {dim: position, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``dim`` and ``positions``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dropped : Dataset</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        IndexError</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; data = np.arange(6).reshape(2, 3)</span>
<span class="sd">        &gt;&gt;&gt; labels = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;A&quot;: ([&quot;x&quot;, &quot;y&quot;], data), &quot;y&quot;: labels})</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 2, y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) &lt;U1 &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x, y) int64 0 1 2 3 4 5</span>
<span class="sd">        &gt;&gt;&gt; ds.drop_isel(y=[0, 2])</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 2, y: 1)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) &lt;U1 &#39;b&#39;</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x, y) int64 1 4</span>
<span class="sd">        &gt;&gt;&gt; ds.drop_isel(y=1)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 2, y: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) &lt;U1 &#39;a&#39; &#39;c&#39;</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x, y) int64 0 2 3 5</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">indexers</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">indexers_kwargs</span><span class="p">,</span> <span class="s2">&quot;drop_isel&quot;</span><span class="p">)</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">dimension_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">pos_for_dim</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Don&#39;t cast to set, as it would harm performance when labels</span>
            <span class="c1"># is a large numpy array</span>
            <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">pos_for_dim</span><span class="p">):</span>
                <span class="n">pos_for_dim</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos_for_dim</span><span class="p">]</span>
            <span class="n">pos_for_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pos_for_dim</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">pos_for_dim</span><span class="p">)</span>
            <span class="n">dimension_index</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_index</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dimension_index</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ds</span>

    <span class="k">def</span> <span class="nf">drop_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">drop_dims</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span> <span class="o">*</span><span class="p">,</span> <span class="n">errors</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Drop dimensions and associated variables from this dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        drop_dims : hashable or iterable of hashable</span>
<span class="sd">            Dimension or dimensions to drop.</span>
<span class="sd">        errors : {&quot;raise&quot;, &quot;ignore&quot;}, default: &quot;raise&quot;</span>
<span class="sd">            If &#39;raise&#39;, raises a ValueError error if any of the</span>
<span class="sd">            dimensions passed are not in the dataset. If &#39;ignore&#39;, any given</span>
<span class="sd">            dimensions that are in the dataset are dropped and no error is raised.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : Dataset</span>
<span class="sd">            The dataset without the given dimensions (or any variables</span>
<span class="sd">            containing those dimensions).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">errors</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="s2">&quot;ignore&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;errors must be either &quot;raise&quot; or &quot;ignore&quot;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">drop_dims</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">drop_dims</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">drop_dims</span> <span class="o">=</span> <span class="p">{</span><span class="n">drop_dims</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">drop_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">drop_dims</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
            <span class="n">missing_dims</span> <span class="o">=</span> <span class="n">drop_dims</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">missing_dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Dataset does not contain the dimensions: </span><span class="si">{</span><span class="n">missing_dims</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="n">drop_vars</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">drop_dims</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">drop_vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">dims</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
        <span class="n">missing_dims</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new Dataset object with all array dimensions transposed.</span>

<span class="sd">        Although the order of dimensions on each array will change, the dataset</span>
<span class="sd">        dimensions themselves will remain in fixed (sorted) order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *dims : hashable, optional</span>
<span class="sd">            By default, reverse the dimensions on each array. Otherwise,</span>
<span class="sd">            reorder the dimensions to this order.</span>
<span class="sd">        missing_dims : {&quot;raise&quot;, &quot;warn&quot;, &quot;ignore&quot;}, default: &quot;raise&quot;</span>
<span class="sd">            What to do if dimensions that should be selected from are not present in the</span>
<span class="sd">            Dataset:</span>
<span class="sd">            - &quot;raise&quot;: raise an exception</span>
<span class="sd">            - &quot;warn&quot;: raise a warning, and ignore the missing dimensions</span>
<span class="sd">            - &quot;ignore&quot;: ignore the missing dimensions</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        transposed : Dataset</span>
<span class="sd">            Each array in the dataset (including) coordinates will be</span>
<span class="sd">            transposed to the given order.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This operation returns a view of each array&#39;s data. It is</span>
<span class="sd">        lazy for dask-backed DataArrays but not for numpy-backed DataArrays</span>
<span class="sd">        -- the data will be fully loaded into memory.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.transpose</span>
<span class="sd">        DataArray.transpose</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use infix_dims to check once for missing dimensions</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">infix_dims</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">missing_dims</span><span class="p">))</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">var_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="o">+</span> <span class="p">(</span><span class="o">...</span><span class="p">,)))</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">var_dims</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ds</span>

    <span class="k">def</span> <span class="nf">dropna</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
        <span class="n">how</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;any&quot;</span><span class="p">,</span>
        <span class="n">thresh</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">subset</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a new dataset with dropped labels for missing values along</span>
<span class="sd">        the provided dimension.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : hashable</span>
<span class="sd">            Dimension along which to drop missing values. Dropping along</span>
<span class="sd">            multiple dimensions simultaneously is not yet supported.</span>
<span class="sd">        how : {&quot;any&quot;, &quot;all&quot;}, default: &quot;any&quot;</span>
<span class="sd">            * any : if any NA values are present, drop that label</span>
<span class="sd">            * all : if all values are NA, drop that label</span>
<span class="sd">        thresh : int, default: None</span>
<span class="sd">            If supplied, require this many non-NA values.</span>
<span class="sd">        subset : iterable of hashable, optional</span>
<span class="sd">            Which variables to check for missing values. By default, all</span>
<span class="sd">            variables in the dataset are checked.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: consider supporting multiple dimensions? Or not, given that</span>
        <span class="c1"># there are some ugly edge cases, e.g., pandas&#39;s dropna differs</span>
        <span class="c1"># depending on the order of the supplied axes.</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> must be a single dataset dimension&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>

        <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># for type checking</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">subset</span><span class="p">:</span>
            <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">array</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">array</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">d</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">]</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>  <span class="c1"># type: ignore[attr-defined]</span>
                <span class="n">size</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">thresh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">thresh</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;any&quot;</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">count</span> <span class="o">==</span> <span class="n">size</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid how option: </span><span class="si">{</span><span class="n">how</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;must specify how or thresh&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="n">dim</span><span class="p">:</span> <span class="n">mask</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Fill missing values in this object.</span>

<span class="sd">        This operation follows the normal broadcasting and alignment rules that</span>
<span class="sd">        xarray uses for binary arithmetic, except the result is aligned to this</span>
<span class="sd">        object (``join=&#39;left&#39;``) instead of aligned to the intersection of</span>
<span class="sd">        index coordinates (``join=&#39;inner&#39;``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : scalar, ndarray, DataArray, dict or Dataset</span>
<span class="sd">            Used to fill all matching missing values in this dataset&#39;s data</span>
<span class="sd">            variables. Scalars, ndarrays or DataArrays arguments are used to</span>
<span class="sd">            fill all data with aligned coordinates (for DataArrays).</span>
<span class="sd">            Dictionaries or datasets match data variables and then align</span>
<span class="sd">            coordinates if necessary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;A&quot;: (&quot;x&quot;, [np.nan, 2, np.nan, 0]),</span>
<span class="sd">        ...         &quot;B&quot;: (&quot;x&quot;, [3, 4, np.nan, 1]),</span>
<span class="sd">        ...         &quot;C&quot;: (&quot;x&quot;, [np.nan, np.nan, np.nan, 5]),</span>
<span class="sd">        ...         &quot;D&quot;: (&quot;x&quot;, [np.nan, 3, np.nan, 4]),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;x&quot;: [0, 1, 2, 3]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 0 1 2 3</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x) float64 nan 2.0 nan 0.0</span>
<span class="sd">            B        (x) float64 3.0 4.0 nan 1.0</span>
<span class="sd">            C        (x) float64 nan nan nan 5.0</span>
<span class="sd">            D        (x) float64 nan 3.0 nan 4.0</span>

<span class="sd">        Replace all `NaN` values with 0s.</span>

<span class="sd">        &gt;&gt;&gt; ds.fillna(0)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 0 1 2 3</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x) float64 0.0 2.0 0.0 0.0</span>
<span class="sd">            B        (x) float64 3.0 4.0 0.0 1.0</span>
<span class="sd">            C        (x) float64 0.0 0.0 0.0 5.0</span>
<span class="sd">            D        (x) float64 0.0 3.0 0.0 4.0</span>

<span class="sd">        Replace all `NaN` elements in column ‘A’, ‘B’, ‘C’, and ‘D’, with 0, 1, 2, and 3 respectively.</span>

<span class="sd">        &gt;&gt;&gt; values = {&quot;A&quot;: 0, &quot;B&quot;: 1, &quot;C&quot;: 2, &quot;D&quot;: 3}</span>
<span class="sd">        &gt;&gt;&gt; ds.fillna(value=values)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 0 1 2 3</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x) float64 0.0 2.0 0.0 0.0</span>
<span class="sd">            B        (x) float64 3.0 4.0 1.0 1.0</span>
<span class="sd">            C        (x) float64 2.0 2.0 2.0 5.0</span>
<span class="sd">            D        (x) float64 3.0 3.0 3.0 4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="n">value_keys</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;data_vars&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">value_keys</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;all variables in the argument to `fillna` &quot;</span>
                    <span class="s2">&quot;must be contained in the original dataset&quot;</span>
                <span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">interpolate_na</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_coordinate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">max_gap</span><span class="p">:</span> <span class="p">(</span>
            <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span> <span class="o">|</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span>
        <span class="p">)</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Fill in NaNs by interpolating according to different methods.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : str</span>
<span class="sd">            Specifies the dimension along which to interpolate.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            String indicating which method to use for interpolation:</span>

<span class="sd">            - &#39;linear&#39;: linear interpolation (Default). Additional keyword</span>
<span class="sd">              arguments are passed to :py:func:`numpy.interp`</span>
<span class="sd">            - &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;polynomial&#39;:</span>
<span class="sd">              are passed to :py:func:`scipy.interpolate.interp1d`. If</span>
<span class="sd">              ``method=&#39;polynomial&#39;``, the ``order`` keyword argument must also be</span>
<span class="sd">              provided.</span>
<span class="sd">            - &#39;barycentric&#39;, &#39;krog&#39;, &#39;pchip&#39;, &#39;spline&#39;, &#39;akima&#39;: use their</span>
<span class="sd">              respective :py:class:`scipy.interpolate` classes.</span>
<span class="sd">        use_coordinate : bool, str, default: True</span>
<span class="sd">            Specifies which index to use as the x values in the interpolation</span>
<span class="sd">            formulated as `y = f(x)`. If False, values are treated as if</span>
<span class="sd">            eqaully-spaced along ``dim``. If True, the IndexVariable `dim` is</span>
<span class="sd">            used. If ``use_coordinate`` is a string, it specifies the name of a</span>
<span class="sd">            coordinate variariable to use as the index.</span>
<span class="sd">        limit : int, default: None</span>
<span class="sd">            Maximum number of consecutive NaNs to fill. Must be greater than 0</span>
<span class="sd">            or None for no limit. This filling is done regardless of the size of</span>
<span class="sd">            the gap in the data. To only interpolate over gaps less than a given length,</span>
<span class="sd">            see ``max_gap``.</span>
<span class="sd">        max_gap : int, float, str, pandas.Timedelta, numpy.timedelta64, datetime.timedelta, default: None</span>
<span class="sd">            Maximum size of gap, a continuous sequence of NaNs, that will be filled.</span>
<span class="sd">            Use None for no limit. When interpolating along a datetime64 dimension</span>
<span class="sd">            and ``use_coordinate=True``, ``max_gap`` can be one of the following:</span>

<span class="sd">            - a string that is valid input for pandas.to_timedelta</span>
<span class="sd">            - a :py:class:`numpy.timedelta64` object</span>
<span class="sd">            - a :py:class:`pandas.Timedelta` object</span>
<span class="sd">            - a :py:class:`datetime.timedelta` object</span>

<span class="sd">            Otherwise, ``max_gap`` must be an int or a float. Use of ``max_gap`` with unlabeled</span>
<span class="sd">            dimensions has not been implemented yet. Gap length is defined as the difference</span>
<span class="sd">            between coordinate values at the first data point after a gap and the last value</span>
<span class="sd">            before a gap. For gaps at the beginning (end), gap length is defined as the difference</span>
<span class="sd">            between coordinate values at the first (last) valid data point and the first (last) NaN.</span>
<span class="sd">            For example, consider::</span>

<span class="sd">                &lt;xarray.DataArray (x: 9)&gt;</span>
<span class="sd">                array([nan, nan, nan,  1., nan, nan,  4., nan, nan])</span>
<span class="sd">                Coordinates:</span>
<span class="sd">                  * x        (x) int64 0 1 2 3 4 5 6 7 8</span>

<span class="sd">            The gap lengths are 3-0 = 3; 6-3 = 3; and 8-6 = 2 respectively</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            parameters passed verbatim to the underlying interpolation function</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        interpolated: Dataset</span>
<span class="sd">            Filled in Dataset.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.interp</span>
<span class="sd">        scipy.interpolate</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;A&quot;: (&quot;x&quot;, [np.nan, 2, 3, np.nan, 0]),</span>
<span class="sd">        ...         &quot;B&quot;: (&quot;x&quot;, [3, 4, np.nan, 1, 7]),</span>
<span class="sd">        ...         &quot;C&quot;: (&quot;x&quot;, [np.nan, np.nan, np.nan, 5, 0]),</span>
<span class="sd">        ...         &quot;D&quot;: (&quot;x&quot;, [np.nan, 3, np.nan, -1, 4]),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;x&quot;: [0, 1, 2, 3, 4]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 5)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 0 1 2 3 4</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x) float64 nan 2.0 3.0 nan 0.0</span>
<span class="sd">            B        (x) float64 3.0 4.0 nan 1.0 7.0</span>
<span class="sd">            C        (x) float64 nan nan nan 5.0 0.0</span>
<span class="sd">            D        (x) float64 nan 3.0 nan -1.0 4.0</span>

<span class="sd">        &gt;&gt;&gt; ds.interpolate_na(dim=&quot;x&quot;, method=&quot;linear&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 5)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 0 1 2 3 4</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x) float64 nan 2.0 3.0 1.5 0.0</span>
<span class="sd">            B        (x) float64 3.0 4.0 2.5 1.0 7.0</span>
<span class="sd">            C        (x) float64 nan nan nan 5.0 0.0</span>
<span class="sd">            D        (x) float64 nan 3.0 1.0 -1.0 4.0</span>

<span class="sd">        &gt;&gt;&gt; ds.interpolate_na(dim=&quot;x&quot;, method=&quot;linear&quot;, fill_value=&quot;extrapolate&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 5)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 0 1 2 3 4</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x) float64 1.0 2.0 3.0 1.5 0.0</span>
<span class="sd">            B        (x) float64 3.0 4.0 2.5 1.0 7.0</span>
<span class="sd">            C        (x) float64 20.0 15.0 10.0 5.0 0.0</span>
<span class="sd">            D        (x) float64 5.0 3.0 1.0 -1.0 4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.missing</span> <span class="kn">import</span> <span class="n">_apply_over_vars_with_dim</span><span class="p">,</span> <span class="n">interp_na</span>

        <span class="n">new</span> <span class="o">=</span> <span class="n">_apply_over_vars_with_dim</span><span class="p">(</span>
            <span class="n">interp_na</span><span class="p">,</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
            <span class="n">use_coordinate</span><span class="o">=</span><span class="n">use_coordinate</span><span class="p">,</span>
            <span class="n">max_gap</span><span class="o">=</span><span class="n">max_gap</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">ffill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Fill NaN values by propagating values forward</span>

<span class="sd">        *Requires bottleneck.*</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : Hashable</span>
<span class="sd">            Specifies the dimension along which to propagate values when</span>
<span class="sd">            filling.</span>
<span class="sd">        limit : int, default: None</span>
<span class="sd">            The maximum number of consecutive NaN values to forward fill. In</span>
<span class="sd">            other words, if there is a gap with more than this number of</span>
<span class="sd">            consecutive NaNs, it will only be partially filled. Must be greater</span>
<span class="sd">            than 0 or None for no limit. Must be None or greater than or equal</span>
<span class="sd">            to axis length if filling along chunked axes (dimensions).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.missing</span> <span class="kn">import</span> <span class="n">_apply_over_vars_with_dim</span><span class="p">,</span> <span class="n">ffill</span>

        <span class="n">new</span> <span class="o">=</span> <span class="n">_apply_over_vars_with_dim</span><span class="p">(</span><span class="n">ffill</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">bfill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Fill NaN values by propagating values backward</span>

<span class="sd">        *Requires bottleneck.*</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : str</span>
<span class="sd">            Specifies the dimension along which to propagate values when</span>
<span class="sd">            filling.</span>
<span class="sd">        limit : int, default: None</span>
<span class="sd">            The maximum number of consecutive NaN values to backward fill. In</span>
<span class="sd">            other words, if there is a gap with more than this number of</span>
<span class="sd">            consecutive NaNs, it will only be partially filled. Must be greater</span>
<span class="sd">            than 0 or None for no limit. Must be None or greater than or equal</span>
<span class="sd">            to axis length if filling along chunked axes (dimensions).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.missing</span> <span class="kn">import</span> <span class="n">_apply_over_vars_with_dim</span><span class="p">,</span> <span class="n">bfill</span>

        <span class="n">new</span> <span class="o">=</span> <span class="n">_apply_over_vars_with_dim</span><span class="p">(</span><span class="n">bfill</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">combine_first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Combine two Datasets, default to data_vars of self.</span>

<span class="sd">        The new coordinates follow the normal broadcasting and alignment rules</span>
<span class="sd">        of ``join=&#39;outer&#39;``.  Vacant cells in the expanded coordinates are</span>
<span class="sd">        filled with np.nan.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Dataset</span>
<span class="sd">            Used to fill all matching missing values in this array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span> <span class="n">dataset_join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">keep_attrs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Reduce this dataset by applying `func` along some dimension(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">            Function which can be called in the form</span>
<span class="sd">            `f(x, axis=axis, **kwargs)` to return the result of reducing an</span>
<span class="sd">            np.ndarray over an integer valued axis.</span>
<span class="sd">        dim : str or sequence of str, optional</span>
<span class="sd">            Dimension(s) over which to apply `func`.  By default `func` is</span>
<span class="sd">            applied over all dimensions.</span>
<span class="sd">        keep_attrs : bool, optional</span>
<span class="sd">            If True, the dataset&#39;s attributes (`attrs`) will be copied from</span>
<span class="sd">            the original object to the new one.  If False (default), the new</span>
<span class="sd">            object will be returned without attributes.</span>
<span class="sd">        keepdims : bool, default: False</span>
<span class="sd">            If True, the dimensions which are reduced are left in the result</span>
<span class="sd">            as dimensions of size one. Coordinates that use these dimensions</span>
<span class="sd">            are removed.</span>
<span class="sd">        numeric_only : bool, optional</span>
<span class="sd">            If True, only apply ``func`` to variables with a numeric dtype.</span>
<span class="sd">        **kwargs : Any</span>
<span class="sd">            Additional keyword arguments passed on to ``func``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reduced : Dataset</span>
<span class="sd">            Dataset with this object&#39;s DataArrays replaced with new DataArrays</span>
<span class="sd">            of summarized data and the indicated dimension(s) removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;axis&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;passing &#39;axis&#39; to Dataset reduce methods is ambiguous.&quot;</span>
                <span class="s2">&quot; Please use &#39;dim&#39; instead.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dim</span> <span class="ow">is</span> <span class="o">...</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

        <span class="n">missing_dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">missing_dimensions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Dataset does not contain the dimensions: </span><span class="si">{</span><span class="n">missing_dimensions</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">keep_attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keep_attrs</span> <span class="o">=</span> <span class="n">_get_keep_attrs</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">reduce_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">reduce_dims</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="c1"># Some reduction functions (e.g. std, var) need to run on variables</span>
                    <span class="c1"># that don&#39;t have the reduce dims: PR5393</span>
                    <span class="ow">not</span> <span class="n">reduce_dims</span>
                    <span class="ow">or</span> <span class="ow">not</span> <span class="n">numeric_only</span>
                    <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reduce_dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># unpack dimensions for the benefit of functions</span>
                        <span class="c1"># like np.argmin which can&#39;t handle tuple arguments</span>
                        <span class="p">(</span><span class="n">reduce_dims</span><span class="p">,)</span> <span class="o">=</span> <span class="n">reduce_dims</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">reduce_dims</span><span class="p">)</span> <span class="o">==</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                        <span class="c1"># prefer to aggregate over axis=None rather than</span>
                        <span class="c1"># axis=(0, 1) if they will be equivalent, because</span>
                        <span class="c1"># the former is often more efficient</span>
                        <span class="n">reduce_dims</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore[assignment]</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
                        <span class="n">func</span><span class="p">,</span>
                        <span class="n">dim</span><span class="o">=</span><span class="n">reduce_dims</span><span class="p">,</span>
                        <span class="n">keep_attrs</span><span class="o">=</span><span class="n">keep_attrs</span><span class="p">,</span>
                        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="n">coord_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">}</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">}</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span> <span class="k">if</span> <span class="n">keep_attrs</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">keep_attrs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">args</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Apply a function to each variable in this dataset</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">            Function which can be called in the form `func(x, *args, **kwargs)`</span>
<span class="sd">            to transform each DataArray `x` in this dataset into another</span>
<span class="sd">            DataArray.</span>
<span class="sd">        keep_attrs : bool, optional</span>
<span class="sd">            If True, both the dataset&#39;s and variables&#39; attributes (`attrs`) will be</span>
<span class="sd">            copied from the original objects to the new ones. If False, the new dataset</span>
<span class="sd">            and variables will be returned without copying the attributes.</span>
<span class="sd">        args : tuple, optional</span>
<span class="sd">            Positional arguments passed on to `func`.</span>
<span class="sd">        **kwargs : Any</span>
<span class="sd">            Keyword arguments passed on to `func`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        applied : Dataset</span>
<span class="sd">            Resulting dataset from applying ``func`` to each data variable.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; da = xr.DataArray(np.random.randn(2, 3))</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;foo&quot;: da, &quot;bar&quot;: (&quot;x&quot;, [-1, 2])})</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (dim_0: 2, dim_1: 3, x: 2)</span>
<span class="sd">        Dimensions without coordinates: dim_0, dim_1, x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (dim_0, dim_1) float64 1.764 0.4002 0.9787 2.241 1.868 -0.9773</span>
<span class="sd">            bar      (x) int64 -1 2</span>
<span class="sd">        &gt;&gt;&gt; ds.map(np.fabs)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (dim_0: 2, dim_1: 3, x: 2)</span>
<span class="sd">        Dimensions without coordinates: dim_0, dim_1, x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (dim_0, dim_1) float64 1.764 0.4002 0.9787 2.241 1.868 0.9773</span>
<span class="sd">            bar      (x) float64 1.0 2.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">keep_attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keep_attrs</span> <span class="o">=</span> <span class="n">_get_keep_attrs</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">maybe_wrap_array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">keep_attrs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">v</span><span class="o">.</span><span class="n">_copy_attrs_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span> <span class="k">if</span> <span class="n">keep_attrs</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">variables</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">keep_attrs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">args</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Backward compatible implementation of ``map``</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.map</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Dataset.apply may be deprecated in the future. Using Dataset.map is encouraged&quot;</span><span class="p">,</span>
            <span class="ne">PendingDeprecationWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">keep_attrs</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">assign</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">variables_kwargs</span><span class="p">:</span> <span class="n">Hashable</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Assign new data variables to a Dataset, returning a new object</span>
<span class="sd">        with all the original variables in addition to the new ones.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variables : mapping of hashable to Any</span>
<span class="sd">            Mapping from variables names to the new values. If the new values</span>
<span class="sd">            are callable, they are computed on the Dataset and assigned to new</span>
<span class="sd">            data variables. If the values are not callable, (e.g. a DataArray,</span>
<span class="sd">            scalar, or array), they are simply assigned.</span>
<span class="sd">        **variables_kwargs</span>
<span class="sd">            The keyword arguments form of ``variables``.</span>
<span class="sd">            One of variables or variables_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ds : Dataset</span>
<span class="sd">            A new Dataset with the new variables in addition to all the</span>
<span class="sd">            existing variables.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Since ``kwargs`` is a dictionary, the order of your arguments may not</span>
<span class="sd">        be preserved, and so the order of the new variables is not well</span>
<span class="sd">        defined. Assigning multiple variables within the same ``assign`` is</span>
<span class="sd">        possible, but you cannot reference other variables created within the</span>
<span class="sd">        same ``assign`` call.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.DataFrame.assign</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;temperature_c&quot;: (</span>
<span class="sd">        ...             (&quot;lat&quot;, &quot;lon&quot;),</span>
<span class="sd">        ...             20 * np.random.rand(4).reshape(2, 2),</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...         &quot;precipitation&quot;: ((&quot;lat&quot;, &quot;lon&quot;), np.random.rand(4).reshape(2, 2)),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;lat&quot;: [10, 20], &quot;lon&quot;: [150, 160]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:        (lat: 2, lon: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * lat            (lat) int64 10 20</span>
<span class="sd">          * lon            (lon) int64 150 160</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature_c  (lat, lon) float64 10.98 14.3 12.06 10.9</span>
<span class="sd">            precipitation  (lat, lon) float64 0.4237 0.6459 0.4376 0.8918</span>

<span class="sd">        Where the value is a callable, evaluated on dataset:</span>

<span class="sd">        &gt;&gt;&gt; x.assign(temperature_f=lambda x: x.temperature_c * 9 / 5 + 32)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:        (lat: 2, lon: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * lat            (lat) int64 10 20</span>
<span class="sd">          * lon            (lon) int64 150 160</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature_c  (lat, lon) float64 10.98 14.3 12.06 10.9</span>
<span class="sd">            precipitation  (lat, lon) float64 0.4237 0.6459 0.4376 0.8918</span>
<span class="sd">            temperature_f  (lat, lon) float64 51.76 57.75 53.7 51.62</span>

<span class="sd">        Alternatively, the same behavior can be achieved by directly referencing an existing dataarray:</span>

<span class="sd">        &gt;&gt;&gt; x.assign(temperature_f=x[&quot;temperature_c&quot;] * 9 / 5 + 32)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:        (lat: 2, lon: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * lat            (lat) int64 10 20</span>
<span class="sd">          * lon            (lon) int64 150 160</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature_c  (lat, lon) float64 10.98 14.3 12.06 10.9</span>
<span class="sd">            precipitation  (lat, lon) float64 0.4237 0.6459 0.4376 0.8918</span>
<span class="sd">            temperature_f  (lat, lon) float64 51.76 57.75 53.7 51.62</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">variables_kwargs</span><span class="p">,</span> <span class="s2">&quot;assign&quot;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># do all calculations first...</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_calc_assign_results</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="c1"># ... and then assign</span>
        <span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;variable&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert this dataset into an xarray.DataArray</span>

<span class="sd">        The data variables of this dataset will be broadcast against each other</span>
<span class="sd">        and stacked along the first axis of the new array. All coordinates of</span>
<span class="sd">        this dataset will remain coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : str, optional</span>
<span class="sd">            Name of the new dimension.</span>
<span class="sd">        name : str, optional</span>
<span class="sd">            Name of the new data array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array : xarray.DataArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>

        <span class="n">data_vars</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">]</span>
        <span class="n">broadcast_vars</span> <span class="o">=</span> <span class="n">broadcast_variables</span><span class="p">(</span><span class="o">*</span><span class="n">data_vars</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">duck_array_ops</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">broadcast_vars</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">propagate_indexes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">)</span>

        <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">dim</span><span class="p">,)</span> <span class="o">+</span> <span class="n">broadcast_vars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span>

        <span class="k">return</span> <span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_normalize_dim_order</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dim_order</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check the validity of the provided dimensions if any and return the mapping</span>
<span class="sd">        between dimension name and their size.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim_order</span>
<span class="sd">            Dimension order to validate (default to the alphabetical order if None).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result</span>
<span class="sd">            Validated dimensions mapping.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">set</span><span class="p">(</span><span class="n">dim_order</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;dim_order </span><span class="si">{}</span><span class="s2"> does not match the set of dimensions of this &quot;</span>
                <span class="s2">&quot;Dataset: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim_order</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="n">ordered_dims</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dim_order</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">ordered_dims</span>

    <span class="k">def</span> <span class="nf">to_pandas</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convert this dataset into a pandas object without changing the number of dimensions.</span>

<span class="sd">        The type of the returned object depends on the number of Dataset</span>
<span class="sd">        dimensions:</span>

<span class="sd">        * 0D -&gt; `pandas.Series`</span>
<span class="sd">        * 1D -&gt; `pandas.DataFrame`</span>

<span class="sd">        Only works for Datasets with 1 or fewer dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;cannot convert Datasets with </span><span class="si">%s</span><span class="s2"> dimensions into &quot;</span>
            <span class="s2">&quot;pandas objects without changing the number of dimensions. &quot;</span>
            <span class="s2">&quot;Please use Dataset.to_dataframe() instead.&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ordered_dims</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">set_dims</span><span class="p">(</span><span class="n">ordered_dims</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">columns</span>
        <span class="p">]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">to_index</span><span class="p">([</span><span class="o">*</span><span class="n">ordered_dims</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">data</span><span class="p">)),</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim_order</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convert this dataset into a pandas.DataFrame.</span>

<span class="sd">        Non-index variables in this dataset form the columns of the</span>
<span class="sd">        DataFrame. The DataFrame is indexed by the Cartesian product of</span>
<span class="sd">        this dataset&#39;s indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim_order</span>
<span class="sd">            Hierarchical dimension order for the resulting dataframe. All</span>
<span class="sd">            arrays are transposed to this order and then written out as flat</span>
<span class="sd">            vectors in contiguous order, so the last dimension in this list</span>
<span class="sd">            will be contiguous in the resulting DataFrame. This has a major</span>
<span class="sd">            influence on which operations are efficient on the resulting</span>
<span class="sd">            dataframe.</span>

<span class="sd">            If provided, must include all dimensions of this dataset. By</span>
<span class="sd">            default, dimensions are sorted alphabetically.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result</span>
<span class="sd">            Dataset as a pandas DataFrame.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ordered_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_dim_order</span><span class="p">(</span><span class="n">dim_order</span><span class="o">=</span><span class="n">dim_order</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_dataframe</span><span class="p">(</span><span class="n">ordered_dims</span><span class="o">=</span><span class="n">ordered_dims</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_sparse_data_from_dataframe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="n">arrays</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="n">dims</span><span class="p">:</span> <span class="nb">tuple</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">sparse</span> <span class="kn">import</span> <span class="n">COO</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="k">for</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">idx</span><span class="o">.</span><span class="n">codes</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">is_sorted</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lev</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">lev</span> <span class="ow">in</span> <span class="n">idx</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">is_sorted</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">size</span><span class="p">,)</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
            <span class="c1"># In virtually all real use cases, the sparse array will now have</span>
            <span class="c1"># missing values and needs a fill_value. For consistency, don&#39;t</span>
            <span class="c1"># special case the rare exceptions (e.g., dtype=int without a</span>
            <span class="c1"># MultiIndex).</span>
            <span class="n">dtype</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">maybe_promote</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">COO</span><span class="p">(</span>
                <span class="n">coords</span><span class="p">,</span>
                <span class="n">values</span><span class="p">,</span>
                <span class="n">shape</span><span class="p">,</span>
                <span class="n">has_duplicates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="nb">sorted</span><span class="o">=</span><span class="n">is_sorted</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_numpy_data_from_dataframe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="n">arrays</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="n">dims</span><span class="p">:</span> <span class="nb">tuple</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># NB: similar, more general logic, now exists in</span>
        <span class="c1"># variable.unstack_once; we could consider combining them at some</span>
        <span class="c1"># point.</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lev</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">lev</span> <span class="ow">in</span> <span class="n">idx</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">codes</span><span class="p">)</span>

        <span class="c1"># We already verified that the MultiIndex has all unique values, so</span>
        <span class="c1"># there are missing values if and only if the size of output arrays is</span>
        <span class="c1"># larger that the index.</span>
        <span class="n">missing_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
            <span class="c1"># NumPy indexing is much faster than using DataFrame.reindex() to</span>
            <span class="c1"># fill in missing values:</span>
            <span class="c1"># https://stackoverflow.com/a/35049899/809705</span>
            <span class="k">if</span> <span class="n">missing_values</span><span class="p">:</span>
                <span class="n">dtype</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">maybe_promote</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If there are no missing values, keep the existing dtype</span>
                <span class="c1"># instead of promoting to support NA, e.g., keep integer</span>
                <span class="c1"># columns as integers.</span>
                <span class="c1"># TODO: consider removing this special case, which doesn&#39;t</span>
                <span class="c1"># exist for sparse=True.</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dataframe</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convert a pandas.DataFrame into an xarray.Dataset</span>

<span class="sd">        Each column will be converted into an independent variable in the</span>
<span class="sd">        Dataset. If the dataframe&#39;s index is a MultiIndex, it will be expanded</span>
<span class="sd">        into a tensor product of one-dimensional indices (filling in missing</span>
<span class="sd">        values with NaN). This method will produce a Dataset very similar to</span>
<span class="sd">        that on which the &#39;to_dataframe&#39; method was called, except with</span>
<span class="sd">        possibly redundant dimensions (since all dataset variables will have</span>
<span class="sd">        the same dimensionality)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataframe : DataFrame</span>
<span class="sd">            DataFrame from which to copy data and indices.</span>
<span class="sd">        sparse : bool, default: False</span>
<span class="sd">            If true, create a sparse arrays instead of dense numpy arrays. This</span>
<span class="sd">            can potentially save a large amount of memory if the DataFrame has</span>
<span class="sd">            a MultiIndex. Requires the sparse package (sparse.pydata.org).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        New Dataset.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        xarray.DataArray.from_series</span>
<span class="sd">        pandas.DataFrame.to_xarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Add an option to remove dimensions along which the variables</span>
        <span class="c1"># are constant, to enable consistent serialization to/from a dataframe,</span>
        <span class="c1"># even if some variables have different dimensionality.</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot convert DataFrame with non-unique columns&quot;</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">remove_unused_levels_categories</span><span class="p">(</span><span class="n">dataframe</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">idx</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;cannot convert a DataFrame with a non-unique MultiIndex into xarray&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Cast to a NumPy array first, in case the Series is a pandas Extension</span>
        <span class="c1"># array (which doesn&#39;t have a valid NumPy dtype)</span>
        <span class="c1"># TODO: allow users to control how this casting happens, e.g., by</span>
        <span class="c1"># forwarding arguments to pandas.Series.to_numpy?</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;level_</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">n</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">lev</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">idx</span><span class="o">.</span><span class="n">levels</span><span class="p">):</span>
                <span class="n">obj</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">lev</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index_name</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;index&quot;</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">index_name</span><span class="p">,)</span>
            <span class="n">obj</span><span class="p">[</span><span class="n">index_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_set_sparse_data_from_dataframe</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_set_numpy_data_from_dataframe</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">to_dask_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">set_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this dataset into a dask.dataframe.DataFrame.</span>

<span class="sd">        The dimensions, coordinates and data variables in this dataset form</span>
<span class="sd">        the columns of the DataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim_order : list, optional</span>
<span class="sd">            Hierarchical dimension order for the resulting dataframe. All</span>
<span class="sd">            arrays are transposed to this order and then written out as flat</span>
<span class="sd">            vectors in contiguous order, so the last dimension in this list</span>
<span class="sd">            will be contiguous in the resulting DataFrame. This has a major</span>
<span class="sd">            influence on which operations are efficient on the resulting dask</span>
<span class="sd">            dataframe.</span>

<span class="sd">            If provided, must include all dimensions of this dataset. By</span>
<span class="sd">            default, dimensions are sorted alphabetically.</span>
<span class="sd">        set_index : bool, optional</span>
<span class="sd">            If set_index=True, the dask DataFrame is indexed by this dataset&#39;s</span>
<span class="sd">            coordinate. Since dask DataFrames do not support multi-indexes,</span>
<span class="sd">            set_index only works if the dataset only contains one dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dask.dataframe.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
        <span class="kn">import</span> <span class="nn">dask.dataframe</span> <span class="k">as</span> <span class="nn">dd</span>

        <span class="n">ordered_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_dim_order</span><span class="p">(</span><span class="n">dim_order</span><span class="o">=</span><span class="n">dim_order</span><span class="p">)</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered_dims</span><span class="p">)</span>
        <span class="n">columns</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">columns</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>

        <span class="n">series_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># dimension without a matching coordinate</span>
                <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">((</span><span class="n">name</span><span class="p">,),</span> <span class="n">data</span><span class="p">)</span>

            <span class="c1"># IndexVariable objects have a dummy .chunk() method</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">IndexVariable</span><span class="p">):</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">to_base_variable</span><span class="p">()</span>

            <span class="n">dask_array</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">set_dims</span><span class="p">(</span><span class="n">ordered_dims</span><span class="p">)</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
            <span class="n">series</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">dask_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
            <span class="n">series_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">series_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">set_index</span><span class="p">:</span>
            <span class="n">dim_order</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">ordered_dims</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim_order</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="p">(</span><span class="n">dim</span><span class="p">,)</span> <span class="o">=</span> <span class="n">dim_order</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># triggers an error about multi-indexes, even if only one</span>
                <span class="c1"># dimension is passed</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">dim_order</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this dataset to a dictionary following xarray naming</span>
<span class="sd">        conventions.</span>

<span class="sd">        Converts all variables and attributes to native Python objects</span>
<span class="sd">        Useful for converting to json. To avoid datetime incompatibility</span>
<span class="sd">        use decode_times=False kwarg in xarrray.open_dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : bool, optional</span>
<span class="sd">            Whether to include the actual data in the dictionary. When set to</span>
<span class="sd">            False, returns just the schema.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.from_dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;coords&quot;</span><span class="p">:</span> <span class="p">{},</span>
            <span class="s2">&quot;attrs&quot;</span><span class="p">:</span> <span class="n">decode_numpy_dict_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">),</span>
            <span class="s2">&quot;dims&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">),</span>
            <span class="s2">&quot;data_vars&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)})</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;data_vars&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)})</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a dictionary into an xarray.Dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        d : dict-like</span>
<span class="sd">            Mapping with a minimum structure of</span>
<span class="sd">                ``{&quot;var_0&quot;: {&quot;dims&quot;: [..], &quot;data&quot;: [..]}, \</span>
<span class="sd">                            ...}``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : xarray.Dataset</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.to_dict</span>
<span class="sd">        DataArray.from_dict</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; d = {</span>
<span class="sd">        ...     &quot;t&quot;: {&quot;dims&quot;: (&quot;t&quot;), &quot;data&quot;: [0, 1, 2]},</span>
<span class="sd">        ...     &quot;a&quot;: {&quot;dims&quot;: (&quot;t&quot;), &quot;data&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]},</span>
<span class="sd">        ...     &quot;b&quot;: {&quot;dims&quot;: (&quot;t&quot;), &quot;data&quot;: [10, 20, 30]},</span>
<span class="sd">        ... }</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset.from_dict(d)</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (t: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * t        (t) int64 0 1 2</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (t) &lt;U1 &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>
<span class="sd">            b        (t) int64 10 20 30</span>

<span class="sd">        &gt;&gt;&gt; d = {</span>
<span class="sd">        ...     &quot;coords&quot;: {</span>
<span class="sd">        ...         &quot;t&quot;: {&quot;dims&quot;: &quot;t&quot;, &quot;data&quot;: [0, 1, 2], &quot;attrs&quot;: {&quot;units&quot;: &quot;s&quot;}}</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     &quot;attrs&quot;: {&quot;title&quot;: &quot;air temperature&quot;},</span>
<span class="sd">        ...     &quot;dims&quot;: &quot;t&quot;,</span>
<span class="sd">        ...     &quot;data_vars&quot;: {</span>
<span class="sd">        ...         &quot;a&quot;: {&quot;dims&quot;: &quot;t&quot;, &quot;data&quot;: [10, 20, 30]},</span>
<span class="sd">        ...         &quot;b&quot;: {&quot;dims&quot;: &quot;t&quot;, &quot;data&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]},</span>
<span class="sd">        ...     },</span>
<span class="sd">        ... }</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset.from_dict(d)</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (t: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * t        (t) int64 0 1 2</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (t) int64 10 20 30</span>
<span class="sd">            b        (t) &lt;U1 &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>
<span class="sd">        Attributes:</span>
<span class="sd">            title:    air temperature</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">{</span><span class="s2">&quot;coords&quot;</span><span class="p">,</span> <span class="s2">&quot;data_vars&quot;</span><span class="p">}</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">d</span><span class="p">)):</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">itertools</span>

            <span class="n">variables</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;coords&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;data_vars&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">variable_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s2">&quot;dims&quot;</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;attrs&quot;</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span>
            <span class="p">}</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;cannot convert dict without the key &quot;</span>
                <span class="s2">&quot;&#39;</span><span class="si">{dims_data}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dims_data</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">variable_dict</span><span class="p">)</span>

        <span class="c1"># what if coords aren&#39;t dims?</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;coords&quot;</span><span class="p">,</span> <span class="p">{}))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dims&quot;</span><span class="p">,</span> <span class="p">{}))</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">set_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

        <span class="n">obj</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;attrs&quot;</span><span class="p">,</span> <span class="p">{}))</span>

        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_unary_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">keep_attrs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;keep_attrs&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keep_attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keep_attrs</span> <span class="o">=</span> <span class="n">_get_keep_attrs</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">keep_attrs</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">_attrs</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="k">if</span> <span class="n">keep_attrs</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_binary_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">reflexive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">groupby</span><span class="o">.</span><span class="n">GroupBy</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="n">align_type</span> <span class="o">=</span> <span class="n">OPTIONS</span><span class="p">[</span><span class="s2">&quot;arithmetic_join&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">join</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">join</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">)):</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">align_type</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">f</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">reflexive</span> <span class="k">else</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_binary_op</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">align_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ds</span>

    <span class="k">def</span> <span class="nf">_inplace_binary_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">groupby</span><span class="o">.</span><span class="n">GroupBy</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;in-place operations between a Dataset and &quot;</span>
                <span class="s2">&quot;a grouped object are not permitted&quot;</span>
            <span class="p">)</span>
        <span class="c1"># we don&#39;t actually modify arrays in-place with in-place Dataset</span>
        <span class="c1"># arithmetic -- this lets us automatically align things</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">)):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">inplace_to_noninplace_op</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_binary_op</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">_indexes</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_calculate_binary_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">apply_over_both</span><span class="p">(</span><span class="n">lhs_data_vars</span><span class="p">,</span> <span class="n">rhs_data_vars</span><span class="p">,</span> <span class="n">lhs_vars</span><span class="p">,</span> <span class="n">rhs_vars</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">inplace</span> <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span><span class="n">lhs_data_vars</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">rhs_data_vars</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;datasets must have the same data variables &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;for in-place arithmetic operations: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">lhs_data_vars</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">rhs_data_vars</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="n">dest_vars</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">lhs_data_vars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rhs_data_vars</span><span class="p">:</span>
                    <span class="n">dest_vars</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">lhs_vars</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">rhs_vars</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">join</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;outer&quot;</span><span class="p">]:</span>
                    <span class="n">dest_vars</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">lhs_vars</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rhs_data_vars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dest_vars</span> <span class="ow">and</span> <span class="n">join</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;outer&quot;</span><span class="p">]:</span>
                    <span class="n">dest_vars</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">rhs_vars</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dest_vars</span>

        <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="c1"># can&#39;t use our shortcut of doing the binary operation with</span>
            <span class="c1"># Variable objects, so apply over our data vars instead.</span>
            <span class="n">new_data_vars</span> <span class="o">=</span> <span class="n">apply_over_both</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">,</span> <span class="n">other</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">new_data_vars</span><span class="p">)</span>

        <span class="n">other_coords</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;coords&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">other_coords</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="n">new_vars</span> <span class="o">=</span> <span class="n">apply_over_both</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">data_vars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">variables</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_variable</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="n">new_vars</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">other_variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_vars</span><span class="p">)</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">_dims</span> <span class="o">=</span> <span class="n">calculate_dimensions</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">_variables</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ds</span>

    <span class="k">def</span> <span class="nf">_copy_attrs_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">attrs</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span>

    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;upper&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the n-th order discrete difference along given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : str</span>
<span class="sd">            Dimension over which to calculate the finite difference.</span>
<span class="sd">        n : int, optional</span>
<span class="sd">            The number of times values are differenced.</span>
<span class="sd">        label : str, optional</span>
<span class="sd">            The new coordinate in dimension ``dim`` will have the</span>
<span class="sd">            values of either the minuend&#39;s or subtrahend&#39;s coordinate</span>
<span class="sd">            for values &#39;upper&#39; and &#39;lower&#39;, respectively.  Other</span>
<span class="sd">            values are not supported.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        difference : same type as caller</span>
<span class="sd">            The n-th order finite difference of this object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        `n` matches numpy&#39;s behavior and is different from pandas&#39; first argument named</span>
<span class="sd">        `periods`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;foo&quot;: (&quot;x&quot;, [5, 5, 6, 6])})</span>
<span class="sd">        &gt;&gt;&gt; ds.diff(&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 3)</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (x) int64 0 1 0</span>
<span class="sd">        &gt;&gt;&gt; ds.diff(&quot;x&quot;, 2)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 2)</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (x) int64 1 -1</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.differentiate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;order `n` must be non-negative but got </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># prepare slices</span>
        <span class="n">kwargs_start</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)}</span>
        <span class="n">kwargs_end</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)}</span>

        <span class="c1"># prepare new coordinate</span>
        <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="n">kwargs_new</span> <span class="o">=</span> <span class="n">kwargs_end</span>
        <span class="k">elif</span> <span class="n">label</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
            <span class="n">kwargs_new</span> <span class="o">=</span> <span class="n">kwargs_start</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The &#39;label&#39; argument has to be either &#39;upper&#39; or &#39;lower&#39;&quot;</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs_end</span><span class="p">)</span> <span class="o">-</span> <span class="n">var</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs_start</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs_new</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="n">indexes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexes</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span> <span class="n">PandasIndex</span><span class="p">):</span>
                <span class="c1"># maybe optimize? (pandas index already indexed above with var.isel)</span>
                <span class="n">new_index</span> <span class="o">=</span> <span class="n">indexes</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">kwargs_new</span><span class="p">[</span><span class="n">dim</span><span class="p">]]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
                    <span class="n">indexes</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">PandasMultiIndex</span><span class="p">(</span><span class="n">new_index</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">indexes</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">PandasIndex</span><span class="p">(</span><span class="n">new_index</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>

        <span class="n">difference</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">difference</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">difference</span>

    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shifts</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
        <span class="o">**</span><span class="n">shifts_kwargs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>

        <span class="sd">&quot;&quot;&quot;Shift this dataset by an offset along one or more dimensions.</span>

<span class="sd">        Only data variables are moved; coordinates stay in place. This is</span>
<span class="sd">        consistent with the behavior of ``shift`` in pandas.</span>

<span class="sd">        Values shifted from beyond array bounds will appear at one end of</span>
<span class="sd">        each dimension, which are filled according to `fill_value`. For periodic</span>
<span class="sd">        offsets instead see `roll`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shifts : mapping of hashable to int</span>
<span class="sd">            Integer offset to shift along each of the given dimensions.</span>
<span class="sd">            Positive offsets shift to the right; negative offsets shift to the</span>
<span class="sd">            left.</span>
<span class="sd">        fill_value : scalar or dict-like, optional</span>
<span class="sd">            Value to use for newly missing values. If a dict-like, maps</span>
<span class="sd">            variable names (including coordinates) to fill values.</span>
<span class="sd">        **shifts_kwargs</span>
<span class="sd">            The keyword arguments form of ``shifts``.</span>
<span class="sd">            One of shifts or shifts_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shifted : Dataset</span>
<span class="sd">            Dataset with the same coordinates and attributes but shifted data</span>
<span class="sd">            variables.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        roll</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;foo&quot;: (&quot;x&quot;, list(&quot;abcde&quot;))})</span>
<span class="sd">        &gt;&gt;&gt; ds.shift(x=2)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 5)</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (x) object nan nan &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">shifts</span><span class="p">,</span> <span class="n">shifts_kwargs</span><span class="p">,</span> <span class="s2">&quot;shift&quot;</span><span class="p">)</span>
        <span class="n">invalid</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">shifts</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">invalid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dimensions </span><span class="si">{</span><span class="n">invalid</span><span class="si">!r}</span><span class="s2"> do not exist&quot;</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
                <span class="n">fill_value_</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">fill_value</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
                    <span class="k">else</span> <span class="n">fill_value</span>
                <span class="p">)</span>

                <span class="n">var_shifts</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">shifts</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value_</span><span class="p">,</span> <span class="n">shifts</span><span class="o">=</span><span class="n">var_shifts</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">roll</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shifts</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">roll_coords</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">shifts_kwargs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Roll this dataset by an offset along one or more dimensions.</span>

<span class="sd">        Unlike shift, roll treats the given dimensions as periodic, so will not</span>
<span class="sd">        create any missing values to be filled.</span>

<span class="sd">        Also unlike shift, roll may rotate all variables, including coordinates</span>
<span class="sd">        if specified. The direction of rotation is consistent with</span>
<span class="sd">        :py:func:`numpy.roll`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shifts : mapping of hashable to int, optional</span>
<span class="sd">            A dict with keys matching dimensions and values given</span>
<span class="sd">            by integers to rotate each of the given dimensions. Positive</span>
<span class="sd">            offsets roll to the right; negative offsets roll to the left.</span>
<span class="sd">        roll_coords : bool, default: False</span>
<span class="sd">            Indicates whether to roll the coordinates by the offset too.</span>
<span class="sd">        **shifts_kwargs : {dim: offset, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``shifts``.</span>
<span class="sd">            One of shifts or shifts_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rolled : Dataset</span>
<span class="sd">            Dataset with the same attributes but rolled data and coordinates.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        shift</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;foo&quot;: (&quot;x&quot;, list(&quot;abcde&quot;))}, coords={&quot;x&quot;: np.arange(5)})</span>
<span class="sd">        &gt;&gt;&gt; ds.roll(x=2)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 5)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 0 1 2 3 4</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (x) &lt;U1 &#39;d&#39; &#39;e&#39; &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>

<span class="sd">        &gt;&gt;&gt; ds.roll(x=2, roll_coords=True)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 5)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 3 4 0 1 2</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (x) &lt;U1 &#39;d&#39; &#39;e&#39; &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">shifts</span><span class="p">,</span> <span class="n">shifts_kwargs</span><span class="p">,</span> <span class="s2">&quot;roll&quot;</span><span class="p">)</span>
        <span class="n">invalid</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">shifts</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">invalid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dimensions </span><span class="si">{</span><span class="n">invalid</span><span class="si">!r}</span><span class="s2"> do not exist&quot;</span><span class="p">)</span>

        <span class="n">unrolled_vars</span> <span class="o">=</span> <span class="p">()</span> <span class="k">if</span> <span class="n">roll_coords</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unrolled_vars</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span>
                    <span class="n">shifts</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">s</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shifts</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="k">if</span> <span class="n">roll_coords</span><span class="p">:</span>
            <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">idx</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="p">(</span><span class="n">dim</span><span class="p">,)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">:</span>
                    <span class="n">indexes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">roll_index</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">shifts</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">indexes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sortby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort object by labels or values (along an axis).</span>

<span class="sd">        Sorts the dataset, either along specified dimensions,</span>
<span class="sd">        or according to values of 1-D dataarrays that share dimension</span>
<span class="sd">        with calling object.</span>

<span class="sd">        If the input variables are dataarrays, then the dataarrays are aligned</span>
<span class="sd">        (via left-join) to the calling object prior to sorting by cell values.</span>
<span class="sd">        NaNs are sorted to the end, following Numpy convention.</span>

<span class="sd">        If multiple sorts along the same dimension is</span>
<span class="sd">        given, numpy&#39;s lexsort is performed along that dimension:</span>
<span class="sd">        https://numpy.org/doc/stable/reference/generated/numpy.lexsort.html</span>
<span class="sd">        and the FIRST key in the sequence is used as the primary sort key,</span>
<span class="sd">        followed by the 2nd key, etc.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variables : str, DataArray, or list of str or DataArray</span>
<span class="sd">            1D DataArray objects or name(s) of 1D variable(s) in</span>
<span class="sd">            coords/data_vars whose values are used to sort the dataset.</span>
<span class="sd">        ascending : bool, optional</span>
<span class="sd">            Whether to sort by ascending or descending order.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sorted : Dataset</span>
<span class="sd">            A new dataset where all the specified dims are sorted by dim</span>
<span class="sd">            labels.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.sortby</span>
<span class="sd">        numpy.sort</span>
<span class="sd">        pandas.sort_values</span>
<span class="sd">        pandas.sort_index</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;A&quot;: ((&quot;x&quot;, &quot;y&quot;), [[1, 2], [3, 4]]),</span>
<span class="sd">        ...         &quot;B&quot;: ((&quot;x&quot;, &quot;y&quot;), [[5, 6], [7, 8]]),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;x&quot;: [&quot;b&quot;, &quot;a&quot;], &quot;y&quot;: [1, 0]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds.sortby(&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 2, y: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) &lt;U1 &#39;a&#39; &#39;b&#39;</span>
<span class="sd">          * y        (y) int64 1 0</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x, y) int64 3 4 1 2</span>
<span class="sd">            B        (x, y) int64 7 8 5 6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">variables</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">]</span>
        <span class="n">aligned_vars</span> <span class="o">=</span> <span class="n">align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">variables</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="n">aligned_self</span> <span class="o">=</span> <span class="n">aligned_vars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">aligned_other_vars</span> <span class="o">=</span> <span class="n">aligned_vars</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">vars_by_dim</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">data_array</span> <span class="ow">in</span> <span class="n">aligned_other_vars</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input DataArray is not 1-D.&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="n">key</span><span class="p">,)</span> <span class="o">=</span> <span class="n">data_array</span><span class="o">.</span><span class="n">dims</span>
            <span class="n">vars_by_dim</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_array</span><span class="p">)</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">arrays</span> <span class="ow">in</span> <span class="n">vars_by_dim</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">arrays</span><span class="p">)))</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">order</span> <span class="k">if</span> <span class="n">ascending</span> <span class="k">else</span> <span class="n">order</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">aligned_self</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="o">**</span><span class="n">indices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">quantile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">QUANTILE_METHODS</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">keep_attrs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">interpolation</span><span class="p">:</span> <span class="n">QUANTILE_METHODS</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the qth quantile of the data along the specified dimension.</span>

<span class="sd">        Returns the qth quantiles(s) of the array elements for each variable</span>
<span class="sd">        in the Dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q : float or array-like of float</span>
<span class="sd">            Quantile to compute, which must be between 0 and 1 inclusive.</span>
<span class="sd">        dim : str or sequence of str, optional</span>
<span class="sd">            Dimension(s) over which to apply quantile.</span>
<span class="sd">        method : str, default: &quot;linear&quot;</span>
<span class="sd">            This optional parameter specifies the interpolation method to use when the</span>
<span class="sd">            desired quantile lies between two data points. The options sorted by their R</span>
<span class="sd">            type as summarized in the H&amp;F paper [1]_ are:</span>

<span class="sd">                1. &quot;inverted_cdf&quot; (*)</span>
<span class="sd">                2. &quot;averaged_inverted_cdf&quot; (*)</span>
<span class="sd">                3. &quot;closest_observation&quot; (*)</span>
<span class="sd">                4. &quot;interpolated_inverted_cdf&quot; (*)</span>
<span class="sd">                5. &quot;hazen&quot; (*)</span>
<span class="sd">                6. &quot;weibull&quot; (*)</span>
<span class="sd">                7. &quot;linear&quot;  (default)</span>
<span class="sd">                8. &quot;median_unbiased&quot; (*)</span>
<span class="sd">                9. &quot;normal_unbiased&quot; (*)</span>

<span class="sd">            The first three methods are discontiuous.  The following discontinuous</span>
<span class="sd">            variations of the default &quot;linear&quot; (7.) option are also available:</span>

<span class="sd">                * &quot;lower&quot;</span>
<span class="sd">                * &quot;higher&quot;</span>
<span class="sd">                * &quot;midpoint&quot;</span>
<span class="sd">                * &quot;nearest&quot;</span>

<span class="sd">            See :py:func:`numpy.quantile` or [1]_ for a description. Methods marked with</span>
<span class="sd">            an asterix require numpy version 1.22 or newer. The &quot;method&quot; argument was</span>
<span class="sd">            previously called &quot;interpolation&quot;, renamed in accordance with numpy</span>
<span class="sd">            version 1.22.0.</span>

<span class="sd">        keep_attrs : bool, optional</span>
<span class="sd">            If True, the dataset&#39;s attributes (`attrs`) will be copied from</span>
<span class="sd">            the original object to the new one.  If False (default), the new</span>
<span class="sd">            object will be returned without attributes.</span>
<span class="sd">        numeric_only : bool, optional</span>
<span class="sd">            If True, only apply ``func`` to variables with a numeric dtype.</span>
<span class="sd">        skipna : bool, optional</span>
<span class="sd">            Whether to skip missing values when aggregating.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        quantiles : Dataset</span>
<span class="sd">            If `q` is a single quantile, then the result is a scalar for each</span>
<span class="sd">            variable in data_vars. If multiple percentiles are given, first</span>
<span class="sd">            axis of the result corresponds to the quantile and a quantile</span>
<span class="sd">            dimension is added to the return Dataset. The other dimensions are</span>
<span class="sd">            the dimensions that remain after the reduction of the array.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.nanquantile, numpy.quantile, pandas.Series.quantile, DataArray.quantile</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     {&quot;a&quot;: ((&quot;x&quot;, &quot;y&quot;), [[0.7, 4.2, 9.4, 1.5], [6.5, 7.3, 2.6, 1.9]])},</span>
<span class="sd">        ...     coords={&quot;x&quot;: [7, 9], &quot;y&quot;: [1, 1.5, 2, 2.5]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds.quantile(0)  # or ds.quantile(0, dim=...)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:   ()</span>
<span class="sd">        Coordinates:</span>
<span class="sd">            quantile  float64 0.0</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a         float64 0.7</span>
<span class="sd">        &gt;&gt;&gt; ds.quantile(0, dim=&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:   (y: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y         (y) float64 1.0 1.5 2.0 2.5</span>
<span class="sd">            quantile  float64 0.0</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a         (y) float64 0.7 4.2 2.6 1.5</span>
<span class="sd">        &gt;&gt;&gt; ds.quantile([0, 0.5, 1])</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:   (quantile: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * quantile  (quantile) float64 0.0 0.5 1.0</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a         (quantile) float64 0.7 3.4 9.4</span>
<span class="sd">        &gt;&gt;&gt; ds.quantile([0, 0.5, 1], dim=&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:   (quantile: 3, y: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y         (y) float64 1.0 1.5 2.0 2.5</span>
<span class="sd">          * quantile  (quantile) float64 0.0 0.5 1.0</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a         (quantile, y) float64 0.7 4.2 2.6 1.5 3.6 ... 1.7 6.5 7.3 9.4 1.9</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] R. J. Hyndman and Y. Fan,</span>
<span class="sd">           &quot;Sample quantiles in statistical packages,&quot;</span>
<span class="sd">           The American Statistician, 50(4), pp. 361-365, 1996</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># interpolation renamed to method in version 0.21.0</span>
        <span class="c1"># check here and in variable to avoid repeated warnings</span>
        <span class="k">if</span> <span class="n">interpolation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The `interpolation` argument to quantile was renamed to `method`.&quot;</span><span class="p">,</span>
                <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot pass interpolation and method keywords!&quot;</span><span class="p">)</span>

            <span class="n">method</span> <span class="o">=</span> <span class="n">interpolation</span>

        <span class="n">dims</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">}</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dim</span> <span class="ow">is</span> <span class="o">...</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

        <span class="n">_assert_empty</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">),</span>
            <span class="s2">&quot;Dataset does not contain the dimensions: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">reduce_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">reduce_dims</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="ow">not</span> <span class="n">numeric_only</span>
                        <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
                        <span class="ow">or</span> <span class="n">var</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span>
                    <span class="p">):</span>
                        <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span>
                            <span class="n">q</span><span class="p">,</span>
                            <span class="n">dim</span><span class="o">=</span><span class="n">reduce_dims</span><span class="p">,</span>
                            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                            <span class="n">keep_attrs</span><span class="o">=</span><span class="n">keep_attrs</span><span class="p">,</span>
                            <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
                        <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="c1"># construct the new dataset</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">}</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">keep_attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keep_attrs</span> <span class="o">=</span> <span class="n">_get_keep_attrs</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span> <span class="k">if</span> <span class="n">keep_attrs</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="n">q</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">pct</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ranks the data.</span>

<span class="sd">        Equal values are assigned a rank that is the average of the ranks that</span>
<span class="sd">        would have been otherwise assigned to all of the values within</span>
<span class="sd">        that set.</span>
<span class="sd">        Ranks begin at 1, not 0. If pct is True, computes percentage ranks.</span>

<span class="sd">        NaNs in the input array are returned as NaNs.</span>

<span class="sd">        The `bottleneck` library is required.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : str</span>
<span class="sd">            Dimension over which to compute rank.</span>
<span class="sd">        pct : bool, optional</span>
<span class="sd">            If True, compute percentage ranks, otherwise compute integer ranks.</span>
<span class="sd">        keep_attrs : bool, optional</span>
<span class="sd">            If True, the dataset&#39;s attributes (`attrs`) will be copied from</span>
<span class="sd">            the original object to the new one.  If False (default), the new</span>
<span class="sd">            object will be returned without attributes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ranked : Dataset</span>
<span class="sd">            Variables that do not depend on `dim` are dropped.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">OPTIONS</span><span class="p">[</span><span class="s2">&quot;use_bottleneck&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;rank requires bottleneck to be enabled.&quot;</span>
                <span class="s2">&quot; Call `xr.set_options(use_bottleneck=True)` to enable it.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dataset does not contain the dimension: </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">pct</span><span class="o">=</span><span class="n">pct</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="n">coord_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keep_attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keep_attrs</span> <span class="o">=</span> <span class="n">_get_keep_attrs</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span> <span class="k">if</span> <span class="n">keep_attrs</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">differentiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">datetime_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Differentiate with the second order accurate central</span>
<span class="sd">        differences.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This feature is limited to simple cartesian geometry, i.e. coord</span>
<span class="sd">            must be one dimensional.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coord : str</span>
<span class="sd">            The coordinate to be used to compute the gradient.</span>
<span class="sd">        edge_order : {1, 2}, default: 1</span>
<span class="sd">            N-th order accurate differences at the boundaries.</span>
<span class="sd">        datetime_unit : None or {&quot;Y&quot;, &quot;M&quot;, &quot;W&quot;, &quot;D&quot;, &quot;h&quot;, &quot;m&quot;, &quot;s&quot;, &quot;ms&quot;, \</span>
<span class="sd">            &quot;us&quot;, &quot;ns&quot;, &quot;ps&quot;, &quot;fs&quot;, &quot;as&quot;}, default: None</span>
<span class="sd">            Unit to compute gradient. Only valid for datetime coordinate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        differentiated: Dataset</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.gradient: corresponding numpy function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.variable</span> <span class="kn">import</span> <span class="n">Variable</span>

        <span class="k">if</span> <span class="n">coord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="ow">and</span> <span class="n">coord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Coordinate </span><span class="si">{</span><span class="n">coord</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>

        <span class="n">coord_var</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span><span class="o">.</span><span class="n">variable</span>
        <span class="k">if</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Coordinate </span><span class="si">{}</span><span class="s2"> must be 1 dimensional but is </span><span class="si">{}</span><span class="s2">&quot;</span>
                <span class="s2">&quot; dimensional&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">_contains_datetime_like_objects</span><span class="p">(</span><span class="n">coord_var</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;mM&quot;</span> <span class="ow">and</span> <span class="n">datetime_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">datetime_unit</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime_data</span><span class="p">(</span><span class="n">coord_var</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">datetime_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">datetime_unit</span> <span class="o">=</span> <span class="s2">&quot;s&quot;</span>  <span class="c1"># Default to seconds for cftime objects</span>
            <span class="n">coord_var</span> <span class="o">=</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">_to_numeric</span><span class="p">(</span><span class="n">datetime_unit</span><span class="o">=</span><span class="n">datetime_unit</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span> <span class="ow">and</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_contains_datetime_like_objects</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">_to_numeric</span><span class="p">(</span><span class="n">datetime_unit</span><span class="o">=</span><span class="n">datetime_unit</span><span class="p">)</span>
                <span class="n">grad</span> <span class="o">=</span> <span class="n">duck_array_ops</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span>
                    <span class="n">v</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">coord_var</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">get_axis_num</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">grad</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coord</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
        <span class="n">datetime_unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Integrate along the given coordinate using the trapezoidal rule.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This feature is limited to simple cartesian geometry, i.e. coord</span>
<span class="sd">            must be one dimensional.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coord : hashable, or sequence of hashable</span>
<span class="sd">            Coordinate(s) used for the integration.</span>
<span class="sd">        datetime_unit : {&#39;Y&#39;, &#39;M&#39;, &#39;W&#39;, &#39;D&#39;, &#39;h&#39;, &#39;m&#39;, &#39;s&#39;, &#39;ms&#39;, &#39;us&#39;, &#39;ns&#39;, \</span>
<span class="sd">                        &#39;ps&#39;, &#39;fs&#39;, &#39;as&#39;}, optional</span>
<span class="sd">            Specify the unit if datetime coordinate is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        integrated : Dataset</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.integrate</span>
<span class="sd">        numpy.trapz : corresponding numpy function</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     data_vars={&quot;a&quot;: (&quot;x&quot;, [5, 5, 6, 6]), &quot;b&quot;: (&quot;x&quot;, [1, 2, 1, 0])},</span>
<span class="sd">        ...     coords={&quot;x&quot;: [0, 1, 2, 3], &quot;y&quot;: (&quot;x&quot;, [1, 7, 3, 5])},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 0 1 2 3</span>
<span class="sd">            y        (x) int64 1 7 3 5</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) int64 5 5 6 6</span>
<span class="sd">            b        (x) int64 1 2 1 0</span>
<span class="sd">        &gt;&gt;&gt; ds.integrate(&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  ()</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        float64 16.5</span>
<span class="sd">            b        float64 3.5</span>
<span class="sd">        &gt;&gt;&gt; ds.integrate(&quot;y&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  ()</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        float64 20.0</span>
<span class="sd">            b        float64 4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="p">(</span><span class="n">coord</span><span class="p">,)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coord</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_integrate_one</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">datetime_unit</span><span class="o">=</span><span class="n">datetime_unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_integrate_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">datetime_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cumulative</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.variable</span> <span class="kn">import</span> <span class="n">Variable</span>

        <span class="k">if</span> <span class="n">coord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="ow">and</span> <span class="n">coord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Coordinate </span><span class="si">{</span><span class="n">coord</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>

        <span class="n">coord_var</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span><span class="o">.</span><span class="n">variable</span>
        <span class="k">if</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Coordinate </span><span class="si">{}</span><span class="s2"> must be 1 dimensional but is </span><span class="si">{}</span><span class="s2">&quot;</span>
                <span class="s2">&quot; dimensional&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">_contains_datetime_like_objects</span><span class="p">(</span><span class="n">coord_var</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;mM&quot;</span> <span class="ow">and</span> <span class="n">datetime_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">datetime_unit</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime_data</span><span class="p">(</span><span class="n">coord_var</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">datetime_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">datetime_unit</span> <span class="o">=</span> <span class="s2">&quot;s&quot;</span>  <span class="c1"># Default to seconds for cftime objects</span>
            <span class="n">coord_var</span> <span class="o">=</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">datetime_to_numeric</span><span class="p">(</span><span class="n">coord_var</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">datetime_unit</span><span class="o">=</span><span class="n">datetime_unit</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span> <span class="ow">or</span> <span class="n">cumulative</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                    <span class="n">coord_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span> <span class="ow">and</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">_contains_datetime_like_objects</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">datetime_to_numeric</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">datetime_unit</span><span class="o">=</span><span class="n">datetime_unit</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">cumulative</span><span class="p">:</span>
                        <span class="n">integ</span> <span class="o">=</span> <span class="n">duck_array_ops</span><span class="o">.</span><span class="n">cumulative_trapezoid</span><span class="p">(</span>
                            <span class="n">v</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">get_axis_num</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">v_dims</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">integ</span> <span class="o">=</span> <span class="n">duck_array_ops</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span>
                            <span class="n">v</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">get_axis_num</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">v_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
                        <span class="n">v_dims</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">v_dims</span><span class="p">,</span> <span class="n">integ</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">cumulative_integrate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coord</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
        <span class="n">datetime_unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Integrate along the given coordinate using the trapezoidal rule.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This feature is limited to simple cartesian geometry, i.e. coord</span>
<span class="sd">            must be one dimensional.</span>

<span class="sd">            The first entry of the cumulative integral of each variable is always 0, in</span>
<span class="sd">            order to keep the length of the dimension unchanged between input and</span>
<span class="sd">            output.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coord : hashable, or sequence of hashable</span>
<span class="sd">            Coordinate(s) used for the integration.</span>
<span class="sd">        datetime_unit : {&#39;Y&#39;, &#39;M&#39;, &#39;W&#39;, &#39;D&#39;, &#39;h&#39;, &#39;m&#39;, &#39;s&#39;, &#39;ms&#39;, &#39;us&#39;, &#39;ns&#39;, \</span>
<span class="sd">                        &#39;ps&#39;, &#39;fs&#39;, &#39;as&#39;}, optional</span>
<span class="sd">            Specify the unit if datetime coordinate is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        integrated : Dataset</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.cumulative_integrate</span>
<span class="sd">        scipy.integrate.cumulative_trapezoid : corresponding scipy function</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     data_vars={&quot;a&quot;: (&quot;x&quot;, [5, 5, 6, 6]), &quot;b&quot;: (&quot;x&quot;, [1, 2, 1, 0])},</span>
<span class="sd">        ...     coords={&quot;x&quot;: [0, 1, 2, 3], &quot;y&quot;: (&quot;x&quot;, [1, 7, 3, 5])},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 0 1 2 3</span>
<span class="sd">            y        (x) int64 1 7 3 5</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) int64 5 5 6 6</span>
<span class="sd">            b        (x) int64 1 2 1 0</span>
<span class="sd">        &gt;&gt;&gt; ds.cumulative_integrate(&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 0 1 2 3</span>
<span class="sd">            y        (x) int64 1 7 3 5</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) float64 0.0 5.0 10.5 16.5</span>
<span class="sd">            b        (x) float64 0.0 1.5 3.0 3.5</span>
<span class="sd">        &gt;&gt;&gt; ds.cumulative_integrate(&quot;y&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 0 1 2 3</span>
<span class="sd">            y        (x) int64 1 7 3 5</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) float64 0.0 30.0 8.0 20.0</span>
<span class="sd">            b        (x) float64 0.0 9.0 3.0 4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="p">(</span><span class="n">coord</span><span class="p">,)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coord</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_integrate_one</span><span class="p">(</span>
                <span class="n">c</span><span class="p">,</span> <span class="n">datetime_unit</span><span class="o">=</span><span class="n">datetime_unit</span><span class="p">,</span> <span class="n">cumulative</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">keep_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">keep_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">plot</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">UncachedAccessor</span><span class="p">(</span><span class="n">_Dataset_PlotMethods</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">filter_by_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a ``Dataset`` with variables that match specific conditions.</span>

<span class="sd">        Can pass in ``key=value`` or ``key=callable``.  A Dataset is returned</span>
<span class="sd">        containing only the variables for which all the filter tests pass.</span>
<span class="sd">        These tests are either ``key=value`` for which the attribute ``key``</span>
<span class="sd">        has the exact value ``value`` or the callable passed into</span>
<span class="sd">        ``key=callable`` returns True. The callable will be passed a single</span>
<span class="sd">        value, either the value of the attribute ``key`` or ``None`` if the</span>
<span class="sd">        DataArray does not have an attribute with the name ``key``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            key : str</span>
<span class="sd">                Attribute name.</span>
<span class="sd">            value : callable or obj</span>
<span class="sd">                If value is a callable, it should return a boolean in the form</span>
<span class="sd">                of bool = func(attr) where attr is da.attrs[key].</span>
<span class="sd">                Otherwise, value will be compared to the each</span>
<span class="sd">                DataArray&#39;s attrs[key].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new : Dataset</span>
<span class="sd">            New dataset with variables filtered by attribute.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; temp = 15 + 8 * np.random.randn(2, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; precip = 10 * np.random.rand(2, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; lon = [[-99.83, -99.32], [-99.79, -99.23]]</span>
<span class="sd">        &gt;&gt;&gt; lat = [[42.25, 42.21], [42.63, 42.59]]</span>
<span class="sd">        &gt;&gt;&gt; dims = [&quot;x&quot;, &quot;y&quot;, &quot;time&quot;]</span>
<span class="sd">        &gt;&gt;&gt; temp_attr = dict(standard_name=&quot;air_potential_temperature&quot;)</span>
<span class="sd">        &gt;&gt;&gt; precip_attr = dict(standard_name=&quot;convective_precipitation_flux&quot;)</span>

<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     dict(</span>
<span class="sd">        ...         temperature=(dims, temp, temp_attr),</span>
<span class="sd">        ...         precipitation=(dims, precip, precip_attr),</span>
<span class="sd">        ...     ),</span>
<span class="sd">        ...     coords=dict(</span>
<span class="sd">        ...         lon=([&quot;x&quot;, &quot;y&quot;], lon),</span>
<span class="sd">        ...         lat=([&quot;x&quot;, &quot;y&quot;], lat),</span>
<span class="sd">        ...         time=pd.date_range(&quot;2014-09-06&quot;, periods=3),</span>
<span class="sd">        ...         reference_time=pd.Timestamp(&quot;2014-09-05&quot;),</span>
<span class="sd">        ...     ),</span>
<span class="sd">        ... )</span>

<span class="sd">        Get variables matching a specific standard_name:</span>

<span class="sd">        &gt;&gt;&gt; ds.filter_by_attrs(standard_name=&quot;convective_precipitation_flux&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:         (x: 2, y: 2, time: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">            lon             (x, y) float64 -99.83 -99.32 -99.79 -99.23</span>
<span class="sd">            lat             (x, y) float64 42.25 42.21 42.63 42.59</span>
<span class="sd">          * time            (time) datetime64[ns] 2014-09-06 2014-09-07 2014-09-08</span>
<span class="sd">            reference_time  datetime64[ns] 2014-09-05</span>
<span class="sd">        Dimensions without coordinates: x, y</span>
<span class="sd">        Data variables:</span>
<span class="sd">            precipitation   (x, y, time) float64 5.68 9.256 0.7104 ... 7.992 4.615 7.805</span>

<span class="sd">        Get all variables that have a standard_name attribute:</span>

<span class="sd">        &gt;&gt;&gt; standard_name = lambda v: v is not None</span>
<span class="sd">        &gt;&gt;&gt; ds.filter_by_attrs(standard_name=standard_name)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:         (x: 2, y: 2, time: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">            lon             (x, y) float64 -99.83 -99.32 -99.79 -99.23</span>
<span class="sd">            lat             (x, y) float64 42.25 42.21 42.63 42.59</span>
<span class="sd">          * time            (time) datetime64[ns] 2014-09-06 2014-09-07 2014-09-08</span>
<span class="sd">            reference_time  datetime64[ns] 2014-09-05</span>
<span class="sd">        Dimensions without coordinates: x, y</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature     (x, y, time) float64 29.11 18.2 22.83 ... 18.28 16.15 26.63</span>
<span class="sd">            precipitation   (x, y, time) float64 5.68 9.256 0.7104 ... 7.992 4.615 7.805</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">has_value_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">attr_value</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">attr_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="ow">and</span> <span class="n">pattern</span><span class="p">(</span><span class="n">attr_value</span><span class="p">))</span> <span class="ow">or</span> <span class="n">attr_value</span> <span class="o">==</span> <span class="n">pattern</span><span class="p">:</span>
                    <span class="n">has_value_flag</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">has_value_flag</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">has_value_flag</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">selection</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">selection</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">unify_chunks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Unify chunk size along all chunked dimensions of this Dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset with consistent chunk sizes for all dask-array variables</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dask.array.core.unify_chunks</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">unify_chunks</span><span class="p">(</span><span class="bp">self</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">map_blocks</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">T_Xarray</span><span class="p">],</span>
        <span class="n">args</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
        <span class="n">kwargs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">template</span><span class="p">:</span> <span class="n">DataArray</span> <span class="o">|</span> <span class="n">Dataset</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T_Xarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a function to each block of this Dataset.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            This method is experimental and its signature may change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">            User-provided function that accepts a Dataset as its first</span>
<span class="sd">            parameter. The function will receive a subset or &#39;block&#39; of this Dataset (see below),</span>
<span class="sd">            corresponding to one chunk along each chunked dimension. ``func`` will be</span>
<span class="sd">            executed as ``func(subset_dataset, *subset_args, **kwargs)``.</span>

<span class="sd">            This function must return either a single DataArray or a single Dataset.</span>

<span class="sd">            This function cannot add a new chunked dimension.</span>
<span class="sd">        args : sequence</span>
<span class="sd">            Passed to func after unpacking and subsetting any xarray objects by blocks.</span>
<span class="sd">            xarray objects in args must be aligned with obj, otherwise an error is raised.</span>
<span class="sd">        kwargs : mapping</span>
<span class="sd">            Passed verbatim to func after unpacking. xarray objects, if any, will not be</span>
<span class="sd">            subset to blocks. Passing dask collections in kwargs is not allowed.</span>
<span class="sd">        template : DataArray or Dataset, optional</span>
<span class="sd">            xarray object representing the final result after compute is called. If not provided,</span>
<span class="sd">            the function will be first run on mocked-up data, that looks like this object but</span>
<span class="sd">            has sizes 0, to determine properties of the returned object such as dtype,</span>
<span class="sd">            variable names, attributes, new dimensions and new indexes (if any).</span>
<span class="sd">            ``template`` must be provided if the function changes the size of existing dimensions.</span>
<span class="sd">            When provided, ``attrs`` on variables in `template` are copied over to the result. Any</span>
<span class="sd">            ``attrs`` set by ``func`` will be ignored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A single DataArray or Dataset with dask backend, reassembled from the outputs of the</span>
<span class="sd">        function.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function is designed for when ``func`` needs to manipulate a whole xarray object</span>
<span class="sd">        subset to each block. Each block is loaded into memory. In the more common case where</span>
<span class="sd">        ``func`` can work on numpy arrays, it is recommended to use ``apply_ufunc``.</span>

<span class="sd">        If none of the variables in this object is backed by dask arrays, calling this function is</span>
<span class="sd">        equivalent to calling ``func(obj, *args, **kwargs)``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dask.array.map_blocks, xarray.apply_ufunc, xarray.Dataset.map_blocks</span>
<span class="sd">        xarray.DataArray.map_blocks</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Calculate an anomaly from climatology using ``.groupby()``. Using</span>
<span class="sd">        ``xr.map_blocks()`` allows for parallel operations with knowledge of ``xarray``,</span>
<span class="sd">        its indices, and its methods like ``.groupby()``.</span>

<span class="sd">        &gt;&gt;&gt; def calculate_anomaly(da, groupby_type=&quot;time.month&quot;):</span>
<span class="sd">        ...     gb = da.groupby(groupby_type)</span>
<span class="sd">        ...     clim = gb.mean(dim=&quot;time&quot;)</span>
<span class="sd">        ...     return gb - clim</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; time = xr.cftime_range(&quot;1990-01&quot;, &quot;1992-01&quot;, freq=&quot;M&quot;)</span>
<span class="sd">        &gt;&gt;&gt; month = xr.DataArray(time.month, coords={&quot;time&quot;: time}, dims=[&quot;time&quot;])</span>
<span class="sd">        &gt;&gt;&gt; np.random.seed(123)</span>
<span class="sd">        &gt;&gt;&gt; array = xr.DataArray(</span>
<span class="sd">        ...     np.random.rand(len(time)),</span>
<span class="sd">        ...     dims=[&quot;time&quot;],</span>
<span class="sd">        ...     coords={&quot;time&quot;: time, &quot;month&quot;: month},</span>
<span class="sd">        ... ).chunk()</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;a&quot;: array})</span>
<span class="sd">        &gt;&gt;&gt; ds.map_blocks(calculate_anomaly, template=ds).compute()</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (time: 24)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time     (time) object 1990-01-31 00:00:00 ... 1991-12-31 00:00:00</span>
<span class="sd">            month    (time) int64 1 2 3 4 5 6 7 8 9 10 11 12 1 2 3 4 5 6 7 8 9 10 11 12</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (time) float64 0.1289 0.1132 -0.0856 ... 0.2287 0.1906 -0.05901</span>

<span class="sd">        Note that one must explicitly use ``args=[]`` and ``kwargs={}`` to pass arguments</span>
<span class="sd">        to the function being applied in ``xr.map_blocks()``:</span>

<span class="sd">        &gt;&gt;&gt; ds.map_blocks(</span>
<span class="sd">        ...     calculate_anomaly,</span>
<span class="sd">        ...     kwargs={&quot;groupby_type&quot;: &quot;time.year&quot;},</span>
<span class="sd">        ...     template=ds,</span>
<span class="sd">        ... )</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (time: 24)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time     (time) object 1990-01-31 00:00:00 ... 1991-12-31 00:00:00</span>
<span class="sd">            month    (time) int64 dask.array&lt;chunksize=(24,), meta=np.ndarray&gt;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (time) float64 dask.array&lt;chunksize=(24,), meta=np.ndarray&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.parallel</span> <span class="kn">import</span> <span class="n">map_blocks</span>

        <span class="k">return</span> <span class="n">map_blocks</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">template</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">polyfit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
        <span class="n">deg</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">rcond</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">w</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">full</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cov</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Least squares polynomial fit.</span>

<span class="sd">        This replicates the behaviour of `numpy.polyfit` but differs by skipping</span>
<span class="sd">        invalid values when `skipna = True`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : hashable</span>
<span class="sd">            Coordinate along which to fit the polynomials.</span>
<span class="sd">        deg : int</span>
<span class="sd">            Degree of the fitting polynomial.</span>
<span class="sd">        skipna : bool, optional</span>
<span class="sd">            If True, removes all invalid values before fitting each 1D slices of the array.</span>
<span class="sd">            Default is True if data is stored in a dask.array or if there is any</span>
<span class="sd">            invalid values, False otherwise.</span>
<span class="sd">        rcond : float, optional</span>
<span class="sd">            Relative condition number to the fit.</span>
<span class="sd">        w : hashable or Any, optional</span>
<span class="sd">            Weights to apply to the y-coordinate of the sample points.</span>
<span class="sd">            Can be an array-like object or the name of a coordinate in the dataset.</span>
<span class="sd">        full : bool, optional</span>
<span class="sd">            Whether to return the residuals, matrix rank and singular values in addition</span>
<span class="sd">            to the coefficients.</span>
<span class="sd">        cov : bool or str, optional</span>
<span class="sd">            Whether to return to the covariance matrix in addition to the coefficients.</span>
<span class="sd">            The matrix is not scaled if `cov=&#39;unscaled&#39;`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        polyfit_results : Dataset</span>
<span class="sd">            A single dataset which contains (for each &quot;var&quot; in the input dataset):</span>

<span class="sd">            [var]_polyfit_coefficients</span>
<span class="sd">                The coefficients of the best fit for each variable in this dataset.</span>
<span class="sd">            [var]_polyfit_residuals</span>
<span class="sd">                The residuals of the least-square computation for each variable (only included if `full=True`)</span>
<span class="sd">                When the matrix rank is deficient, np.nan is returned.</span>
<span class="sd">            [dim]_matrix_rank</span>
<span class="sd">                The effective rank of the scaled Vandermonde coefficient matrix (only included if `full=True`)</span>
<span class="sd">                The rank is computed ignoring the NaN values that might be skipped.</span>
<span class="sd">            [dim]_singular_values</span>
<span class="sd">                The singular values of the scaled Vandermonde coefficient matrix (only included if `full=True`)</span>
<span class="sd">            [var]_polyfit_covariance</span>
<span class="sd">                The covariance matrix of the polynomial coefficient estimates (only included if `full=False` and `cov=True`)</span>

<span class="sd">        Warns</span>
<span class="sd">        -----</span>
<span class="sd">        RankWarning</span>
<span class="sd">            The rank of the coefficient matrix in the least-squares fit is deficient.</span>
<span class="sd">            The warning is not raised with in-memory (not dask) data and `full=True`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.polyfit</span>
<span class="sd">        numpy.polyval</span>
<span class="sd">        xarray.polyval</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">skipna_da</span> <span class="o">=</span> <span class="n">skipna</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">get_clean_interp_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">xname</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_&quot;</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">deg</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rcond</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rcond</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>  <span class="c1"># type: ignore[attr-defined]</span>
            <span class="p">)</span>

        <span class="c1"># Weights:</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">):</span>
                <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected a 1-d array for weights.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected w and </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> to have the same length&quot;</span><span class="p">)</span>
            <span class="n">lhs</span> <span class="o">*=</span> <span class="n">w</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c1"># Scaling</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">lhs</span> <span class="o">*</span> <span class="n">lhs</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">lhs</span> <span class="o">/=</span> <span class="n">scale</span>

        <span class="n">degree_dim</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_temp_dimname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="s2">&quot;degree&quot;</span><span class="p">)</span>

        <span class="n">rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">xname</span> <span class="o">+</span> <span class="s2">&quot;matrix_rank&quot;</span><span class="p">)</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">rank</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">rank</span>
            <span class="n">_sing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">sing</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="n">_sing</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">degree_dim</span><span class="p">,),</span>
                <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="n">degree_dim</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">rank</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)},</span>
                <span class="n">name</span><span class="o">=</span><span class="n">xname</span> <span class="o">+</span> <span class="s2">&quot;singular_values&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">sing</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">sing</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">da</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">is_duck_dask_array</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">rank</span> <span class="o">!=</span> <span class="n">order</span> <span class="ow">or</span> <span class="n">full</span> <span class="ow">or</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="c1"># Current algorithm with dask and skipna=False neither supports</span>
                <span class="c1"># deficient ranks nor does it output the &quot;full&quot; info (issue dask/dask#6516)</span>
                <span class="n">skipna_da</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">skipna_da</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">isnull</span><span class="p">()))</span>

            <span class="n">dims_to_stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">dimname</span> <span class="k">for</span> <span class="n">dimname</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">dimname</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">]</span>
            <span class="n">stacked_coords</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">dims_to_stack</span><span class="p">:</span>
                <span class="n">stacked_dim</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_temp_dimname</span><span class="p">(</span><span class="n">dims_to_stack</span><span class="p">,</span> <span class="s2">&quot;stacked&quot;</span><span class="p">)</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="o">*</span><span class="n">dims_to_stack</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">stacked_dim</span><span class="p">:</span> <span class="n">dims_to_stack</span><span class="p">}</span>
                <span class="p">)</span>
                <span class="n">stacked_coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">stacked_dim</span><span class="p">:</span> <span class="n">rhs</span><span class="p">[</span><span class="n">stacked_dim</span><span class="p">]}</span>
                <span class="n">scale_da</span> <span class="o">=</span> <span class="n">scale</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="n">da</span>
                <span class="n">scale_da</span> <span class="o">=</span> <span class="n">scale</span>

            <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rhs</span> <span class="o">*=</span> <span class="n">w</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">full</span><span class="p">:</span>  <span class="c1"># Copy np.polyfit behavior</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">RankWarning</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Raise only once per variable</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;once&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">RankWarning</span><span class="p">)</span>

                <span class="n">coeffs</span><span class="p">,</span> <span class="n">residuals</span> <span class="o">=</span> <span class="n">duck_array_ops</span><span class="o">.</span><span class="n">least_squares</span><span class="p">(</span>
                    <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="n">rcond</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna_da</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Thus a ReprObject =&gt; polyfit was called on a DataArray</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

            <span class="n">coeffs</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="n">coeffs</span> <span class="o">/</span> <span class="n">scale_da</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="n">degree_dim</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">stacked_coords</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="n">degree_dim</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">order</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">stacked_coords</span><span class="p">},</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;polyfit_coefficients&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">dims_to_stack</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="n">stacked_dim</span><span class="p">)</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">coeffs</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeffs</span>

            <span class="k">if</span> <span class="n">full</span> <span class="ow">or</span> <span class="p">(</span><span class="n">cov</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">):</span>
                <span class="n">residuals</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                    <span class="n">residuals</span> <span class="k">if</span> <span class="n">dims_to_stack</span> <span class="k">else</span> <span class="n">residuals</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
                    <span class="n">dims</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">stacked_coords</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                    <span class="n">coords</span><span class="o">=</span><span class="n">stacked_coords</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;polyfit_residuals&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">dims_to_stack</span><span class="p">:</span>
                    <span class="n">residuals</span> <span class="o">=</span> <span class="n">residuals</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="n">stacked_dim</span><span class="p">)</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">residuals</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">residuals</span>

            <span class="k">if</span> <span class="n">cov</span><span class="p">:</span>
                <span class="n">Vbase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">lhs</span><span class="p">))</span>
                <span class="n">Vbase</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cov</span> <span class="o">==</span> <span class="s2">&quot;unscaled&quot;</span><span class="p">:</span>
                    <span class="n">fac</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">order</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;The number of data points must exceed order to scale the covariance matrix.&quot;</span>
                        <span class="p">)</span>
                    <span class="n">fac</span> <span class="o">=</span> <span class="n">residuals</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">order</span><span class="p">)</span>
                <span class="n">covariance</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">Vbase</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;cov_i&quot;</span><span class="p">,</span> <span class="s2">&quot;cov_j&quot;</span><span class="p">))</span> <span class="o">*</span> <span class="n">fac</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;polyfit_covariance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">covariance</span>

        <span class="k">return</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">data_vars</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">pad</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pad_width</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
        <span class="n">stat_length</span><span class="p">:</span> <span class="nb">int</span>
        <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
        <span class="o">|</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span>
        <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">constant_values</span><span class="p">:</span> <span class="p">(</span>
            <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span>
        <span class="p">)</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end_values</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reflect_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">pad_width_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Pad this dataset along one or more dimensions.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            This function is experimental and its behaviour is likely to change</span>
<span class="sd">            especially regarding padding of dimension coordinates (or IndexVariables).</span>

<span class="sd">        When using one of the modes (&quot;edge&quot;, &quot;reflect&quot;, &quot;symmetric&quot;, &quot;wrap&quot;),</span>
<span class="sd">        coordinates will be padded with the same mode, otherwise coordinates</span>
<span class="sd">        are padded using the &quot;constant&quot; mode with fill_value dtypes.NA.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pad_width : mapping of hashable to tuple of int</span>
<span class="sd">            Mapping with the form of {dim: (pad_before, pad_after)}</span>
<span class="sd">            describing the number of values padded along each dimension.</span>
<span class="sd">            {dim: pad} is a shortcut for pad_before = pad_after = pad</span>
<span class="sd">        mode : str, default: &quot;constant&quot;</span>
<span class="sd">            One of the following string values (taken from numpy docs).</span>

<span class="sd">            - constant: Pads with a constant value.</span>
<span class="sd">            - edge: Pads with the edge values of array.</span>
<span class="sd">            - linear_ramp: Pads with the linear ramp between end_value and the</span>
<span class="sd">              array edge value.</span>
<span class="sd">            - maximum: Pads with the maximum value of all or part of the</span>
<span class="sd">              vector along each axis.</span>
<span class="sd">            - mean: Pads with the mean value of all or part of the</span>
<span class="sd">              vector along each axis.</span>
<span class="sd">            - median: Pads with the median value of all or part of the</span>
<span class="sd">              vector along each axis.</span>
<span class="sd">            - minimum: Pads with the minimum value of all or part of the</span>
<span class="sd">              vector along each axis.</span>
<span class="sd">            - reflect: Pads with the reflection of the vector mirrored on</span>
<span class="sd">              the first and last values of the vector along each axis.</span>
<span class="sd">            - symmetric: Pads with the reflection of the vector mirrored</span>
<span class="sd">              along the edge of the array.</span>
<span class="sd">            - wrap: Pads with the wrap of the vector along the axis.</span>
<span class="sd">              The first values are used to pad the end and the</span>
<span class="sd">              end values are used to pad the beginning.</span>

<span class="sd">        stat_length : int, tuple or mapping of hashable to tuple, default: None</span>
<span class="sd">            Used in &#39;maximum&#39;, &#39;mean&#39;, &#39;median&#39;, and &#39;minimum&#39;.  Number of</span>
<span class="sd">            values at edge of each axis used to calculate the statistic value.</span>
<span class="sd">            {dim_1: (before_1, after_1), ... dim_N: (before_N, after_N)} unique</span>
<span class="sd">            statistic lengths along each dimension.</span>
<span class="sd">            ((before, after),) yields same before and after statistic lengths</span>
<span class="sd">            for each dimension.</span>
<span class="sd">            (stat_length,) or int is a shortcut for before = after = statistic</span>
<span class="sd">            length for all axes.</span>
<span class="sd">            Default is ``None``, to use the entire axis.</span>
<span class="sd">        constant_values : scalar, tuple or mapping of hashable to tuple, default: 0</span>
<span class="sd">            Used in &#39;constant&#39;.  The values to set the padded values for each</span>
<span class="sd">            axis.</span>
<span class="sd">            ``{dim_1: (before_1, after_1), ... dim_N: (before_N, after_N)}`` unique</span>
<span class="sd">            pad constants along each dimension.</span>
<span class="sd">            ``((before, after),)`` yields same before and after constants for each</span>
<span class="sd">            dimension.</span>
<span class="sd">            ``(constant,)`` or ``constant`` is a shortcut for ``before = after = constant`` for</span>
<span class="sd">            all dimensions.</span>
<span class="sd">            Default is 0.</span>
<span class="sd">        end_values : scalar, tuple or mapping of hashable to tuple, default: 0</span>
<span class="sd">            Used in &#39;linear_ramp&#39;.  The values used for the ending value of the</span>
<span class="sd">            linear_ramp and that will form the edge of the padded array.</span>
<span class="sd">            ``{dim_1: (before_1, after_1), ... dim_N: (before_N, after_N)}`` unique</span>
<span class="sd">            end values along each dimension.</span>
<span class="sd">            ``((before, after),)`` yields same before and after end values for each</span>
<span class="sd">            axis.</span>
<span class="sd">            ``(constant,)`` or ``constant`` is a shortcut for ``before = after = constant`` for</span>
<span class="sd">            all axes.</span>
<span class="sd">            Default is 0.</span>
<span class="sd">        reflect_type : {&quot;even&quot;, &quot;odd&quot;}, optional</span>
<span class="sd">            Used in &quot;reflect&quot;, and &quot;symmetric&quot;.  The &quot;even&quot; style is the</span>
<span class="sd">            default with an unaltered reflection around the edge value.  For</span>
<span class="sd">            the &quot;odd&quot; style, the extended part of the array is created by</span>
<span class="sd">            subtracting the reflected values from two times the edge value.</span>
<span class="sd">        **pad_width_kwargs</span>
<span class="sd">            The keyword arguments form of ``pad_width``.</span>
<span class="sd">            One of ``pad_width`` or ``pad_width_kwargs`` must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        padded : Dataset</span>
<span class="sd">            Dataset with the padded coordinates and data.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.shift, Dataset.roll, Dataset.bfill, Dataset.ffill, numpy.pad, dask.array.pad</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        By default when ``mode=&quot;constant&quot;`` and ``constant_values=None``, integer types will be</span>
<span class="sd">        promoted to ``float`` and padded with ``np.nan``. To avoid type promotion</span>
<span class="sd">        specify ``constant_values=np.nan``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;foo&quot;: (&quot;x&quot;, range(5))})</span>
<span class="sd">        &gt;&gt;&gt; ds.pad(x=(1, 2))</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 8)</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (x) float64 nan 0.0 1.0 2.0 3.0 4.0 nan nan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pad_width</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">pad_width_kwargs</span><span class="p">,</span> <span class="s2">&quot;pad&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;edge&quot;</span><span class="p">,</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span> <span class="s2">&quot;symmetric&quot;</span><span class="p">,</span> <span class="s2">&quot;wrap&quot;</span><span class="p">):</span>
            <span class="n">coord_pad_mode</span> <span class="o">=</span> <span class="n">mode</span>
            <span class="n">coord_pad_options</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;stat_length&quot;</span><span class="p">:</span> <span class="n">stat_length</span><span class="p">,</span>
                <span class="s2">&quot;constant_values&quot;</span><span class="p">:</span> <span class="n">constant_values</span><span class="p">,</span>
                <span class="s2">&quot;end_values&quot;</span><span class="p">:</span> <span class="n">end_values</span><span class="p">,</span>
                <span class="s2">&quot;reflect_type&quot;</span><span class="p">:</span> <span class="n">reflect_type</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coord_pad_mode</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span>
            <span class="n">coord_pad_options</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">var_pad_width</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pad_width</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">var_pad_width</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                    <span class="n">pad_width</span><span class="o">=</span><span class="n">var_pad_width</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                    <span class="n">stat_length</span><span class="o">=</span><span class="n">stat_length</span><span class="p">,</span>
                    <span class="n">constant_values</span><span class="o">=</span><span class="n">constant_values</span><span class="p">,</span>
                    <span class="n">end_values</span><span class="o">=</span><span class="n">end_values</span><span class="p">,</span>
                    <span class="n">reflect_type</span><span class="o">=</span><span class="n">reflect_type</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                    <span class="n">pad_width</span><span class="o">=</span><span class="n">var_pad_width</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">coord_pad_mode</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">coord_pad_options</span><span class="p">,</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_vars_and_dims</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">idxmin</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
        <span class="n">keep_attrs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the coordinate label of the minimum value along a dimension.</span>

<span class="sd">        Returns a new `Dataset` named after the dimension with the values of</span>
<span class="sd">        the coordinate labels along that dimension corresponding to minimum</span>
<span class="sd">        values along that dimension.</span>

<span class="sd">        In comparison to :py:meth:`~Dataset.argmin`, this returns the</span>
<span class="sd">        coordinate label while :py:meth:`~Dataset.argmin` returns the index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : str, optional</span>
<span class="sd">            Dimension over which to apply `idxmin`.  This is optional for 1D</span>
<span class="sd">            variables, but required for variables with 2 or more dimensions.</span>
<span class="sd">        skipna : bool or None, default: None</span>
<span class="sd">            If True, skip missing values (as marked by NaN). By default, only</span>
<span class="sd">            skips missing values for ``float``, ``complex``, and ``object``</span>
<span class="sd">            dtypes; other dtypes either do not have a sentinel missing value</span>
<span class="sd">            (``int``) or ``skipna=True`` has not been implemented</span>
<span class="sd">            (``datetime64`` or ``timedelta64``).</span>
<span class="sd">        fill_value : Any, default: NaN</span>
<span class="sd">            Value to be filled in case all of the values along a dimension are</span>
<span class="sd">            null.  By default this is NaN.  The fill value and result are</span>
<span class="sd">            automatically converted to a compatible dtype if possible.</span>
<span class="sd">            Ignored if ``skipna`` is False.</span>
<span class="sd">        keep_attrs : bool, default: False</span>
<span class="sd">            If True, the attributes (``attrs``) will be copied from the</span>
<span class="sd">            original object to the new one.  If False (default), the new object</span>
<span class="sd">            will be returned without attributes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reduced : Dataset</span>
<span class="sd">            New `Dataset` object with `idxmin` applied to its data and the</span>
<span class="sd">            indicated dimension removed.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.idxmin, Dataset.idxmax, Dataset.min, Dataset.argmin</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; array1 = xr.DataArray(</span>
<span class="sd">        ...     [0, 2, 1, 0, -2], dims=&quot;x&quot;, coords={&quot;x&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]}</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; array2 = xr.DataArray(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         [2.0, 1.0, 2.0, 0.0, -2.0],</span>
<span class="sd">        ...         [-4.0, np.NaN, 2.0, np.NaN, -2.0],</span>
<span class="sd">        ...         [np.NaN, np.NaN, 1.0, np.NaN, np.NaN],</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     dims=[&quot;y&quot;, &quot;x&quot;],</span>
<span class="sd">        ...     coords={&quot;y&quot;: [-1, 0, 1], &quot;x&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;int&quot;: array1, &quot;float&quot;: array2})</span>
<span class="sd">        &gt;&gt;&gt; ds.min(dim=&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) int64 -1 0 1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            int      int64 -2</span>
<span class="sd">            float    (y) float64 -2.0 -4.0 1.0</span>
<span class="sd">        &gt;&gt;&gt; ds.argmin(dim=&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) int64 -1 0 1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            int      int64 4</span>
<span class="sd">            float    (y) int64 4 0 2</span>
<span class="sd">        &gt;&gt;&gt; ds.idxmin(dim=&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) int64 -1 0 1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            int      &lt;U1 &#39;e&#39;</span>
<span class="sd">            float    (y) object &#39;e&#39; &#39;a&#39; &#39;c&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="n">methodcaller</span><span class="p">(</span>
                <span class="s2">&quot;idxmin&quot;</span><span class="p">,</span>
                <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span>
                <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="n">keep_attrs</span><span class="o">=</span><span class="n">keep_attrs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">idxmax</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
        <span class="n">keep_attrs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the coordinate label of the maximum value along a dimension.</span>

<span class="sd">        Returns a new `Dataset` named after the dimension with the values of</span>
<span class="sd">        the coordinate labels along that dimension corresponding to maximum</span>
<span class="sd">        values along that dimension.</span>

<span class="sd">        In comparison to :py:meth:`~Dataset.argmax`, this returns the</span>
<span class="sd">        coordinate label while :py:meth:`~Dataset.argmax` returns the index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : str, optional</span>
<span class="sd">            Dimension over which to apply `idxmax`.  This is optional for 1D</span>
<span class="sd">            variables, but required for variables with 2 or more dimensions.</span>
<span class="sd">        skipna : bool or None, default: None</span>
<span class="sd">            If True, skip missing values (as marked by NaN). By default, only</span>
<span class="sd">            skips missing values for ``float``, ``complex``, and ``object``</span>
<span class="sd">            dtypes; other dtypes either do not have a sentinel missing value</span>
<span class="sd">            (``int``) or ``skipna=True`` has not been implemented</span>
<span class="sd">            (``datetime64`` or ``timedelta64``).</span>
<span class="sd">        fill_value : Any, default: NaN</span>
<span class="sd">            Value to be filled in case all of the values along a dimension are</span>
<span class="sd">            null.  By default this is NaN.  The fill value and result are</span>
<span class="sd">            automatically converted to a compatible dtype if possible.</span>
<span class="sd">            Ignored if ``skipna`` is False.</span>
<span class="sd">        keep_attrs : bool, default: False</span>
<span class="sd">            If True, the attributes (``attrs``) will be copied from the</span>
<span class="sd">            original object to the new one.  If False (default), the new object</span>
<span class="sd">            will be returned without attributes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reduced : Dataset</span>
<span class="sd">            New `Dataset` object with `idxmax` applied to its data and the</span>
<span class="sd">            indicated dimension removed.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.idxmax, Dataset.idxmin, Dataset.max, Dataset.argmax</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; array1 = xr.DataArray(</span>
<span class="sd">        ...     [0, 2, 1, 0, -2], dims=&quot;x&quot;, coords={&quot;x&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]}</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; array2 = xr.DataArray(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         [2.0, 1.0, 2.0, 0.0, -2.0],</span>
<span class="sd">        ...         [-4.0, np.NaN, 2.0, np.NaN, -2.0],</span>
<span class="sd">        ...         [np.NaN, np.NaN, 1.0, np.NaN, np.NaN],</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     dims=[&quot;y&quot;, &quot;x&quot;],</span>
<span class="sd">        ...     coords={&quot;y&quot;: [-1, 0, 1], &quot;x&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;int&quot;: array1, &quot;float&quot;: array2})</span>
<span class="sd">        &gt;&gt;&gt; ds.max(dim=&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) int64 -1 0 1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            int      int64 2</span>
<span class="sd">            float    (y) float64 2.0 2.0 1.0</span>
<span class="sd">        &gt;&gt;&gt; ds.argmax(dim=&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) int64 -1 0 1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            int      int64 1</span>
<span class="sd">            float    (y) int64 0 2 2</span>
<span class="sd">        &gt;&gt;&gt; ds.idxmax(dim=&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) int64 -1 0 1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            int      &lt;U1 &#39;b&#39;</span>
<span class="sd">            float    (y) object &#39;a&#39; &#39;c&#39; &#39;c&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="n">methodcaller</span><span class="p">(</span>
                <span class="s2">&quot;idxmax&quot;</span><span class="p">,</span>
                <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span>
                <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="n">keep_attrs</span><span class="o">=</span><span class="n">keep_attrs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Indices of the minima of the member variables.</span>

<span class="sd">        If there are multiple minima, the indices of the first one found will be</span>
<span class="sd">        returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : str, optional</span>
<span class="sd">            The dimension over which to find the minimum. By default, finds minimum over</span>
<span class="sd">            all dimensions - for now returning an int for backward compatibility, but</span>
<span class="sd">            this is deprecated, in future will be an error, since DataArray.argmin will</span>
<span class="sd">            return a dict with indices for all dimensions, which does not make sense for</span>
<span class="sd">            a Dataset.</span>
<span class="sd">        keep_attrs : bool, optional</span>
<span class="sd">            If True, the attributes (`attrs`) will be copied from the original</span>
<span class="sd">            object to the new one.  If False (default), the new object will be</span>
<span class="sd">            returned without attributes.</span>
<span class="sd">        skipna : bool, optional</span>
<span class="sd">            If True, skip missing values (as marked by NaN). By default, only</span>
<span class="sd">            skips missing values for float dtypes; other dtypes either do not</span>
<span class="sd">            have a sentinel missing value (int) or skipna=True has not been</span>
<span class="sd">            implemented (object, datetime64 or timedelta64).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : Dataset</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.argmin</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Once the behaviour of DataArray.argmin() and Variable.argmin() without &quot;</span>
                <span class="s2">&quot;dim changes to return a dict of indices of each dimension, for &quot;</span>
                <span class="s2">&quot;consistency it will be an error to call Dataset.argmin() with no argument,&quot;</span>
                <span class="s2">&quot;since we don&#39;t return a dict of Datasets.&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="o">...</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># Return int index if single dimension is passed, and is not part of a</span>
            <span class="c1"># sequence</span>
            <span class="n">argmin_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">duck_array_ops</span><span class="p">,</span> <span class="s2">&quot;argmin&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">argmin_func</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;When dim is a sequence or ..., DataArray.argmin() returns a dict. &quot;</span>
                <span class="s2">&quot;dicts cannot be contained in a Dataset, so cannot call &quot;</span>
                <span class="s2">&quot;Dataset.argmin() with a sequence or ... for dim&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Indices of the maxima of the member variables.</span>

<span class="sd">        If there are multiple maxima, the indices of the first one found will be</span>
<span class="sd">        returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : str, optional</span>
<span class="sd">            The dimension over which to find the maximum. By default, finds maximum over</span>
<span class="sd">            all dimensions - for now returning an int for backward compatibility, but</span>
<span class="sd">            this is deprecated, in future will be an error, since DataArray.argmax will</span>
<span class="sd">            return a dict with indices for all dimensions, which does not make sense for</span>
<span class="sd">            a Dataset.</span>
<span class="sd">        keep_attrs : bool, optional</span>
<span class="sd">            If True, the attributes (`attrs`) will be copied from the original</span>
<span class="sd">            object to the new one.  If False (default), the new object will be</span>
<span class="sd">            returned without attributes.</span>
<span class="sd">        skipna : bool, optional</span>
<span class="sd">            If True, skip missing values (as marked by NaN). By default, only</span>
<span class="sd">            skips missing values for float dtypes; other dtypes either do not</span>
<span class="sd">            have a sentinel missing value (int) or skipna=True has not been</span>
<span class="sd">            implemented (object, datetime64 or timedelta64).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : Dataset</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.argmax</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Once the behaviour of DataArray.argmin() and Variable.argmin() without &quot;</span>
                <span class="s2">&quot;dim changes to return a dict of indices of each dimension, for &quot;</span>
                <span class="s2">&quot;consistency it will be an error to call Dataset.argmin() with no argument,&quot;</span>
                <span class="s2">&quot;since we don&#39;t return a dict of Datasets.&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="o">...</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># Return int index if single dimension is passed, and is not part of a</span>
            <span class="c1"># sequence</span>
            <span class="n">argmax_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">duck_array_ops</span><span class="p">,</span> <span class="s2">&quot;argmax&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">argmax_func</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;When dim is a sequence or ..., DataArray.argmin() returns a dict. &quot;</span>
                <span class="s2">&quot;dicts cannot be contained in a Dataset, so cannot call &quot;</span>
                <span class="s2">&quot;Dataset.argmin() with a sequence or ... for dim&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">queries</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parser</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pandas&quot;</span><span class="p">,</span>
        <span class="n">engine</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">missing_dims</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">queries_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new dataset with each array indexed along the specified</span>
<span class="sd">        dimension(s), where the indexers are given as strings containing</span>
<span class="sd">        Python expressions to be evaluated against the data variables in the</span>
<span class="sd">        dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        queries : dict, optional</span>
<span class="sd">            A dict with keys matching dimensions and values given by strings</span>
<span class="sd">            containing Python expressions to be evaluated against the data variables</span>
<span class="sd">            in the dataset. The expressions will be evaluated using the pandas</span>
<span class="sd">            eval() function, and can contain any valid Python expressions but cannot</span>
<span class="sd">            contain any Python statements.</span>
<span class="sd">        parser : {&quot;pandas&quot;, &quot;python&quot;}, default: &quot;pandas&quot;</span>
<span class="sd">            The parser to use to construct the syntax tree from the expression.</span>
<span class="sd">            The default of &#39;pandas&#39; parses code slightly different than standard</span>
<span class="sd">            Python. Alternatively, you can parse an expression using the &#39;python&#39;</span>
<span class="sd">            parser to retain strict Python semantics.</span>
<span class="sd">        engine : {&quot;python&quot;, &quot;numexpr&quot;, None}, default: None</span>
<span class="sd">            The engine used to evaluate the expression. Supported engines are:</span>

<span class="sd">            - None: tries to use numexpr, falls back to python</span>
<span class="sd">            - &quot;numexpr&quot;: evaluates expressions using numexpr</span>
<span class="sd">            - &quot;python&quot;: performs operations as if you had eval’d in top level python</span>

<span class="sd">        missing_dims : {&quot;raise&quot;, &quot;warn&quot;, &quot;ignore&quot;}, default: &quot;raise&quot;</span>
<span class="sd">            What to do if dimensions that should be selected from are not present in the</span>
<span class="sd">            Dataset:</span>

<span class="sd">            - &quot;raise&quot;: raise an exception</span>
<span class="sd">            - &quot;warning&quot;: raise a warning, and ignore the missing dimensions</span>
<span class="sd">            - &quot;ignore&quot;: ignore the missing dimensions</span>

<span class="sd">        **queries_kwargs : {dim: query, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``queries``.</span>
<span class="sd">            One of queries or queries_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : Dataset</span>
<span class="sd">            A new Dataset with the same contents as this dataset, except each</span>
<span class="sd">            array and dimension is indexed by the results of the appropriate</span>
<span class="sd">            queries.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.isel</span>
<span class="sd">        pandas.eval</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; a = np.arange(0, 5, 1)</span>
<span class="sd">        &gt;&gt;&gt; b = np.linspace(0, 1, 5)</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;a&quot;: (&quot;x&quot;, a), &quot;b&quot;: (&quot;x&quot;, b)})</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 5)</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) int64 0 1 2 3 4</span>
<span class="sd">            b        (x) float64 0.0 0.25 0.5 0.75 1.0</span>
<span class="sd">        &gt;&gt;&gt; ds.query(x=&quot;a &gt; 2&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 2)</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) int64 3 4</span>
<span class="sd">            b        (x) float64 0.75 1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># allow queries to be given either as a dict or as kwargs</span>
        <span class="n">queries</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="n">queries_kwargs</span><span class="p">,</span> <span class="s2">&quot;query&quot;</span><span class="p">)</span>

        <span class="c1"># check queries</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">queries</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;expr for dim </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> must be a string to be evaluated, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="si">}</span><span class="s2"> given&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># evaluate the queries to create the indexers</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">dim</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">resolvers</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">],</span> <span class="n">parser</span><span class="o">=</span><span class="n">parser</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">queries</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1"># apply the selection</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">missing_dims</span><span class="o">=</span><span class="n">missing_dims</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">curvefit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coords</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">DataArray</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="n">DataArray</span><span class="p">],</span>
        <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">reduce_dims</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">p0</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bounds</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">param_names</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Curve fitting optimization for arbitrary functions.</span>

<span class="sd">        Wraps `scipy.optimize.curve_fit` with `apply_ufunc`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords : hashable, DataArray, or sequence of hashable or DataArray</span>
<span class="sd">            Independent coordinate(s) over which to perform the curve fitting. Must share</span>
<span class="sd">            at least one dimension with the calling object. When fitting multi-dimensional</span>
<span class="sd">            functions, supply `coords` as a sequence in the same order as arguments in</span>
<span class="sd">            `func`. To fit along existing dimensions of the calling object, `coords` can</span>
<span class="sd">            also be specified as a str or sequence of strs.</span>
<span class="sd">        func : callable</span>
<span class="sd">            User specified function in the form `f(x, *params)` which returns a numpy</span>
<span class="sd">            array of length `len(x)`. `params` are the fittable parameters which are optimized</span>
<span class="sd">            by scipy curve_fit. `x` can also be specified as a sequence containing multiple</span>
<span class="sd">            coordinates, e.g. `f((x0, x1), *params)`.</span>
<span class="sd">        reduce_dims : hashable or sequence of hashable</span>
<span class="sd">            Additional dimension(s) over which to aggregate while fitting. For example,</span>
<span class="sd">            calling `ds.curvefit(coords=&#39;time&#39;, reduce_dims=[&#39;lat&#39;, &#39;lon&#39;], ...)` will</span>
<span class="sd">            aggregate all lat and lon points and fit the specified function along the</span>
<span class="sd">            time dimension.</span>
<span class="sd">        skipna : bool, optional</span>
<span class="sd">            Whether to skip missing values when fitting. Default is True.</span>
<span class="sd">        p0 : dict-like, optional</span>
<span class="sd">            Optional dictionary of parameter names to initial guesses passed to the</span>
<span class="sd">            `curve_fit` `p0` arg. If none or only some parameters are passed, the rest will</span>
<span class="sd">            be assigned initial values following the default scipy behavior.</span>
<span class="sd">        bounds : dict-like, optional</span>
<span class="sd">            Optional dictionary of parameter names to bounding values passed to the</span>
<span class="sd">            `curve_fit` `bounds` arg. If none or only some parameters are passed, the rest</span>
<span class="sd">            will be unbounded following the default scipy behavior.</span>
<span class="sd">        param_names : sequence of hashable, optional</span>
<span class="sd">            Sequence of names for the fittable parameters of `func`. If not supplied,</span>
<span class="sd">            this will be automatically determined by arguments of `func`. `param_names`</span>
<span class="sd">            should be manually supplied when fitting a function that takes a variable</span>
<span class="sd">            number of parameters.</span>
<span class="sd">        **kwargs : optional</span>
<span class="sd">            Additional keyword arguments to passed to scipy curve_fit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        curvefit_results : Dataset</span>
<span class="sd">            A single dataset which contains:</span>

<span class="sd">            [var]_curvefit_coefficients</span>
<span class="sd">                The coefficients of the best fit.</span>
<span class="sd">            [var]_curvefit_covariance</span>
<span class="sd">                The covariance matrix of the coefficient estimates.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.polyfit</span>
<span class="sd">        scipy.optimize.curve_fit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>

        <span class="k">if</span> <span class="n">p0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">reduce_dims</span><span class="p">:</span>
            <span class="n">reduce_dims_</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reduce_dims</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reduce_dims</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">reduce_dims_</span> <span class="o">=</span> <span class="p">[</span><span class="n">reduce_dims</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reduce_dims_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">reduce_dims</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)</span>
            <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">]</span>
        <span class="n">coords_</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">coord</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">]</span>

        <span class="c1"># Determine whether any coords are dims on self</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords_</span><span class="p">:</span>
            <span class="n">reduce_dims_</span> <span class="o">+=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">c</span><span class="p">])]</span>
        <span class="n">reduce_dims_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">reduce_dims_</span><span class="p">))</span>
        <span class="n">preserved_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">reduce_dims_</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">reduce_dims_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No arguments to `coords` were identified as a dimension on the calling &quot;</span>
                <span class="s2">&quot;object, and no dims were supplied to `reduce_dims`. This would result &quot;</span>
                <span class="s2">&quot;in fitting on scalar data.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Broadcast all coords with each other</span>
        <span class="n">coords_</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="o">*</span><span class="n">coords_</span><span class="p">)</span>
        <span class="n">coords_</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">coord</span><span class="o">.</span><span class="n">broadcast_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">preserved_dims</span><span class="p">)</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords_</span>
        <span class="p">]</span>

        <span class="n">params</span><span class="p">,</span> <span class="n">func_args</span> <span class="o">=</span> <span class="n">_get_func_args</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">param_names</span><span class="p">)</span>
        <span class="n">param_defaults</span><span class="p">,</span> <span class="n">bounds_defaults</span> <span class="o">=</span> <span class="n">_initialize_curvefit_params</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">func_args</span>
        <span class="p">)</span>
        <span class="n">n_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;p0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">param_defaults</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">])</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
            <span class="s2">&quot;bounds&quot;</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="n">bounds_defaults</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">],</span>
                <span class="p">[</span><span class="n">bounds_defaults</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">],</span>
            <span class="p">],</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">_wrapper</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="o">*</span><span class="n">coords_</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># Wrap curve_fit with raveled coordinates and pointwise NaN handling</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords_</span><span class="p">])</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">skipna</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                    <span class="n">popt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="n">n_params</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                    <span class="n">pcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="n">n_params</span><span class="p">,</span> <span class="n">n_params</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">da</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="n">xr</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">dataarray</span><span class="o">.</span><span class="n">_THIS_ARRAY</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">_&quot;</span>

            <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">_wrapper</span><span class="p">,</span>
                <span class="n">da</span><span class="p">,</span>
                <span class="o">*</span><span class="n">coords_</span><span class="p">,</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span><span class="n">reduce_dims_</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords_</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[[</span><span class="s2">&quot;param&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;cov_i&quot;</span><span class="p">,</span> <span class="s2">&quot;cov_j&quot;</span><span class="p">]],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s2">&quot;param&quot;</span><span class="p">:</span> <span class="n">n_params</span><span class="p">,</span>
                        <span class="s2">&quot;cov_i&quot;</span><span class="p">:</span> <span class="n">n_params</span><span class="p">,</span>
                        <span class="s2">&quot;cov_j&quot;</span><span class="p">:</span> <span class="n">n_params</span><span class="p">,</span>
                    <span class="p">},</span>
                <span class="p">},</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                <span class="n">exclude_dims</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">reduce_dims_</span><span class="p">),</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">result</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;curvefit_coefficients&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">popt</span>
            <span class="n">result</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;curvefit_covariance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcov</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;param&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">,</span> <span class="s2">&quot;cov_i&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">,</span> <span class="s2">&quot;cov_j&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">drop_duplicates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">keep</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="s2">&quot;last&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a new Dataset with duplicate dimension values removed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : dimension label or labels</span>
<span class="sd">            Pass `...` to drop duplicates along all dimensions.</span>
<span class="sd">        keep : {&quot;first&quot;, &quot;last&quot;, False}, default: &quot;first&quot;</span>
<span class="sd">            Determines which duplicates (if any) to keep.</span>
<span class="sd">            - ``&quot;first&quot;`` : Drop duplicates except for the first occurrence.</span>
<span class="sd">            - ``&quot;last&quot;`` : Drop duplicates except for the last occurrence.</span>
<span class="sd">            - False : Drop all duplicates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.drop_duplicates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">dim</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="ow">is</span> <span class="o">...</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="n">dim</span>

        <span class="n">missing_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">missing_dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">missing_dims</span><span class="si">}</span><span class="s2">&#39; not found in dimensions&quot;</span><span class="p">)</span>

        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convert_calendar</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">calendar</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span>
        <span class="n">align_on</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">missing</span><span class="p">:</span> <span class="n">Any</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_cftime</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convert the Dataset to another calendar.</span>

<span class="sd">        Only converts the individual timestamps, does not modify any data except</span>
<span class="sd">        in dropping invalid/surplus dates or inserting missing dates.</span>

<span class="sd">        If the source and target calendars are either no_leap, all_leap or a</span>
<span class="sd">        standard type, only the type of the time array is modified.</span>
<span class="sd">        When converting to a leap year from a non-leap year, the 29th of February</span>
<span class="sd">        is removed from the array. In the other direction the 29th of February</span>
<span class="sd">        will be missing in the output, unless `missing` is specified,</span>
<span class="sd">        in which case that value is inserted.</span>

<span class="sd">        For conversions involving `360_day` calendars, see Notes.</span>

<span class="sd">        This method is safe to use with sub-daily data as it doesn&#39;t touch the</span>
<span class="sd">        time part of the timestamps.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        calendar : str</span>
<span class="sd">            The target calendar name.</span>
<span class="sd">        dim : str</span>
<span class="sd">            Name of the time coordinate.</span>
<span class="sd">        align_on : {None, &#39;date&#39;, &#39;year&#39;}</span>
<span class="sd">            Must be specified when either source or target is a `360_day` calendar,</span>
<span class="sd">            ignored otherwise. See Notes.</span>
<span class="sd">        missing : Optional[any]</span>
<span class="sd">            By default, i.e. if the value is None, this method will simply attempt</span>
<span class="sd">            to convert the dates in the source calendar to the same dates in the</span>
<span class="sd">            target calendar, and drop any of those that are not possible to</span>
<span class="sd">            represent.  If a value is provided, a new time coordinate will be</span>
<span class="sd">            created in the target calendar with the same frequency as the original</span>
<span class="sd">            time coordinate; for any dates that are not present in the source, the</span>
<span class="sd">            data will be filled with this value.  Note that using this mode requires</span>
<span class="sd">            that the source data have an inferable frequency; for more information</span>
<span class="sd">            see :py:func:`xarray.infer_freq`.  For certain frequency, source, and</span>
<span class="sd">            target calendar combinations, this could result in many missing values, see notes.</span>
<span class="sd">        use_cftime : boolean, optional</span>
<span class="sd">            Whether to use cftime objects in the output, only used if `calendar`</span>
<span class="sd">            is one of {&quot;proleptic_gregorian&quot;, &quot;gregorian&quot; or &quot;standard&quot;}.</span>
<span class="sd">            If True, the new time axis uses cftime objects.</span>
<span class="sd">            If None (default), it uses :py:class:`numpy.datetime64` values if the</span>
<span class="sd">            date range permits it, and :py:class:`cftime.datetime` objects if not.</span>
<span class="sd">            If False, it uses :py:class:`numpy.datetime64`  or fails.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset</span>
<span class="sd">            Copy of the dataarray with the time coordinate converted to the</span>
<span class="sd">            target calendar. If &#39;missing&#39; was None (default), invalid dates in</span>
<span class="sd">            the new calendar are dropped, but missing dates are not inserted.</span>
<span class="sd">            If `missing` was given, the new data is reindexed to have a time axis</span>
<span class="sd">            with the same frequency as the source, but in the new calendar; any</span>
<span class="sd">            missing datapoints are filled with `missing`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Passing a value to `missing` is only usable if the source&#39;s time coordinate as an</span>
<span class="sd">        inferrable frequencies (see :py:func:`~xarray.infer_freq`) and is only appropriate</span>
<span class="sd">        if the target coordinate, generated from this frequency, has dates equivalent to the</span>
<span class="sd">        source. It is usually **not** appropriate to use this mode with:</span>

<span class="sd">        - Period-end frequencies : &#39;A&#39;, &#39;Y&#39;, &#39;Q&#39; or &#39;M&#39;, in opposition to &#39;AS&#39; &#39;YS&#39;, &#39;QS&#39; and &#39;MS&#39;</span>
<span class="sd">        - Sub-monthly frequencies that do not divide a day evenly : &#39;W&#39;, &#39;nD&#39; where `N != 1`</span>
<span class="sd">            or &#39;mH&#39; where 24 % m != 0).</span>

<span class="sd">        If one of the source or target calendars is `&quot;360_day&quot;`, `align_on` must</span>
<span class="sd">        be specified and two options are offered.</span>

<span class="sd">        - &quot;year&quot;</span>
<span class="sd">            The dates are translated according to their relative position in the year,</span>
<span class="sd">            ignoring their original month and day information, meaning that the</span>
<span class="sd">            missing/surplus days are added/removed at regular intervals.</span>

<span class="sd">            From a `360_day` to a standard calendar, the output will be missing the</span>
<span class="sd">            following dates (day of year in parentheses):</span>

<span class="sd">            To a leap year:</span>
<span class="sd">                January 31st (31), March 31st (91), June 1st (153), July 31st (213),</span>
<span class="sd">                September 31st (275) and November 30th (335).</span>
<span class="sd">            To a non-leap year:</span>
<span class="sd">                February 6th (36), April 19th (109), July 2nd (183),</span>
<span class="sd">                September 12th (255), November 25th (329).</span>

<span class="sd">            From a standard calendar to a `&quot;360_day&quot;`, the following dates in the</span>
<span class="sd">            source array will be dropped:</span>

<span class="sd">            From a leap year:</span>
<span class="sd">                January 31st (31), April 1st (92), June 1st (153), August 1st (214),</span>
<span class="sd">                September 31st (275), December 1st (336)</span>
<span class="sd">            From a non-leap year:</span>
<span class="sd">                February 6th (37), April 20th (110), July 2nd (183),</span>
<span class="sd">                September 13th (256), November 25th (329)</span>

<span class="sd">            This option is best used on daily and subdaily data.</span>

<span class="sd">        - &quot;date&quot;</span>
<span class="sd">            The month/day information is conserved and invalid dates are dropped</span>
<span class="sd">            from the output. This means that when converting from a `&quot;360_day&quot;` to a</span>
<span class="sd">            standard calendar, all 31st (Jan, March, May, July, August, October and</span>
<span class="sd">            December) will be missing as there is no equivalent dates in the</span>
<span class="sd">            `&quot;360_day&quot;` calendar and the 29th (on non-leap years) and 30th of February</span>
<span class="sd">            will be dropped as there are no equivalent dates in a standard calendar.</span>

<span class="sd">            This option is best used with data on a frequency coarser than daily.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">convert_calendar</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">calendar</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span>
            <span class="n">align_on</span><span class="o">=</span><span class="n">align_on</span><span class="p">,</span>
            <span class="n">missing</span><span class="o">=</span><span class="n">missing</span><span class="p">,</span>
            <span class="n">use_cftime</span><span class="o">=</span><span class="n">use_cftime</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">interp_calendar</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span> <span class="o">|</span> <span class="n">CFTimeIndex</span> <span class="o">|</span> <span class="n">DataArray</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Interpolates the Dataset to another calendar based on decimal year measure.</span>

<span class="sd">        Each timestamp in `source` and `target` are first converted to their decimal</span>
<span class="sd">        year equivalent then `source` is interpolated on the target coordinate.</span>
<span class="sd">        The decimal year of a timestamp is its year plus its sub-year component</span>
<span class="sd">        converted to the fraction of its year. For example &quot;2000-03-01 12:00&quot; is</span>
<span class="sd">        2000.1653 in a standard calendar or 2000.16301 in a `&quot;noleap&quot;` calendar.</span>

<span class="sd">        This method should only be used when the time (HH:MM:SS) information of</span>
<span class="sd">        time coordinate is not important.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target: DataArray or DatetimeIndex or CFTimeIndex</span>
<span class="sd">            The target time coordinate of a valid dtype</span>
<span class="sd">            (np.datetime64 or cftime objects)</span>
<span class="sd">        dim : str</span>
<span class="sd">            The time coordinate name.</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        DataArray</span>
<span class="sd">            The source interpolated on the decimal years of target,</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">interp_calendar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span></div>
</pre></div>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Jeffrey Newman<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>