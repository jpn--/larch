# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""Larch can be used to estimate discrete choice models."""


from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_core', [dirname(__file__)])
        except ImportError:
            import _core
            return _core
        if fp is not None:
            try:
                _mod = imp.load_module('_core', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _core = swig_import_helper()
    del swig_import_helper
else:
    import _core
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except Exception:
    weakref_proxy = lambda x: x




def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)



from ._core import LarchError
from ._core import SQLiteError
from ._core import FacetError
from ._core import LarchCacheError
from ._core import ProvisioningError
from ._core import MatrixInverseError

class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _core.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _core.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _core.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _core.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _core.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _core.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _core.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _core.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _core.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _core.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _core.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _core.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _core.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _core.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _core.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _core.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _core.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _core.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


_core.SHARED_PTR_DISOWN_swigconstant(_core)
SHARED_PTR_DISOWN = _core.SHARED_PTR_DISOWN

import numpy
__default_array_type__ = numpy.ndarray



class IntVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.IntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.IntVector___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _core.IntVector___len__(self)

    def __getslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "std::vector< int,std::allocator< int > > *":
        return _core.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.IntVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "void":
        return _core.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.IntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _core.IntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.IntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _core.IntVector_pop(self)

    def append(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _core.IntVector_append(self, x)

    def empty(self) -> "bool":
        return _core.IntVector_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _core.IntVector_size(self)

    def swap(self, v: 'IntVector') -> "void":
        return _core.IntVector_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _core.IntVector_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _core.IntVector_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _core.IntVector_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _core.IntVector_rend(self)

    def clear(self) -> "void":
        return _core.IntVector_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _core.IntVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.IntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _core.IntVector_erase(self, *args)

    def __init__(self, *args):
        this = _core.new_IntVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _core.IntVector_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _core.IntVector_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _core.IntVector_back(self)

    def assign(self, n: 'std::vector< int >::size_type', x: 'std::vector< int >::value_type const &') -> "void":
        return _core.IntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.IntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.IntVector_insert(self, *args)

    def reserve(self, n: 'std::vector< int >::size_type') -> "void":
        return _core.IntVector_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _core.IntVector_capacity(self)
    __swig_destroy__ = _core.delete_IntVector
    __del__ = lambda self: None
IntVector_swigregister = _core.IntVector_swigregister
IntVector_swigregister(IntVector)

class DoubleVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.DoubleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.DoubleVector___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _core.DoubleVector___len__(self)

    def __getslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "std::vector< double,std::allocator< double > > *":
        return _core.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "void":
        return _core.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _core.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.DoubleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _core.DoubleVector_pop(self)

    def append(self, x: 'std::vector< double >::value_type const &') -> "void":
        return _core.DoubleVector_append(self, x)

    def empty(self) -> "bool":
        return _core.DoubleVector_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _core.DoubleVector_size(self)

    def swap(self, v: 'DoubleVector') -> "void":
        return _core.DoubleVector_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _core.DoubleVector_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _core.DoubleVector_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _core.DoubleVector_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _core.DoubleVector_rend(self)

    def clear(self) -> "void":
        return _core.DoubleVector_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _core.DoubleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.DoubleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _core.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        this = _core.new_DoubleVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< double >::value_type const &') -> "void":
        return _core.DoubleVector_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _core.DoubleVector_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _core.DoubleVector_back(self)

    def assign(self, n: 'std::vector< double >::size_type', x: 'std::vector< double >::value_type const &') -> "void":
        return _core.DoubleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.DoubleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.DoubleVector_insert(self, *args)

    def reserve(self, n: 'std::vector< double >::size_type') -> "void":
        return _core.DoubleVector_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _core.DoubleVector_capacity(self)
    __swig_destroy__ = _core.delete_DoubleVector
    __del__ = lambda self: None
DoubleVector_swigregister = _core.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class ULongLongVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.ULongLongVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.ULongLongVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.ULongLongVector___bool__(self)

    def __len__(self) -> "std::vector< unsigned long long >::size_type":
        return _core.ULongLongVector___len__(self)

    def __getslice__(self, i: 'std::vector< unsigned long long >::difference_type', j: 'std::vector< unsigned long long >::difference_type') -> "std::vector< unsigned long long,std::allocator< unsigned long long > > *":
        return _core.ULongLongVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.ULongLongVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< unsigned long long >::difference_type', j: 'std::vector< unsigned long long >::difference_type') -> "void":
        return _core.ULongLongVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.ULongLongVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned long long >::value_type const &":
        return _core.ULongLongVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.ULongLongVector___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned long long >::value_type":
        return _core.ULongLongVector_pop(self)

    def append(self, x: 'std::vector< unsigned long long >::value_type const &') -> "void":
        return _core.ULongLongVector_append(self, x)

    def empty(self) -> "bool":
        return _core.ULongLongVector_empty(self)

    def size(self) -> "std::vector< unsigned long long >::size_type":
        return _core.ULongLongVector_size(self)

    def swap(self, v: 'ULongLongVector') -> "void":
        return _core.ULongLongVector_swap(self, v)

    def begin(self) -> "std::vector< unsigned long long >::iterator":
        return _core.ULongLongVector_begin(self)

    def end(self) -> "std::vector< unsigned long long >::iterator":
        return _core.ULongLongVector_end(self)

    def rbegin(self) -> "std::vector< unsigned long long >::reverse_iterator":
        return _core.ULongLongVector_rbegin(self)

    def rend(self) -> "std::vector< unsigned long long >::reverse_iterator":
        return _core.ULongLongVector_rend(self)

    def clear(self) -> "void":
        return _core.ULongLongVector_clear(self)

    def get_allocator(self) -> "std::vector< unsigned long long >::allocator_type":
        return _core.ULongLongVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.ULongLongVector_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned long long >::iterator":
        return _core.ULongLongVector_erase(self, *args)

    def __init__(self, *args):
        this = _core.new_ULongLongVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< unsigned long long >::value_type const &') -> "void":
        return _core.ULongLongVector_push_back(self, x)

    def front(self) -> "std::vector< unsigned long long >::value_type const &":
        return _core.ULongLongVector_front(self)

    def back(self) -> "std::vector< unsigned long long >::value_type const &":
        return _core.ULongLongVector_back(self)

    def assign(self, n: 'std::vector< unsigned long long >::size_type', x: 'std::vector< unsigned long long >::value_type const &') -> "void":
        return _core.ULongLongVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.ULongLongVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.ULongLongVector_insert(self, *args)

    def reserve(self, n: 'std::vector< unsigned long long >::size_type') -> "void":
        return _core.ULongLongVector_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned long long >::size_type":
        return _core.ULongLongVector_capacity(self)
    __swig_destroy__ = _core.delete_ULongLongVector
    __del__ = lambda self: None
ULongLongVector_swigregister = _core.ULongLongVector_swigregister
ULongLongVector_swigregister(ULongLongVector)

class LongLongVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.LongLongVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.LongLongVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.LongLongVector___bool__(self)

    def __len__(self) -> "std::vector< long long >::size_type":
        return _core.LongLongVector___len__(self)

    def __getslice__(self, i: 'std::vector< long long >::difference_type', j: 'std::vector< long long >::difference_type') -> "std::vector< long long,std::allocator< long long > > *":
        return _core.LongLongVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.LongLongVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< long long >::difference_type', j: 'std::vector< long long >::difference_type') -> "void":
        return _core.LongLongVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.LongLongVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< long long >::value_type const &":
        return _core.LongLongVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.LongLongVector___setitem__(self, *args)

    def pop(self) -> "std::vector< long long >::value_type":
        return _core.LongLongVector_pop(self)

    def append(self, x: 'std::vector< long long >::value_type const &') -> "void":
        return _core.LongLongVector_append(self, x)

    def empty(self) -> "bool":
        return _core.LongLongVector_empty(self)

    def size(self) -> "std::vector< long long >::size_type":
        return _core.LongLongVector_size(self)

    def swap(self, v: 'LongLongVector') -> "void":
        return _core.LongLongVector_swap(self, v)

    def begin(self) -> "std::vector< long long >::iterator":
        return _core.LongLongVector_begin(self)

    def end(self) -> "std::vector< long long >::iterator":
        return _core.LongLongVector_end(self)

    def rbegin(self) -> "std::vector< long long >::reverse_iterator":
        return _core.LongLongVector_rbegin(self)

    def rend(self) -> "std::vector< long long >::reverse_iterator":
        return _core.LongLongVector_rend(self)

    def clear(self) -> "void":
        return _core.LongLongVector_clear(self)

    def get_allocator(self) -> "std::vector< long long >::allocator_type":
        return _core.LongLongVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.LongLongVector_pop_back(self)

    def erase(self, *args) -> "std::vector< long long >::iterator":
        return _core.LongLongVector_erase(self, *args)

    def __init__(self, *args):
        this = _core.new_LongLongVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< long long >::value_type const &') -> "void":
        return _core.LongLongVector_push_back(self, x)

    def front(self) -> "std::vector< long long >::value_type const &":
        return _core.LongLongVector_front(self)

    def back(self) -> "std::vector< long long >::value_type const &":
        return _core.LongLongVector_back(self)

    def assign(self, n: 'std::vector< long long >::size_type', x: 'std::vector< long long >::value_type const &') -> "void":
        return _core.LongLongVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.LongLongVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.LongLongVector_insert(self, *args)

    def reserve(self, n: 'std::vector< long long >::size_type') -> "void":
        return _core.LongLongVector_reserve(self, n)

    def capacity(self) -> "std::vector< long long >::size_type":
        return _core.LongLongVector_capacity(self)
    __swig_destroy__ = _core.delete_LongLongVector
    __del__ = lambda self: None
LongLongVector_swigregister = _core.LongLongVector_swigregister
LongLongVector_swigregister(LongLongVector)

class StrVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.StrVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.StrVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.StrVector___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _core.StrVector___len__(self)

    def __getslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "std::vector< std::string,std::allocator< std::string > > *":
        return _core.StrVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.StrVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "void":
        return _core.StrVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.StrVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _core.StrVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.StrVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _core.StrVector_pop(self)

    def append(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        return _core.StrVector_append(self, x)

    def empty(self) -> "bool":
        return _core.StrVector_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _core.StrVector_size(self)

    def swap(self, v: 'StrVector') -> "void":
        return _core.StrVector_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _core.StrVector_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _core.StrVector_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _core.StrVector_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _core.StrVector_rend(self)

    def clear(self) -> "void":
        return _core.StrVector_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _core.StrVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.StrVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _core.StrVector_erase(self, *args)

    def __init__(self, *args):
        this = _core.new_StrVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        return _core.StrVector_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _core.StrVector_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _core.StrVector_back(self)

    def assign(self, n: 'std::vector< std::string >::size_type', x: 'std::vector< std::string >::value_type const &') -> "void":
        return _core.StrVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.StrVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.StrVector_insert(self, *args)

    def reserve(self, n: 'std::vector< std::string >::size_type') -> "void":
        return _core.StrVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _core.StrVector_capacity(self)
    __swig_destroy__ = _core.delete_StrVector
    __del__ = lambda self: None
StrVector_swigregister = _core.StrVector_swigregister
StrVector_swigregister(StrVector)

class IntStringDict(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.IntStringDict_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.IntStringDict___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.IntStringDict___bool__(self)

    def __len__(self) -> "std::map< long long,std::string >::size_type":
        return _core.IntStringDict___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< long long,std::string >::key_type const &') -> "std::map< long long,std::string >::mapped_type const &":
        return _core.IntStringDict___getitem__(self, key)

    def __delitem__(self, key: 'std::map< long long,std::string >::key_type const &') -> "void":
        return _core.IntStringDict___delitem__(self, key)

    def has_key(self, key: 'std::map< long long,std::string >::key_type const &') -> "bool":
        return _core.IntStringDict_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _core.IntStringDict_keys(self)

    def values(self) -> "PyObject *":
        return _core.IntStringDict_values(self)

    def items(self) -> "PyObject *":
        return _core.IntStringDict_items(self)

    def __contains__(self, key: 'std::map< long long,std::string >::key_type const &') -> "bool":
        return _core.IntStringDict___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _core.IntStringDict_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _core.IntStringDict_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _core.IntStringDict___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _core.IntStringDict_asdict(self)

    def __init__(self, *args):
        this = _core.new_IntStringDict(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self) -> "bool":
        return _core.IntStringDict_empty(self)

    def size(self) -> "std::map< long long,std::string >::size_type":
        return _core.IntStringDict_size(self)

    def swap(self, v: 'IntStringDict') -> "void":
        return _core.IntStringDict_swap(self, v)

    def begin(self) -> "std::map< long long,std::string >::iterator":
        return _core.IntStringDict_begin(self)

    def end(self) -> "std::map< long long,std::string >::iterator":
        return _core.IntStringDict_end(self)

    def rbegin(self) -> "std::map< long long,std::string >::reverse_iterator":
        return _core.IntStringDict_rbegin(self)

    def rend(self) -> "std::map< long long,std::string >::reverse_iterator":
        return _core.IntStringDict_rend(self)

    def clear(self) -> "void":
        return _core.IntStringDict_clear(self)

    def get_allocator(self) -> "std::map< long long,std::string >::allocator_type":
        return _core.IntStringDict_get_allocator(self)

    def count(self, x: 'std::map< long long,std::string >::key_type const &') -> "std::map< long long,std::string >::size_type":
        return _core.IntStringDict_count(self, x)

    def erase(self, *args) -> "void":
        return _core.IntStringDict_erase(self, *args)

    def find(self, x: 'std::map< long long,std::string >::key_type const &') -> "std::map< long long,std::string >::iterator":
        return _core.IntStringDict_find(self, x)

    def lower_bound(self, x: 'std::map< long long,std::string >::key_type const &') -> "std::map< long long,std::string >::iterator":
        return _core.IntStringDict_lower_bound(self, x)

    def upper_bound(self, x: 'std::map< long long,std::string >::key_type const &') -> "std::map< long long,std::string >::iterator":
        return _core.IntStringDict_upper_bound(self, x)

    def __reduce__(self):
    	args = (dict(self), )
    	return self.__class__, args

    __swig_destroy__ = _core.delete_IntStringDict
    __del__ = lambda self: None
IntStringDict_swigregister = _core.IntStringDict_swigregister
IntStringDict_swigregister(IntStringDict)


def set_linalg(mod: 'PyObject *') -> "void":
    return _core.set_linalg(mod)
set_linalg = _core.set_linalg

def _swigtest_empty_dict() -> "PyObject *":
    return _core._swigtest_empty_dict()
_swigtest_empty_dict = _core._swigtest_empty_dict

def _swigtest_alpha_dict() -> "PyObject *":
    return _core._swigtest_alpha_dict()
_swigtest_alpha_dict = _core._swigtest_alpha_dict
class ostream_c(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args):
        this = _core.new_ostream_c(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _core.delete_ostream_c
    __del__ = lambda self: None

    def flush(self) -> "void":
        return _core.ostream_c_flush(self)

    def write(self, x: 'std::string') -> "int":
        return _core.ostream_c_write(self, x)

    def mode(self) -> "std::string":
        return _core.ostream_c_mode(self)

    def __repr__(self) -> "std::string":
        return _core.ostream_c___repr__(self)
ostream_c_swigregister = _core.ostream_c_swigregister
ostream_c_swigregister(ostream_c)

class string_sender(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def write(self, x: 'std::string') -> "void":
        return _core.string_sender_write(self, x)
    __swig_destroy__ = _core.delete_string_sender
    __del__ = lambda self: None
string_sender_swigregister = _core.string_sender_swigregister
string_sender_swigregister(string_sender)

class refcounted(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        this = _core.new_refcounted()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _core.delete_refcounted
    __del__ = lambda self: None

    def incref(self) -> "int":
        return _core.refcounted_incref(self)

    def decref(self) -> "int":
        return _core.refcounted_decref(self)

    def ref_count(self) -> "int":
        return _core.refcounted_ref_count(self)

    def lifeboat(self) -> "void":
        return _core.refcounted_lifeboat(self)
refcounted_swigregister = _core.refcounted_swigregister
refcounted_swigregister(refcounted)


def larch_initialize() -> "void":
    return _core.larch_initialize()
larch_initialize = _core.larch_initialize

def larch_openblas_get_config() -> "char *":
    return _core.larch_openblas_get_config()
larch_openblas_get_config = _core.larch_openblas_get_config

def load_scipy_blas_functions() -> "void":
    return _core.load_scipy_blas_functions()
load_scipy_blas_functions = _core.load_scipy_blas_functions
class OptimizationMethodList(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.OptimizationMethodList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.OptimizationMethodList___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.OptimizationMethodList___bool__(self)

    def __len__(self) -> "std::vector< sherpa_pack >::size_type":
        return _core.OptimizationMethodList___len__(self)

    def __getslice__(self, i: 'std::vector< sherpa_pack >::difference_type', j: 'std::vector< sherpa_pack >::difference_type') -> "std::vector< sherpa_pack,std::allocator< sherpa_pack > > *":
        return _core.OptimizationMethodList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.OptimizationMethodList___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< sherpa_pack >::difference_type', j: 'std::vector< sherpa_pack >::difference_type') -> "void":
        return _core.OptimizationMethodList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.OptimizationMethodList___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< sherpa_pack >::value_type const &":
        return _core.OptimizationMethodList___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.OptimizationMethodList___setitem__(self, *args)

    def pop(self) -> "std::vector< sherpa_pack >::value_type":
        return _core.OptimizationMethodList_pop(self)

    def append(self, x: 'OptimizationMethod') -> "void":
        return _core.OptimizationMethodList_append(self, x)

    def empty(self) -> "bool":
        return _core.OptimizationMethodList_empty(self)

    def size(self) -> "std::vector< sherpa_pack >::size_type":
        return _core.OptimizationMethodList_size(self)

    def swap(self, v: 'OptimizationMethodList') -> "void":
        return _core.OptimizationMethodList_swap(self, v)

    def begin(self) -> "std::vector< sherpa_pack >::iterator":
        return _core.OptimizationMethodList_begin(self)

    def end(self) -> "std::vector< sherpa_pack >::iterator":
        return _core.OptimizationMethodList_end(self)

    def rbegin(self) -> "std::vector< sherpa_pack >::reverse_iterator":
        return _core.OptimizationMethodList_rbegin(self)

    def rend(self) -> "std::vector< sherpa_pack >::reverse_iterator":
        return _core.OptimizationMethodList_rend(self)

    def clear(self) -> "void":
        return _core.OptimizationMethodList_clear(self)

    def get_allocator(self) -> "std::vector< sherpa_pack >::allocator_type":
        return _core.OptimizationMethodList_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.OptimizationMethodList_pop_back(self)

    def erase(self, *args) -> "std::vector< sherpa_pack >::iterator":
        return _core.OptimizationMethodList_erase(self, *args)

    def __init__(self, *args):
        this = _core.new_OptimizationMethodList(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'OptimizationMethod') -> "void":
        return _core.OptimizationMethodList_push_back(self, x)

    def front(self) -> "std::vector< sherpa_pack >::value_type const &":
        return _core.OptimizationMethodList_front(self)

    def back(self) -> "std::vector< sherpa_pack >::value_type const &":
        return _core.OptimizationMethodList_back(self)

    def assign(self, n: 'std::vector< sherpa_pack >::size_type', x: 'OptimizationMethod') -> "void":
        return _core.OptimizationMethodList_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.OptimizationMethodList_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.OptimizationMethodList_insert(self, *args)

    def reserve(self, n: 'std::vector< sherpa_pack >::size_type') -> "void":
        return _core.OptimizationMethodList_reserve(self, n)

    def capacity(self) -> "std::vector< sherpa_pack >::size_type":
        return _core.OptimizationMethodList_capacity(self)
    __swig_destroy__ = _core.delete_OptimizationMethodList
    __del__ = lambda self: None
OptimizationMethodList_swigregister = _core.OptimizationMethodList_swigregister
OptimizationMethodList_swigregister(OptimizationMethodList)

class OptimizationMethod(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        this = _core.new_OptimizationMethod(*args, **kwargs)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _core.delete_OptimizationMethod
    __del__ = lambda self: None
    Min_Step = _swig_property(_core.OptimizationMethod_Min_Step_get, _core.OptimizationMethod_Min_Step_set)
    Max_Step = _swig_property(_core.OptimizationMethod_Max_Step_get, _core.OptimizationMethod_Max_Step_set)
    Step_Extend_Factor = _swig_property(_core.OptimizationMethod_Step_Extend_Factor_get, _core.OptimizationMethod_Step_Extend_Factor_set)
    Step_Retract_Factor = _swig_property(_core.OptimizationMethod_Step_Retract_Factor_get, _core.OptimizationMethod_Step_Retract_Factor_set)
    Initial_Step = _swig_property(_core.OptimizationMethod_Initial_Step_get, _core.OptimizationMethod_Initial_Step_set)
    Honeymoon = _swig_property(_core.OptimizationMethod_Honeymoon_get, _core.OptimizationMethod_Honeymoon_set)
    Patience = _swig_property(_core.OptimizationMethod_Patience_get, _core.OptimizationMethod_Patience_set)
    Max_NumIter = _swig_property(_core.OptimizationMethod_Max_NumIter_get, _core.OptimizationMethod_Max_NumIter_set)
    Min_NumIter = _swig_property(_core.OptimizationMethod_Min_NumIter_get, _core.OptimizationMethod_Min_NumIter_set)
    Algorithm = _swig_property(_core.OptimizationMethod_Algorithm_get, _core.OptimizationMethod_Algorithm_set)
    Fail = _swig_property(_core.OptimizationMethod_Fail_get, _core.OptimizationMethod_Fail_set)
    Slowness = _swig_property(_core.OptimizationMethod_Slowness_get, _core.OptimizationMethod_Slowness_set)

    def get_step(self) -> "double":
        return _core.OptimizationMethod_get_step(self)

    def tell_step(self, step: 'double const &') -> "void":
        return _core.OptimizationMethod_tell_step(self, step)

    def tell_turn(self, val: 'double const &', tol: 'double const &', explain_stop: 'std::string &', iterationNumber: 'unsigned int const &') -> "bool":
        return _core.OptimizationMethod_tell_turn(self, val, tol, explain_stop, iterationNumber)

    def print_pack(self) -> "std::string":
        return _core.OptimizationMethod_print_pack(self)

    def AlgorithmName(self) -> "std::string":
        return _core.OptimizationMethod_AlgorithmName(self)

    def __repr__(self) -> "std::string":
        return _core.OptimizationMethod___repr__(self)
OptimizationMethod_swigregister = _core.OptimizationMethod_swigregister
OptimizationMethod_swigregister(OptimizationMethod)


def default_optimization_recipe() -> "std::vector< sherpa_pack,std::allocator< sherpa_pack > >":
    return _core.default_optimization_recipe()
default_optimization_recipe = _core.default_optimization_recipe

def bfgs_optimization_recipe() -> "std::vector< sherpa_pack,std::allocator< sherpa_pack > >":
    return _core.bfgs_optimization_recipe()
bfgs_optimization_recipe = _core.bfgs_optimization_recipe

def _set_array_module(mod: 'PyObject *') -> "void":
    return _core._set_array_module(mod)
_set_array_module = _core._set_array_module
class three_dim(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def size1(self) -> "unsigned int const &":
        return _core.three_dim_size1(self)

    def size2(self) -> "unsigned int const &":
        return _core.three_dim_size2(self)

    def size3(self) -> "unsigned int const &":
        return _core.three_dim_size3(self)

    def __init__(self, r: 'unsigned int const &', c: 'unsigned int const &', d: 'unsigned int const &'):
        this = _core.new_three_dim(r, c, d)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _core.delete_three_dim
    __del__ = lambda self: None
three_dim_swigregister = _core.three_dim_swigregister
three_dim_swigregister(three_dim)


def ndarray_make() -> "etk::ndarray *":
    return _core.ndarray_make()
ndarray_make = _core.ndarray_make

def ndarray_exp(arg1: 'etk::ndarray *') -> "void":
    return _core.ndarray_exp(arg1)
ndarray_exp = _core.ndarray_exp

def ndarray_log(arg1: 'etk::ndarray *') -> "void":
    return _core.ndarray_log(arg1)
ndarray_log = _core.ndarray_log

def ndarray_init(arg1: 'etk::ndarray *') -> "void":
    return _core.ndarray_init(arg1)
ndarray_init = _core.ndarray_init

def SymmetricArray_use_upper_triangle(arg1: 'etk::symmetric_matrix *') -> "void":
    return _core.SymmetricArray_use_upper_triangle(arg1)
SymmetricArray_use_upper_triangle = _core.SymmetricArray_use_upper_triangle


from .array import Array
from .array import SymmetricArray


class Fountain(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ask_dna(self, *args) -> "elm::VAS_dna const":
        return _core.Fountain_ask_dna(self, *args)

    def nCases(self) -> "unsigned int":
        return _core.Fountain_nCases(self)

    def nAlts(self) -> "unsigned int":
        return _core.Fountain_nAlts(self)

    def alternative_names(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.Fountain_alternative_names(self)

    def alternative_codes(self) -> "std::vector< long long,std::allocator< long long > >":
        return _core.Fountain_alternative_codes(self)

    def alternative_name(self, arg0: 'long long') -> "std::string":
        return _core.Fountain_alternative_name(self, arg0)

    def alternative_code(self, arg0: 'std::string') -> "long long":
        return _core.Fountain_alternative_code(self, arg0)

    def uncache_alternatives(self) -> "void":
        return _core.Fountain_uncache_alternatives(self)

    def check_ca(self, column: 'std::string const &') -> "bool":
        return _core.Fountain_check_ca(self, column)

    def check_co(self, column: 'std::string const &') -> "bool":
        return _core.Fountain_check_co(self, column)

    def variables_ca(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.Fountain_variables_ca(self)

    def variables_co(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.Fountain_variables_co(self)

    def __init__(self):
        if self.__class__ == Fountain:
            _self = None
        else:
            _self = self
        this = _core.new_Fountain(_self, )
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _core.delete_Fountain
    __del__ = lambda self: None
    source_filename = _swig_property(_core.Fountain_source_filename_get, _core.Fountain_source_filename_set)

    def DataDNA(self, c: 'long long const &'=0) -> "elm::VAS_System *":
        return _core.Fountain_DataDNA(self, c)

    def alternatives_dna(self) -> "elm::VAS_dna":
        return _core.Fountain_alternatives_dna(self)

    def _refresh_dna(self, a_names: 'StrVector', a_codes: 'LongLongVector') -> "void":
        return _core.Fountain__refresh_dna(self, a_names, a_codes)
    def __disown__(self):
        self.this.disown()
        _core.disown_Fountain(self)
        return weakref_proxy(self)
Fountain_swigregister = _core.Fountain_swigregister
Fountain_swigregister(Fountain)

class QuerySet(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def qry_idco(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.QuerySet_qry_idco(self, corrected)

    def qry_idco_(self) -> "std::string":
        return _core.QuerySet_qry_idco_(self)

    def qry_idca(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.QuerySet_qry_idca(self, corrected)

    def qry_idca_(self) -> "std::string":
        return _core.QuerySet_qry_idca_(self)

    def qry_alts(self) -> "std::string":
        return _core.QuerySet_qry_alts(self)

    def qry_caseids(self) -> "std::string":
        return _core.QuerySet_qry_caseids(self)

    def qry_choice(self) -> "std::string":
        return _core.QuerySet_qry_choice(self)

    def qry_weight(self) -> "std::string":
        return _core.QuerySet_qry_weight(self)

    def qry_avail(self) -> "std::string":
        return _core.QuerySet_qry_avail(self)

    def tbl_idco(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.QuerySet_tbl_idco(self, corrected)

    def tbl_idca(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.QuerySet_tbl_idca(self, corrected)

    def tbl_alts(self) -> "std::string":
        return _core.QuerySet_tbl_alts(self)

    def tbl_caseids(self) -> "std::string":
        return _core.QuerySet_tbl_caseids(self)

    def tbl_choice(self) -> "std::string":
        return _core.QuerySet_tbl_choice(self)

    def tbl_weight(self) -> "std::string":
        return _core.QuerySet_tbl_weight(self)

    def tbl_avail(self) -> "std::string":
        return _core.QuerySet_tbl_avail(self)

    def unweighted(self) -> "bool":
        return _core.QuerySet_unweighted(self)

    def all_alts_always_available(self) -> "bool":
        return _core.QuerySet_all_alts_always_available(self)
    __swig_destroy__ = _core.delete_QuerySet
    __del__ = lambda self: None

    def __init__(self, validator: 'Facet'=None, validator2: 'PyObject *'=None):
        this = _core.new_QuerySet(validator, validator2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def set_validator_(self, validator: 'Facet', validator2: 'PyObject *') -> "void":
        return _core.QuerySet_set_validator_(self, validator, validator2)

    def get_validator(self) -> "PyObject *":
        return _core.QuerySet_get_validator(self)

    def __repr__(self) -> "std::string":
        return _core.QuerySet___repr__(self)

    def actual_type(self) -> "std::string":
        return _core.QuerySet_actual_type(self)

    def pickled(self) -> "PyObject *":
        return _core.QuerySet_pickled(self)

    def __getstate__(self):
    	args = {}
    	for i in dir(self):
    		if len(i)>4 and i[:4]=='get_' and i!='get_validator':
    			args['set_'+i[4:]] = getattr(self,i)()
    	return args
    def __setstate__(self, state):
    	self.__init__()
    	for key, value in state.items():
    		getattr(self,key)(value)
    def set_validator(self, v):
    	self.set_validator_(v,v)


QuerySet_swigregister = _core.QuerySet_swigregister
QuerySet_swigregister(QuerySet)

class QuerySetSimpleCO(QuerySet):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def qry_idco(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.QuerySetSimpleCO_qry_idco(self, corrected)

    def qry_idco_(self) -> "std::string":
        return _core.QuerySetSimpleCO_qry_idco_(self)

    def qry_idca(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.QuerySetSimpleCO_qry_idca(self, corrected)

    def qry_idca_(self) -> "std::string":
        return _core.QuerySetSimpleCO_qry_idca_(self)

    def qry_alts(self) -> "std::string":
        return _core.QuerySetSimpleCO_qry_alts(self)

    def qry_caseids(self) -> "std::string":
        return _core.QuerySetSimpleCO_qry_caseids(self)

    def qry_choice(self) -> "std::string":
        return _core.QuerySetSimpleCO_qry_choice(self)

    def qry_weight(self) -> "std::string":
        return _core.QuerySetSimpleCO_qry_weight(self)

    def qry_avail(self) -> "std::string":
        return _core.QuerySetSimpleCO_qry_avail(self)

    def unweighted(self) -> "bool":
        return _core.QuerySetSimpleCO_unweighted(self)

    def all_alts_always_available(self) -> "bool":
        return _core.QuerySetSimpleCO_all_alts_always_available(self)
    __swig_destroy__ = _core.delete_QuerySetSimpleCO
    __del__ = lambda self: None

    def __repr__(self) -> "std::string":
        return _core.QuerySetSimpleCO___repr__(self)

    def actual_type(self) -> "std::string":
        return _core.QuerySetSimpleCO_actual_type(self)

    def __init__(self, validator: 'Facet'=None):
        this = _core.new_QuerySetSimpleCO(validator)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def set_validator(self, validator: 'Facet'=None) -> "void":
        return _core.QuerySetSimpleCO_set_validator(self, validator)

    def set_idco_query(self, q: 'std::string const &') -> "void":
        return _core.QuerySetSimpleCO_set_idco_query(self, q)

    def set_choice_column(self, col: 'std::string const &') -> "void":
        return _core.QuerySetSimpleCO_set_choice_column(self, col)

    def set_choice_column_map(self, cols: 'IntStringDict') -> "void":
        return _core.QuerySetSimpleCO_set_choice_column_map(self, cols)

    def set_avail_column_map(self, cols: 'IntStringDict') -> "void":
        return _core.QuerySetSimpleCO_set_avail_column_map(self, cols)

    def set_avail_query(self, q: 'std::string const &') -> "void":
        return _core.QuerySetSimpleCO_set_avail_query(self, q)

    def set_avail_all(self) -> "void":
        return _core.QuerySetSimpleCO_set_avail_all(self)

    def set_weight_column(self, col: 'std::string const &') -> "void":
        return _core.QuerySetSimpleCO_set_weight_column(self, col)

    def set_alts_query(self, q: 'std::string const &') -> "void":
        return _core.QuerySetSimpleCO_set_alts_query(self, q)

    def set_alts_values(self, alts: 'IntStringDict') -> "void":
        return _core.QuerySetSimpleCO_set_alts_values(self, alts)

    def get_idco_query(self) -> "std::string":
        return _core.QuerySetSimpleCO_get_idco_query(self)

    def get_choice_column(self) -> "std::string":
        return _core.QuerySetSimpleCO_get_choice_column(self)

    def get_choice_column_map(self) -> "std::map< long long,std::string,std::less< long long >,std::allocator< std::pair< long long const,std::string > > >":
        return _core.QuerySetSimpleCO_get_choice_column_map(self)

    def get_avail_column_map(self) -> "std::map< long long,std::string,std::less< long long >,std::allocator< std::pair< long long const,std::string > > >":
        return _core.QuerySetSimpleCO_get_avail_column_map(self)

    def get_avail_query(self) -> "std::string":
        return _core.QuerySetSimpleCO_get_avail_query(self)

    def get_weight_column(self) -> "std::string":
        return _core.QuerySetSimpleCO_get_weight_column(self)

    def get_alts_query(self) -> "std::string":
        return _core.QuerySetSimpleCO_get_alts_query(self)

    def _get_alts_values(self) -> "std::map< long long,std::string,std::less< long long >,std::allocator< std::pair< long long const,std::string > > >":
        return _core.QuerySetSimpleCO__get_alts_values(self)
QuerySetSimpleCO_swigregister = _core.QuerySetSimpleCO_swigregister
QuerySetSimpleCO_swigregister(QuerySetSimpleCO)


from . import _QuerySetSimpleCO_extras as _morefuncs
del _morefuncs

class QuerySetTwoTable(QuerySet):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def qry_idco(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.QuerySetTwoTable_qry_idco(self, corrected)

    def qry_idco_(self) -> "std::string":
        return _core.QuerySetTwoTable_qry_idco_(self)

    def qry_idca(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.QuerySetTwoTable_qry_idca(self, corrected)

    def qry_idca_(self) -> "std::string":
        return _core.QuerySetTwoTable_qry_idca_(self)

    def qry_alts(self) -> "std::string":
        return _core.QuerySetTwoTable_qry_alts(self)

    def qry_caseids(self) -> "std::string":
        return _core.QuerySetTwoTable_qry_caseids(self)

    def qry_choice(self) -> "std::string":
        return _core.QuerySetTwoTable_qry_choice(self)

    def qry_weight(self) -> "std::string":
        return _core.QuerySetTwoTable_qry_weight(self)

    def qry_avail(self) -> "std::string":
        return _core.QuerySetTwoTable_qry_avail(self)

    def unweighted(self) -> "bool":
        return _core.QuerySetTwoTable_unweighted(self)

    def all_alts_always_available(self) -> "bool":
        return _core.QuerySetTwoTable_all_alts_always_available(self)
    __swig_destroy__ = _core.delete_QuerySetTwoTable
    __del__ = lambda self: None

    def __repr__(self) -> "std::string":
        return _core.QuerySetTwoTable___repr__(self)

    def actual_type(self) -> "std::string":
        return _core.QuerySetTwoTable_actual_type(self)

    def pickled(self) -> "PyObject *":
        return _core.QuerySetTwoTable_pickled(self)

    def __init__(self, validator: 'Facet'=None):
        this = _core.new_QuerySetTwoTable(validator)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def set_validator(self, validator: 'Facet'=None) -> "void":
        return _core.QuerySetTwoTable_set_validator(self, validator)

    def set_idco_query(self, q: 'std::string const &') -> "void":
        return _core.QuerySetTwoTable_set_idco_query(self, q)

    def set_idca_query(self, q: 'std::string const &') -> "void":
        return _core.QuerySetTwoTable_set_idca_query(self, q)

    def set_choice_co(self, col: 'std::string const &') -> "void":
        """
        Set the choice expression that will evaluate on the idco table. 

        Parameters 
        ---------- 
        expr : str 
        	The expression to be evaluated. It should result in integer values 
        	corresponding to the alternative codes.

        """
        return _core.QuerySetTwoTable_set_choice_co(self, col)


    def set_choice_co_map(self, cols: 'IntStringDict') -> "void":
        return _core.QuerySetTwoTable_set_choice_co_map(self, cols)

    def set_choice_ca(self, col: 'std::string const &') -> "void":
        """
        Set the choice expression that will evaluate on the idca table. 

        Parameters 
        ---------- 
        expr : str 
        	The expression to be evaluated. It should evaluate to 1 if the alternative for the 
        	particular row was chosen, and 0 otherwise. (For certain specialized models,     
        	values other than 0 or 1 may be appropriate.)

        """
        return _core.QuerySetTwoTable_set_choice_ca(self, col)


    def set_avail_co_column_map(self, cols: 'IntStringDict') -> "void":
        return _core.QuerySetTwoTable_set_avail_co_column_map(self, cols)

    def set_avail_ca_column(self, col: 'std::string const &') -> "void":
        return _core.QuerySetTwoTable_set_avail_ca_column(self, col)

    def set_avail_all(self) -> "void":
        return _core.QuerySetTwoTable_set_avail_all(self)

    def set_weight_co_column(self, col: 'std::string const &') -> "void":
        return _core.QuerySetTwoTable_set_weight_co_column(self, col)

    def set_alts_query(self, q: 'std::string const &') -> "void":
        return _core.QuerySetTwoTable_set_alts_query(self, q)

    def set_alts_values(self, alts: 'IntStringDict') -> "void":
        return _core.QuerySetTwoTable_set_alts_values(self, alts)

    def get_idco_query(self) -> "std::string":
        return _core.QuerySetTwoTable_get_idco_query(self)

    def get_idca_query(self) -> "std::string":
        return _core.QuerySetTwoTable_get_idca_query(self)

    def get_choice_co(self) -> "std::string":
        return _core.QuerySetTwoTable_get_choice_co(self)

    def get_choice_co_map(self) -> "std::map< long long,std::string,std::less< long long >,std::allocator< std::pair< long long const,std::string > > >":
        return _core.QuerySetTwoTable_get_choice_co_map(self)

    def get_choice_ca(self) -> "std::string":
        return _core.QuerySetTwoTable_get_choice_ca(self)

    def get_avail_co_column_map(self) -> "std::map< long long,std::string,std::less< long long >,std::allocator< std::pair< long long const,std::string > > >":
        return _core.QuerySetTwoTable_get_avail_co_column_map(self)

    def get_avail_ca_column(self) -> "std::string":
        return _core.QuerySetTwoTable_get_avail_ca_column(self)

    def get_weight_co_column(self) -> "std::string":
        return _core.QuerySetTwoTable_get_weight_co_column(self)

    def get_alts_query(self) -> "std::string":
        return _core.QuerySetTwoTable_get_alts_query(self)

    def _get_alts_values(self) -> "std::map< long long,std::string,std::less< long long >,std::allocator< std::pair< long long const,std::string > > >":
        return _core.QuerySetTwoTable__get_alts_values(self)
QuerySetTwoTable_swigregister = _core.QuerySetTwoTable_swigregister
QuerySetTwoTable_swigregister(QuerySetTwoTable)


from . import _QuerySetTwoTable_extras as _morefuncs
del _morefuncs

class SQLiteDB(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, pylong_ptr_to_db: 'PyObject *'):
        this = _core.new_SQLiteDB(pylong_ptr_to_db)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _core.delete_SQLiteDB
    __del__ = lambda self: None

    def close(self) -> "void":
        return _core.SQLiteDB_close(self)

    def copy_from_db(self, file_name_: 'std::string const &') -> "void":
        return _core.SQLiteDB_copy_from_db(self, file_name_)

    def backup(self, filename: 'std::string const &') -> "void":
        """
        Save the current SQLite database to another DB. 

        :param filename: The URI for where to save the DB.
        """
        return _core.SQLiteDB_backup(self, filename)


    def commit(self, raise_on_fail: 'int'=1) -> "void":
        """
        Commit to SQLite database. 

        :param raise_on_fail: Raise an exception if the commit fails for any reason.
        """
        return _core.SQLiteDB_commit(self, raise_on_fail)


    def drop(self, name: 'std::string') -> "void":
        return _core.SQLiteDB_drop(self, name)

    def all_table_names(self) -> "std::vector< std::string,std::allocator< std::string > >":
        """
        A list of all table names in the SQL database, including both data tables and
        administrative tables
        """
        return _core.SQLiteDB_all_table_names(self)


    def column_names(self, query: 'std::string') -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.SQLiteDB_column_names(self, query)

    def column_name(self, query: 'std::string', n: 'int') -> "std::string":
        return _core.SQLiteDB_column_name(self, query, n)

    def logger(self, log: 'PyObject *'=None) -> "PyObject *":
        """
        The SQLiteDB object contains a link to the standard python logging service. By default,
        no logger is connected. Use this function to assign a logger, and then use the usual
        python logging controls to set the quantity/destination of output. To stop logging,
        call this function without any arguments.
        """
        return _core.SQLiteDB_logger(self, log)


    def error_code(self) -> "int":
        return _core.SQLiteDB_error_code(self)

    def error_msg(self) -> "std::string":
        return _core.SQLiteDB_error_msg(self)

    def eval_integer(self, *args) -> "int":
        """
        Evaluate a SQL statement that should return a single text string. 

        :param sql: The SQL statement to evaluate.
        :param default_value: A default value to return if the statement does not return a single value.
        """
        return _core.SQLiteDB_eval_integer(self, *args)


    def eval_int64(self, *args) -> "long long":
        return _core.SQLiteDB_eval_int64(self, *args)

    def eval_float(self, *args) -> "double":
        """
        Evaluate a SQL statement that should return a single double precision floating point number. 

        :param sql: The SQL statement to evaluate.
        :param default_value: A default value to return if the statement does not return a single value.
        """
        return _core.SQLiteDB_eval_float(self, *args)


    def eval_text(self, *args) -> "std::string":
        return _core.SQLiteDB_eval_text(self, *args)

    def eval_int64_tuple(self, sql: 'std::string const &') -> "std::vector< long long,std::allocator< long long > >":
        return _core.SQLiteDB_eval_int64_tuple(self, sql)

    def eval_string_tuple(self, sql: 'std::string const &') -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.SQLiteDB_eval_string_tuple(self, sql)

    def __str__(self):
    	return "<SQLiteDB: %s>"%self.working_name
    def __repr__(self):
    	return "<SQLiteDB: %s>"%self.working_name
    exec_integer = eval_integer
    exec_float   = eval_float
    exec_text    = eval_text
    def Shell(self):
    	'''Enter an SQLite shell for accessing the contents of the database object.

    	The shell is based on the usual SQLite3 command shell, and is not a Python
    	interpreted environment. Use Ctrl-C (Windows) or Ctrl-D (Mac OS X) to escape
    	back to the usual Python environment.'''
    	from . import apsw
    	apsw.Shell(db=self).cmdloop()

SQLiteDB_swigregister = _core.SQLiteDB_swigregister
SQLiteDB_swigregister(SQLiteDB)

class Facet(SQLiteDB, Fountain):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ask_dna(self, c: 'long long const &'=0) -> "elm::VAS_dna":
        return _core.Facet_ask_dna(self, c)
    __swig_destroy__ = _core.delete_Facet
    __del__ = lambda self: None
    window_title = _swig_property(_core.Facet_window_title_get, _core.Facet_window_title_set)
    working_name = _swig_property(_core.Facet_working_name_get, _core.Facet_working_name_set)
    active_facet = _swig_property(_core.Facet_active_facet_get, _core.Facet_active_facet_set)

    def _get_queries(self) -> "PyObject *":
        return _core.Facet__get_queries(self)

    def _set_queries(self, q: 'PyObject *', qp: 'QuerySet', facetself: 'PyObject *') -> "void":
        return _core.Facet__set_queries(self, q, qp, facetself)

    def refresh_queries(self) -> "void":
        return _core.Facet_refresh_queries(self)

    def __init__(self, pylong_ptr_to_db: 'PyObject *'):
        this = _core.new_Facet(pylong_ptr_to_db)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def save_facet(self, name: 'std::string') -> "void":
        return _core.Facet_save_facet(self, name)

    def load_facet(self, *args) -> "void":
        return _core.Facet_load_facet(self, *args)

    def clear_facet(self) -> "void":
        return _core.Facet_clear_facet(self)

    def list_facets(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.Facet_list_facets(self)

    def nCases(self) -> "unsigned int":
        return _core.Facet_nCases(self)

    def nAlts(self) -> "unsigned int":
        return _core.Facet_nAlts(self)

    def caseids(self, firstcasenum: 'unsigned int const &'=0, numberofcases: 'unsigned int const &'=0, no_error_checking: 'int'=0) -> "std::vector< long long,std::allocator< long long > >":
        return _core.Facet_caseids(self, firstcasenum, numberofcases, no_error_checking)

    def altids(self) -> "std::vector< long long,std::allocator< long long > >":
        return _core.Facet_altids(self)

    def alternative_names(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.Facet_alternative_names(self)

    def alternative_codes(self) -> "std::vector< long long,std::allocator< long long > >":
        return _core.Facet_alternative_codes(self)

    def alternative_name(self, arg2: 'long long') -> "std::string":
        return _core.Facet_alternative_name(self, arg2)

    def alternative_code(self, arg2: 'std::string') -> "long long":
        return _core.Facet_alternative_code(self, arg2)

    def check_ca(self, column: 'std::string const &') -> "bool":
        return _core.Facet_check_ca(self, column)

    def check_co(self, column: 'std::string const &') -> "bool":
        return _core.Facet_check_co(self, column)

    def variables_ca(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.Facet_variables_ca(self)

    def variables_co(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.Facet_variables_co(self)

    def query_idca(self, columns: 'StrVector', validate: 'bool'=False, caseid: 'long long *'=None) -> "std::string":
        return _core.Facet_query_idca(self, columns, validate, caseid)

    def query_idco(self, columns: 'StrVector', validate: 'bool'=False, caseid: 'long long *'=None) -> "std::string":
        return _core.Facet_query_idco(self, columns, validate, caseid)

    def query_alts(self, caseid: 'long long *') -> "std::string":
        return _core.Facet_query_alts(self, caseid)

    def query_choice(self, caseid: 'long long *'=None) -> "std::string":
        return _core.Facet_query_choice(self, caseid)

    def query_avail(self, caseid: 'long long *'=None) -> "std::string":
        return _core.Facet_query_avail(self, caseid)

    def query_weight(self, caseid: 'long long *'=None) -> "std::string":
        return _core.Facet_query_weight(self, caseid)

    def qry_idca(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.Facet_qry_idca(self, corrected)

    def qry_idco(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.Facet_qry_idco(self, corrected)

    def qry_idca_(self) -> "std::string":
        return _core.Facet_qry_idca_(self)

    def qry_idco_(self) -> "std::string":
        return _core.Facet_qry_idco_(self)

    def qry_alts(self) -> "std::string":
        return _core.Facet_qry_alts(self)

    def qry_choice(self) -> "std::string":
        return _core.Facet_qry_choice(self)

    def qry_avail(self) -> "std::string":
        return _core.Facet_qry_avail(self)

    def qry_weight(self) -> "std::string":
        return _core.Facet_qry_weight(self)

    def qry_caseids(self) -> "std::string":
        return _core.Facet_qry_caseids(self)

    def tbl_idca(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.Facet_tbl_idca(self, corrected)

    def tbl_idco(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.Facet_tbl_idco(self, corrected)

    def tbl_alts(self) -> "std::string":
        return _core.Facet_tbl_alts(self)

    def tbl_choice(self) -> "std::string":
        return _core.Facet_tbl_choice(self)

    def tbl_avail(self) -> "std::string":
        return _core.Facet_tbl_avail(self)

    def tbl_weight(self) -> "std::string":
        return _core.Facet_tbl_weight(self)

    def tbl_caseids(self) -> "std::string":
        return _core.Facet_tbl_caseids(self)

    def unweighted(self) -> "bool":
        return _core.Facet_unweighted(self)

    def all_alts_always_available(self) -> "bool":
        return _core.Facet_all_alts_always_available(self)

    def _array_idco_reader(self, qry: 'std::string const &', array: 'elm::darray *', caseids: 'elm::darray *') -> "void":
        return _core.Facet__array_idco_reader(self, qry, array, caseids)

    def _array_idca_reader(self, qry: 'std::string const &', array: 'elm::darray *', caseids: 'elm::darray *', altids: 'LongLongVector') -> "void":
        return _core.Facet__array_idca_reader(self, qry, array, caseids, altids)

    def _array_idca_reader_blind(self, qry: 'std::string const &', arraytype: 'int', altids: 'LongLongVector') -> "void":
        return _core.Facet__array_idca_reader_blind(self, qry, arraytype, altids)

    def sql(self):
    	print("sql_idco:   %s"%(self.sql_idco   if self.sql_idco   else "<blank>"))
    	print("sql_idca:   %s"%(self.sql_idca   if self.sql_idca   else "<blank>"))
    	print("sql_alts:   %s"%(self.sql_alts   if self.sql_alts   else "<blank>"))
    	print("sql_choice: %s"%(self.sql_choice if self.sql_choice else "<blank>"))
    	print("sql_avail:  %s"%(self.sql_avail  if self.sql_avail  else "<blank>"))
    	print("sql_weight: %s"%(self.sql_weight if self.sql_weight else "<blank>"))

Facet_swigregister = _core.Facet_swigregister
Facet_swigregister(Facet)


from .db import DB
from .dt import DT


_core.ELM_IGNORED_swigconstant(_core)
ELM_IGNORED = _core.ELM_IGNORED

_core.ELM_UPDATED_swigconstant(_core)
ELM_UPDATED = _core.ELM_UPDATED

_core.ELM_INITIALIZED_swigconstant(_core)
ELM_INITIALIZED = _core.ELM_INITIALIZED

_core.ELM_CREATED_swigconstant(_core)
ELM_CREATED = _core.ELM_CREATED

_core.ELM_FAILED_swigconstant(_core)
ELM_FAILED = _core.ELM_FAILED
class ParameterLinkArray(three_dim):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self):
        this = _core.new_ParameterLinkArray()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _core.delete_ParameterLinkArray
    __del__ = lambda self: None

    def __str__(self) -> "std::string":
        return _core.ParameterLinkArray___str__(self)

    def __repr__(self) -> "std::string":
        return _core.ParameterLinkArray___repr__(self)

    def pull(self, listorder: 'etk::ndarray const *', apporder: 'etk::ndarray *') -> "void":
        return _core.ParameterLinkArray_pull(self, listorder, apporder)

    def push(self, listorder: 'etk::ndarray *', apporder: 'etk::ndarray const *') -> "void":
        return _core.ParameterLinkArray_push(self, listorder, apporder)
ParameterLinkArray_swigregister = _core.ParameterLinkArray_swigregister
ParameterLinkArray_swigregister(ParameterLinkArray)

class cellcodeset_iterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __iter__(self) -> "elm::cellcodeset_iterator":
        return _core.cellcodeset_iterator___iter__(self)

    def next(self) -> "elm::cellcode":
        return _core.cellcodeset_iterator_next(self)

    def __next__(self) -> "elm::cellcode":
        return _core.cellcodeset_iterator___next__(self)

    def __init__(self, parent: 'cellcodeset'):
        this = _core.new_cellcodeset_iterator(parent)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _core.delete_cellcodeset_iterator
    __del__ = lambda self: None
cellcodeset_iterator_swigregister = _core.cellcodeset_iterator_swigregister
cellcodeset_iterator_swigregister(cellcodeset_iterator)

class cellcodeset(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args):
        this = _core.new_cellcodeset(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def contains(self, j: 'elm::cellcode const &') -> "bool":
        return _core.cellcodeset_contains(self, j)

    def insert_set(self, i: 'cellcodeset') -> "void":
        return _core.cellcodeset_insert_set(self, i)

    def append(self, i: 'elm::cellcode const &') -> "void":
        return _core.cellcodeset_append(self, i)

    def remove(self, i: 'elm::cellcode const &') -> "bool":
        return _core.cellcodeset_remove(self, i)

    def noop(self) -> "void":
        return _core.cellcodeset_noop(self)

    def __iadd__(self, *args) -> "elm::cellcodeset &":
        return _core.cellcodeset___iadd__(self, *args)

    def __isub__(self, *args) -> "elm::cellcodeset &":
        return _core.cellcodeset___isub__(self, *args)

    def __len__(self) -> "int":
        return _core.cellcodeset___len__(self)

    def __repr__(self) -> "std::string":
        return _core.cellcodeset___repr__(self)

    def __iter__(self) -> "elm::cellcodeset_iterator":
        return _core.cellcodeset___iter__(self)
    __swig_destroy__ = _core.delete_cellcodeset
    __del__ = lambda self: None
cellcodeset_swigregister = _core.cellcodeset_swigregister
cellcodeset_swigregister(cellcodeset)


def max_cellcode() -> "elm::cellcode":
    return _core.max_cellcode()
max_cellcode = _core.max_cellcode
class string_and_cellcode(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    text = _swig_property(_core.string_and_cellcode_text_get, _core.string_and_cellcode_text_set)
    code = _swig_property(_core.string_and_cellcode_code_get, _core.string_and_cellcode_code_set)

    def __init__(self):
        this = _core.new_string_and_cellcode()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _core.delete_string_and_cellcode
    __del__ = lambda self: None
string_and_cellcode_swigregister = _core.string_and_cellcode_swigregister
string_and_cellcode_swigregister(string_and_cellcode)

class cellcodepair(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    up = _swig_property(_core.cellcodepair_up_get, _core.cellcodepair_up_set)
    dn = _swig_property(_core.cellcodepair_dn_get, _core.cellcodepair_dn_set)

    def __init__(self, *args):
        this = _core.new_cellcodepair(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def __lt__(self, x: 'cellcodepair') -> "bool":
        return _core.cellcodepair___lt__(self, x)

    def __eq__(self, x: 'cellcodepair') -> "bool":
        return _core.cellcodepair___eq__(self, x)

    def __gt__(self, x: 'cellcodepair') -> "bool":
        return _core.cellcodepair___gt__(self, x)

    def __ge__(self, x: 'cellcodepair') -> "bool":
        return _core.cellcodepair___ge__(self, x)

    def __le__(self, x: 'cellcodepair') -> "bool":
        return _core.cellcodepair___le__(self, x)
    __swig_destroy__ = _core.delete_cellcodepair
    __del__ = lambda self: None
cellcodepair_swigregister = _core.cellcodepair_swigregister
cellcodepair_swigregister(cellcodepair)

class cellcode_infodict(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.cellcode_infodict_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.cellcode_infodict___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.cellcode_infodict___bool__(self)

    def __len__(self) -> "std::map< long long,elm::VAS_dna_info >::size_type":
        return _core.cellcode_infodict___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< long long,elm::VAS_dna_info >::key_type const &') -> "std::map< long long,elm::VAS_dna_info >::mapped_type const &":
        return _core.cellcode_infodict___getitem__(self, key)

    def __delitem__(self, key: 'std::map< long long,elm::VAS_dna_info >::key_type const &') -> "void":
        return _core.cellcode_infodict___delitem__(self, key)

    def has_key(self, key: 'std::map< long long,elm::VAS_dna_info >::key_type const &') -> "bool":
        return _core.cellcode_infodict_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _core.cellcode_infodict_keys(self)

    def values(self) -> "PyObject *":
        return _core.cellcode_infodict_values(self)

    def items(self) -> "PyObject *":
        return _core.cellcode_infodict_items(self)

    def __contains__(self, key: 'std::map< long long,elm::VAS_dna_info >::key_type const &') -> "bool":
        return _core.cellcode_infodict___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _core.cellcode_infodict_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _core.cellcode_infodict_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _core.cellcode_infodict___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _core.cellcode_infodict_asdict(self)

    def __init__(self, *args):
        this = _core.new_cellcode_infodict(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self) -> "bool":
        return _core.cellcode_infodict_empty(self)

    def size(self) -> "std::map< long long,elm::VAS_dna_info >::size_type":
        return _core.cellcode_infodict_size(self)

    def swap(self, v: 'cellcode_infodict') -> "void":
        return _core.cellcode_infodict_swap(self, v)

    def begin(self) -> "std::map< long long,elm::VAS_dna_info >::iterator":
        return _core.cellcode_infodict_begin(self)

    def end(self) -> "std::map< long long,elm::VAS_dna_info >::iterator":
        return _core.cellcode_infodict_end(self)

    def rbegin(self) -> "std::map< long long,elm::VAS_dna_info >::reverse_iterator":
        return _core.cellcode_infodict_rbegin(self)

    def rend(self) -> "std::map< long long,elm::VAS_dna_info >::reverse_iterator":
        return _core.cellcode_infodict_rend(self)

    def clear(self) -> "void":
        return _core.cellcode_infodict_clear(self)

    def get_allocator(self) -> "std::map< long long,elm::VAS_dna_info >::allocator_type":
        return _core.cellcode_infodict_get_allocator(self)

    def count(self, x: 'std::map< long long,elm::VAS_dna_info >::key_type const &') -> "std::map< long long,elm::VAS_dna_info >::size_type":
        return _core.cellcode_infodict_count(self, x)

    def erase(self, *args) -> "void":
        return _core.cellcode_infodict_erase(self, *args)

    def find(self, x: 'std::map< long long,elm::VAS_dna_info >::key_type const &') -> "std::map< long long,elm::VAS_dna_info >::iterator":
        return _core.cellcode_infodict_find(self, x)

    def lower_bound(self, x: 'std::map< long long,elm::VAS_dna_info >::key_type const &') -> "std::map< long long,elm::VAS_dna_info >::iterator":
        return _core.cellcode_infodict_lower_bound(self, x)

    def upper_bound(self, x: 'std::map< long long,elm::VAS_dna_info >::key_type const &') -> "std::map< long long,elm::VAS_dna_info >::iterator":
        return _core.cellcode_infodict_upper_bound(self, x)
    __swig_destroy__ = _core.delete_cellcode_infodict
    __del__ = lambda self: None
cellcode_infodict_swigregister = _core.cellcode_infodict_swigregister
cellcode_infodict_swigregister(cellcode_infodict)

class cellcode_list(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.cellcode_list_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.cellcode_list___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.cellcode_list___bool__(self)

    def __len__(self) -> "std::list< long long >::size_type":
        return _core.cellcode_list___len__(self)

    def __getslice__(self, i: 'std::list< long long >::difference_type', j: 'std::list< long long >::difference_type') -> "std::list< long long,std::allocator< long long > > *":
        return _core.cellcode_list___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.cellcode_list___setslice__(self, *args)

    def __delslice__(self, i: 'std::list< long long >::difference_type', j: 'std::list< long long >::difference_type') -> "void":
        return _core.cellcode_list___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.cellcode_list___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< long long >::value_type const &":
        return _core.cellcode_list___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.cellcode_list___setitem__(self, *args)

    def pop(self) -> "std::list< long long >::value_type":
        return _core.cellcode_list_pop(self)

    def append(self, x: 'std::list< long long >::value_type const &') -> "void":
        return _core.cellcode_list_append(self, x)

    def empty(self) -> "bool":
        return _core.cellcode_list_empty(self)

    def size(self) -> "std::list< long long >::size_type":
        return _core.cellcode_list_size(self)

    def swap(self, v: 'cellcode_list') -> "void":
        return _core.cellcode_list_swap(self, v)

    def begin(self) -> "std::list< long long >::iterator":
        return _core.cellcode_list_begin(self)

    def end(self) -> "std::list< long long >::iterator":
        return _core.cellcode_list_end(self)

    def rbegin(self) -> "std::list< long long >::reverse_iterator":
        return _core.cellcode_list_rbegin(self)

    def rend(self) -> "std::list< long long >::reverse_iterator":
        return _core.cellcode_list_rend(self)

    def clear(self) -> "void":
        return _core.cellcode_list_clear(self)

    def get_allocator(self) -> "std::list< long long >::allocator_type":
        return _core.cellcode_list_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.cellcode_list_pop_back(self)

    def erase(self, *args) -> "std::list< long long >::iterator":
        return _core.cellcode_list_erase(self, *args)

    def __init__(self, *args):
        this = _core.new_cellcode_list(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::list< long long >::value_type const &') -> "void":
        return _core.cellcode_list_push_back(self, x)

    def front(self) -> "std::list< long long >::value_type const &":
        return _core.cellcode_list_front(self)

    def back(self) -> "std::list< long long >::value_type const &":
        return _core.cellcode_list_back(self)

    def assign(self, n: 'std::list< long long >::size_type', x: 'std::list< long long >::value_type const &') -> "void":
        return _core.cellcode_list_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.cellcode_list_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.cellcode_list_insert(self, *args)

    def pop_front(self) -> "void":
        return _core.cellcode_list_pop_front(self)

    def push_front(self, x: 'std::list< long long >::value_type const &') -> "void":
        return _core.cellcode_list_push_front(self, x)

    def reverse(self) -> "void":
        return _core.cellcode_list_reverse(self)
    __swig_destroy__ = _core.delete_cellcode_list
    __del__ = lambda self: None
cellcode_list_swigregister = _core.cellcode_list_swigregister
cellcode_list_swigregister(cellcode_list)

class VAS_dna_info(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    dns = _swig_property(_core.VAS_dna_info_dns_get, _core.VAS_dna_info_dns_set)
    name = _swig_property(_core.VAS_dna_info_name_get, _core.VAS_dna_info_name_set)
    is_branch = _swig_property(_core.VAS_dna_info_is_branch_get, _core.VAS_dna_info_is_branch_set)

    def __init__(self, *args):
        this = _core.new_VAS_dna_info(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def is_elemental(self) -> "bool":
        return _core.VAS_dna_info_is_elemental(self)
    __swig_destroy__ = _core.delete_VAS_dna_info
    __del__ = lambda self: None
VAS_dna_info_swigregister = _core.VAS_dna_info_swigregister
VAS_dna_info_swigregister(VAS_dna_info)

class VAS_dna(cellcode_infodict):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def read_sequence(self, seq: 'std::string const &') -> "void":
        return _core.VAS_dna_read_sequence(self, seq)

    def add_sequence(self, *args) -> "void":
        return _core.VAS_dna_add_sequence(self, *args)

    def generate_sequence(self) -> "std::string":
        return _core.VAS_dna_generate_sequence(self)

    def generate_phenotype(self) -> "std::string":
        return _core.VAS_dna_generate_phenotype(self)

    def add_edge(self, source: 'elm::cellcode const &', sink: 'elm::cellcode const &') -> "std::string":
        return _core.VAS_dna_add_edge(self, source, sink)

    def remove_edge(self, source: 'elm::cellcode const &', sink: 'elm::cellcode const &') -> "std::string":
        return _core.VAS_dna_remove_edge(self, source, sink)

    def add_cell(self, *args) -> "int":
        return _core.VAS_dna_add_cell(self, *args)

    def clear(self) -> "void":
        return _core.VAS_dna_clear(self)

    def elemental_codes(self) -> "elm::cellcodeset":
        return _core.VAS_dna_elemental_codes(self)

    def all_known_codes(self) -> "elm::cellcodeset":
        return _core.VAS_dna_all_known_codes(self)

    def branches_in_ascending_order(self, *args) -> "std::list< elm::cellcode,std::allocator< elm::cellcode > >":
        return _core.VAS_dna_branches_in_ascending_order(self, *args)

    def __init__(self):
        this = _core.new_VAS_dna()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _core.delete_VAS_dna
    __del__ = lambda self: None
VAS_dna_swigregister = _core.VAS_dna_swigregister
VAS_dna_swigregister(VAS_dna)

class VAS_System(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def n_elemental(self) -> "unsigned int const &":
        return _core.VAS_System_n_elemental(self)

    def n_branches(self) -> "unsigned int const &":
        return _core.VAS_System_n_branches(self)

    def n_edges(self) -> "unsigned int const &":
        return _core.VAS_System_n_edges(self)

    def alloc_break(self, i: 'unsigned int const &') -> "unsigned int const &":
        return _core.VAS_System_alloc_break(self, i)

    def n_alloc_break(self) -> "size_t":
        return _core.VAS_System_n_alloc_break(self)

    def size(self) -> "size_t":
        return _core.VAS_System_size(self)

    def display(self) -> "std::string":
        return _core.VAS_System_display(self)

    def display_phenotype(self) -> "std::string":
        return _core.VAS_System_display_phenotype(self)

    def display_edges(self) -> "std::string":
        return _core.VAS_System_display_edges(self)

    def elemental_names(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.VAS_System_elemental_names(self)

    def elemental_codes(self) -> "std::vector< long long,std::allocator< long long > >":
        return _core.VAS_System_elemental_codes(self)

    def all_codes(self) -> "std::vector< long long,std::allocator< long long > >":
        return _core.VAS_System_all_codes(self)

    def __init__(self):
        this = _core.new_VAS_System()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _core.delete_VAS_System
    __del__ = lambda self: None
VAS_System_swigregister = _core.VAS_System_swigregister
VAS_System_swigregister(VAS_System)

class ComponentVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.ComponentVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.ComponentVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.ComponentVector___bool__(self)

    def __len__(self) -> "std::vector< elm::LinearComponent >::size_type":
        return _core.ComponentVector___len__(self)

    def __getslice__(self, i: 'std::vector< elm::LinearComponent >::difference_type', j: 'std::vector< elm::LinearComponent >::difference_type') -> "std::vector< elm::LinearComponent,std::allocator< elm::LinearComponent > > *":
        return _core.ComponentVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.ComponentVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< elm::LinearComponent >::difference_type', j: 'std::vector< elm::LinearComponent >::difference_type') -> "void":
        return _core.ComponentVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.ComponentVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< elm::LinearComponent >::value_type const &":
        return _core.ComponentVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.ComponentVector___setitem__(self, *args)

    def pop(self) -> "std::vector< elm::LinearComponent >::value_type":
        return _core.ComponentVector_pop(self)

    def append(self, x: 'LinearComponent') -> "void":
        return _core.ComponentVector_append(self, x)

    def empty(self) -> "bool":
        return _core.ComponentVector_empty(self)

    def size(self) -> "std::vector< elm::LinearComponent >::size_type":
        return _core.ComponentVector_size(self)

    def swap(self, v: 'ComponentVector') -> "void":
        return _core.ComponentVector_swap(self, v)

    def begin(self) -> "std::vector< elm::LinearComponent >::iterator":
        return _core.ComponentVector_begin(self)

    def end(self) -> "std::vector< elm::LinearComponent >::iterator":
        return _core.ComponentVector_end(self)

    def rbegin(self) -> "std::vector< elm::LinearComponent >::reverse_iterator":
        return _core.ComponentVector_rbegin(self)

    def rend(self) -> "std::vector< elm::LinearComponent >::reverse_iterator":
        return _core.ComponentVector_rend(self)

    def clear(self) -> "void":
        return _core.ComponentVector_clear(self)

    def get_allocator(self) -> "std::vector< elm::LinearComponent >::allocator_type":
        return _core.ComponentVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.ComponentVector_pop_back(self)

    def erase(self, *args) -> "std::vector< elm::LinearComponent >::iterator":
        return _core.ComponentVector_erase(self, *args)

    def __init__(self, *args):
        this = _core.new_ComponentVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'LinearComponent') -> "void":
        return _core.ComponentVector_push_back(self, x)

    def front(self) -> "std::vector< elm::LinearComponent >::value_type const &":
        return _core.ComponentVector_front(self)

    def back(self) -> "std::vector< elm::LinearComponent >::value_type const &":
        return _core.ComponentVector_back(self)

    def assign(self, n: 'std::vector< elm::LinearComponent >::size_type', x: 'LinearComponent') -> "void":
        return _core.ComponentVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.ComponentVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.ComponentVector_insert(self, *args)

    def reserve(self, n: 'std::vector< elm::LinearComponent >::size_type') -> "void":
        return _core.ComponentVector_reserve(self, n)

    def capacity(self) -> "std::vector< elm::LinearComponent >::size_type":
        return _core.ComponentVector_capacity(self)
    __swig_destroy__ = _core.delete_ComponentVector
    __del__ = lambda self: None
ComponentVector_swigregister = _core.ComponentVector_swigregister
ComponentVector_swigregister(ComponentVector)

class _base_LinearSubBundle_1(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core._base_LinearSubBundle_1_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core._base_LinearSubBundle_1___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core._base_LinearSubBundle_1___bool__(self)

    def __len__(self) -> "std::map< long long,elm::ComponentList >::size_type":
        return _core._base_LinearSubBundle_1___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< long long,elm::ComponentList >::key_type const &') -> "std::map< long long,elm::ComponentList >::mapped_type const &":
        return _core._base_LinearSubBundle_1___getitem__(self, key)

    def __delitem__(self, key: 'std::map< long long,elm::ComponentList >::key_type const &') -> "void":
        return _core._base_LinearSubBundle_1___delitem__(self, key)

    def has_key(self, key: 'std::map< long long,elm::ComponentList >::key_type const &') -> "bool":
        return _core._base_LinearSubBundle_1_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _core._base_LinearSubBundle_1_keys(self)

    def values(self) -> "PyObject *":
        return _core._base_LinearSubBundle_1_values(self)

    def items(self) -> "PyObject *":
        return _core._base_LinearSubBundle_1_items(self)

    def __contains__(self, key: 'std::map< long long,elm::ComponentList >::key_type const &') -> "bool":
        return _core._base_LinearSubBundle_1___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _core._base_LinearSubBundle_1_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _core._base_LinearSubBundle_1_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _core._base_LinearSubBundle_1___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _core._base_LinearSubBundle_1_asdict(self)

    def __init__(self, *args):
        this = _core.new__base_LinearSubBundle_1(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self) -> "bool":
        return _core._base_LinearSubBundle_1_empty(self)

    def size(self) -> "std::map< long long,elm::ComponentList >::size_type":
        return _core._base_LinearSubBundle_1_size(self)

    def swap(self, v: '_base_LinearSubBundle_1') -> "void":
        return _core._base_LinearSubBundle_1_swap(self, v)

    def begin(self) -> "std::map< long long,elm::ComponentList >::iterator":
        return _core._base_LinearSubBundle_1_begin(self)

    def end(self) -> "std::map< long long,elm::ComponentList >::iterator":
        return _core._base_LinearSubBundle_1_end(self)

    def rbegin(self) -> "std::map< long long,elm::ComponentList >::reverse_iterator":
        return _core._base_LinearSubBundle_1_rbegin(self)

    def rend(self) -> "std::map< long long,elm::ComponentList >::reverse_iterator":
        return _core._base_LinearSubBundle_1_rend(self)

    def clear(self) -> "void":
        return _core._base_LinearSubBundle_1_clear(self)

    def get_allocator(self) -> "std::map< long long,elm::ComponentList >::allocator_type":
        return _core._base_LinearSubBundle_1_get_allocator(self)

    def count(self, x: 'std::map< long long,elm::ComponentList >::key_type const &') -> "std::map< long long,elm::ComponentList >::size_type":
        return _core._base_LinearSubBundle_1_count(self, x)

    def erase(self, *args) -> "void":
        return _core._base_LinearSubBundle_1_erase(self, *args)

    def find(self, x: 'std::map< long long,elm::ComponentList >::key_type const &') -> "std::map< long long,elm::ComponentList >::iterator":
        return _core._base_LinearSubBundle_1_find(self, x)

    def lower_bound(self, x: 'std::map< long long,elm::ComponentList >::key_type const &') -> "std::map< long long,elm::ComponentList >::iterator":
        return _core._base_LinearSubBundle_1_lower_bound(self, x)

    def upper_bound(self, x: 'std::map< long long,elm::ComponentList >::key_type const &') -> "std::map< long long,elm::ComponentList >::iterator":
        return _core._base_LinearSubBundle_1_upper_bound(self, x)
    __swig_destroy__ = _core.delete__base_LinearSubBundle_1
    __del__ = lambda self: None
_base_LinearSubBundle_1_swigregister = _core._base_LinearSubBundle_1_swigregister
_base_LinearSubBundle_1_swigregister(_base_LinearSubBundle_1)

class LinearComponent(object):
    """
    A combination of a parameter and data.

    Parameters
    ----------
    param : str or ParameterRef
    	The name of, or reference to, a parameter.
    data : str or DataRef
    	The name of, or reference to, some data.  This may be a column in
    	a SQLite database, or an expression that can be evaluated, including
    	a number expressed as a string. To express a constant (i.e. a parameter
    	with no data) give 1.0.
    multiplier : float
    	A convenient method to multiply the data by a constant, which can
    	be given as a float instead of a string.
    category : None or int or string or tuple
    	Some LinearComponent's apply only ot certain things.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    data = _swig_property(_core.LinearComponent_data_get, _core.LinearComponent_data_set)
    param = _swig_property(_core.LinearComponent_param_get, _core.LinearComponent_param_set)
    _altcode = _swig_property(_core.LinearComponent__altcode_get, _core.LinearComponent__altcode_set)
    _altname = _swig_property(_core.LinearComponent__altname_get, _core.LinearComponent__altname_set)
    _upcode = _swig_property(_core.LinearComponent__upcode_get, _core.LinearComponent__upcode_set)
    _dncode = _swig_property(_core.LinearComponent__dncode_get, _core.LinearComponent__dncode_set)
    multiplier = _swig_property(_core.LinearComponent_multiplier_get, _core.LinearComponent_multiplier_set)

    def __repr__(self) -> "std::string":
        return _core.LinearComponent___repr__(self)

    def __init__(self, *args, **kwargs):
        this = _core.new_LinearComponent(*args, **kwargs)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    Create = staticmethod(_core.LinearComponent_Create)
    __swig_destroy__ = _core.delete_LinearComponent
    __del__ = lambda self: None

    def altcallsign(self):
    	return "%i: %s"%(self.altcode, self.altname)
    def set_from_callsign(self, x):
    	c,n = x.split(": ")
    	self.altcode = long(c)
    	self.altname = n


    def __add__(self, other: 'LinearComponent') -> "elm::ComponentList":
        return _core.LinearComponent___add__(self, other)
LinearComponent_swigregister = _core.LinearComponent_swigregister
LinearComponent_swigregister(LinearComponent)

def LinearComponent_Create(obj: 'PyObject *') -> "elm::LinearComponent":
    return _core.LinearComponent_Create(obj)
LinearComponent_Create = _core.LinearComponent_Create


_core.COMPONENTLIST_TYPE_UTILITYCA_swigconstant(_core)
COMPONENTLIST_TYPE_UTILITYCA = _core.COMPONENTLIST_TYPE_UTILITYCA

_core.COMPONENTLIST_TYPE_UTILITYCO_swigconstant(_core)
COMPONENTLIST_TYPE_UTILITYCO = _core.COMPONENTLIST_TYPE_UTILITYCO

_core.COMPONENTLIST_TYPE_LOGSUM_swigconstant(_core)
COMPONENTLIST_TYPE_LOGSUM = _core.COMPONENTLIST_TYPE_LOGSUM

_core.COMPONENTLIST_TYPE_EDGE_swigconstant(_core)
COMPONENTLIST_TYPE_EDGE = _core.COMPONENTLIST_TYPE_EDGE

_core.COMPONENTLIST_TYPE_SIMPLECO_swigconstant(_core)
COMPONENTLIST_TYPE_SIMPLECO = _core.COMPONENTLIST_TYPE_SIMPLECO
class LinearFunction(ComponentVector):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    _receiver_type = _swig_property(_core.LinearFunction__receiver_type_get, _core.LinearFunction__receiver_type_set)
    parentmodel = _swig_property(_core.LinearFunction_parentmodel_get, _core.LinearFunction_parentmodel_set)

    def __init__(self, type: 'int'=0, parentmodel: 'Model2'=None):
        this = _core.new_LinearFunction(type, parentmodel)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def receive_utility_ca(self, *args, **kwargs) -> "void":
        return _core.LinearFunction_receive_utility_ca(self, *args, **kwargs)

    def receive_allocation(self, *args, **kwargs) -> "void":
        return _core.LinearFunction_receive_allocation(self, *args, **kwargs)

    def receive_utility_co(self, *args) -> "void":
        return _core.LinearFunction_receive_utility_co(self, *args)

    def receive_utility_co_kwd(self, *args, **kwargs) -> "void":
        return _core.LinearFunction_receive_utility_co_kwd(self, *args, **kwargs)

    def __str__(self) -> "std::string":
        return _core.LinearFunction___str__(self)

    def __repr__(self) -> "std::string":
        return _core.LinearFunction___repr__(self)

    def needs(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.LinearFunction_needs(self)

    def __add__(self, *args) -> "elm::ComponentList":
        return _core.LinearFunction___add__(self, *args)

    def __iadd__(self, *args) -> "elm::ComponentList &":
        return _core.LinearFunction___iadd__(self, *args)
    __swig_destroy__ = _core.delete_LinearFunction
    __del__ = lambda self: None
LinearFunction_swigregister = _core.LinearFunction_swigregister
LinearFunction_swigregister(LinearFunction)

class ComponentCellcodeMap(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, type: 'int'=0, parentmodel: 'Model2'=None):
        this = _core.new_ComponentCellcodeMap(type, parentmodel)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def __repr__(self) -> "std::string":
        return _core.ComponentCellcodeMap___repr__(self)

    def size(self) -> "unsigned int":
        return _core.ComponentCellcodeMap_size(self)

    def empty(self) -> "bool":
        return _core.ComponentCellcodeMap_empty(self)

    def clear(self) -> "void":
        return _core.ComponentCellcodeMap_clear(self)

    def __getitem__(self, key: 'elm::cellcode const &') -> "elm::LinearComponent &":
        return _core.ComponentCellcodeMap___getitem__(self, key)

    def __setitem__(self, key: 'elm::cellcode const &', x: 'LinearComponent') -> "void":
        return _core.ComponentCellcodeMap___setitem__(self, key, x)

    def __delitem__(self, key: 'elm::cellcode const &') -> "void":
        return _core.ComponentCellcodeMap___delitem__(self, key)

    def __contains__(self, key: 'elm::cellcode const &') -> "bool":
        return _core.ComponentCellcodeMap___contains__(self, key)

    def __len__(self) -> "int":
        return _core.ComponentCellcodeMap___len__(self)

    def _create(self, *args) -> "void":
        return _core.ComponentCellcodeMap__create(self, *args)

    def _link(self, parent: 'elm::cellcode const &', child: 'elm::cellcode const &') -> "void":
        return _core.ComponentCellcodeMap__link(self, parent, child)

    def nodes(self) -> "std::vector< elm::cellcode,std::allocator< elm::cellcode > >":
        return _core.ComponentCellcodeMap_nodes(self)
    __swig_destroy__ = _core.delete_ComponentCellcodeMap
    __del__ = lambda self: None
ComponentCellcodeMap_swigregister = _core.ComponentCellcodeMap_swigregister
ComponentCellcodeMap_swigregister(ComponentCellcodeMap)

class LinearCOBundle_1(_base_LinearSubBundle_1):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    parentmodel = _swig_property(_core.LinearCOBundle_1_parentmodel_get, _core.LinearCOBundle_1_parentmodel_set)

    def __init__(self, *args):
        this = _core.new_LinearCOBundle_1(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def metasize(self) -> "size_t":
        return _core.LinearCOBundle_1_metasize(self)

    def __str__(self) -> "std::string":
        return _core.LinearCOBundle_1___str__(self)

    def __repr__(self) -> "std::string":
        return _core.LinearCOBundle_1___repr__(self)

    def needs(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.LinearCOBundle_1_needs(self)

    def add_blank(self, i: 'elm::cellcode const &') -> "elm::ComponentList &":
        return _core.LinearCOBundle_1_add_blank(self, i)

    def _call(self, *args) -> "void":
        return _core.LinearCOBundle_1__call(self, *args)

    def __call__(self, altcode, data, param="", multiplier=1.0):
    	if isinstance(altcode, str) and isinstance(data, int):
    		_ = data
    		data = altcode
    		altcode = _
    	if isinstance(altcode, str) and isinstance(data, str):
    		try:
    			a = DB.alternatives(self.parentmodel, 'reversedict')
    			if altcode in a:
    				altcode = a[altcode]
    			elif data in a:
    				_ = a[data]
    				data = altcode
    				altcode = _
    		except AttributeError:
    			raise TypeError('cannot identify alternative')
    	self._call(altcode, data, param, multiplier)

    __swig_destroy__ = _core.delete_LinearCOBundle_1
    __del__ = lambda self: None
LinearCOBundle_1_swigregister = _core.LinearCOBundle_1_swigregister
LinearCOBundle_1_swigregister(LinearCOBundle_1)

class LinearBundle_1(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    descrip = _swig_property(_core.LinearBundle_1_descrip_get, _core.LinearBundle_1_descrip_set)

    def __init__(self, *args):
        this = _core.new_LinearBundle_1(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def __call__(self, *args) -> "void":
        return _core.LinearBundle_1___call__(self, *args)

    def clean(self, db: 'Facet') -> "void":
        return _core.LinearBundle_1_clean(self, db)

    def __repr__(self) -> "std::string":
        return _core.LinearBundle_1___repr__(self)

    def _set_ca(self, *args) -> "void":
        return _core.LinearBundle_1__set_ca(self, *args)

    def _set_co(self, x: 'LinearCOBundle_1') -> "void":
        return _core.LinearBundle_1__set_co(self, x)

    def _get_ca(self) -> "elm::ComponentList &":
        return _core.LinearBundle_1__get_ca(self)

    def _get_co(self) -> "elm::LinearCOBundle_1 &":
        return _core.LinearBundle_1__get_co(self)

    ca = property(lambda self: self._get_ca(), lambda self,x: self._set_ca(x))
    co = property(lambda self: self._get_co(), lambda self,x: self._set_co(x))

    def __getitem__(self, key):
    	return self._get_co().add_blank(key)
    def __setitem__(self, key, value):
    	self._get_co()[key] = value
    def __delitem__(self, key):
    	del self._get_co()[key]


    __swig_destroy__ = _core.delete_LinearBundle_1
    __del__ = lambda self: None
LinearBundle_1_swigregister = _core.LinearBundle_1_swigregister
LinearBundle_1_swigregister(LinearBundle_1)

class LinearFunctionPair(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    descrip = _swig_property(_core.LinearFunctionPair_descrip_get, _core.LinearFunctionPair_descrip_set)

    def __init__(self, *args):
        this = _core.new_LinearFunctionPair(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def __call__(self, *args) -> "void":
        return _core.LinearFunctionPair___call__(self, *args)

    def clean(self, db: 'Facet') -> "void":
        return _core.LinearFunctionPair_clean(self, db)

    def __repr__(self) -> "std::string":
        return _core.LinearFunctionPair___repr__(self)

    def _set_ca(self, *args) -> "void":
        return _core.LinearFunctionPair__set_ca(self, *args)

    def _set_co(self, *args) -> "void":
        return _core.LinearFunctionPair__set_co(self, *args)

    def _get_ca(self) -> "elm::ComponentList &":
        return _core.LinearFunctionPair__get_ca(self)

    def _get_co(self) -> "elm::ComponentList &":
        return _core.LinearFunctionPair__get_co(self)

    def _set_ca_1(self,x):
    #//if type(x) is ParameterRef: x = LinearComponent(param=str(x), data="1")
    	self._set_ca(x)
    def _set_co_1(self,x):
    #//if type(x) is ParameterRef: x = LinearComponent(param=str(x), data="1")
    	self._set_co(x)
    ca = property(lambda self: self._get_ca(), lambda self,x: self._set_ca_1(x))
    co = property(lambda self: self._get_co(), lambda self,x: self._set_co_1(x))

    __swig_destroy__ = _core.delete_LinearFunctionPair
    __del__ = lambda self: None
LinearFunctionPair_swigregister = _core.LinearFunctionPair_swigregister
LinearFunctionPair_swigregister(LinearFunctionPair)

class LinearCOBundle_2(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    _receiver_type = _swig_property(_core.LinearCOBundle_2__receiver_type_get, _core.LinearCOBundle_2__receiver_type_set)
    parentmodel = _swig_property(_core.LinearCOBundle_2_parentmodel_get, _core.LinearCOBundle_2_parentmodel_set)

    def __init__(self, parentmodel: 'Model2'=None):
        this = _core.new_LinearCOBundle_2(parentmodel)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def __repr__(self) -> "std::string":
        return _core.LinearCOBundle_2___repr__(self)

    def __call__(self, upcode: 'elm::cellcode', dncode: 'elm::cellcode') -> "void":
        return _core.LinearCOBundle_2___call__(self, upcode, dncode)

    def size(self) -> "unsigned int":
        return _core.LinearCOBundle_2_size(self)

    def empty(self) -> "bool":
        return _core.LinearCOBundle_2_empty(self)

    def clear(self) -> "void":
        return _core.LinearCOBundle_2_clear(self)

    def __getitem__(self, key: 'cellcodepair') -> "elm::EdgeValue &":
        return _core.LinearCOBundle_2___getitem__(self, key)

    def __setitem__(self, key: 'cellcodepair', x: 'LinearFunction') -> "void":
        return _core.LinearCOBundle_2___setitem__(self, key, x)

    def __delitem__(self, key: 'cellcodepair') -> "void":
        return _core.LinearCOBundle_2___delitem__(self, key)

    def __contains__(self, key: 'cellcodepair') -> "bool":
        return _core.LinearCOBundle_2___contains__(self, key)

    def __len__(self) -> "int":
        return _core.LinearCOBundle_2___len__(self)

    def links(self) -> "::std::vector< elm::cellcodepair,std::allocator< elm::cellcodepair > >":
        return _core.LinearCOBundle_2_links(self)
    __swig_destroy__ = _core.delete_LinearCOBundle_2
    __del__ = lambda self: None
LinearCOBundle_2_swigregister = _core.LinearCOBundle_2_swigregister
LinearCOBundle_2_swigregister(LinearCOBundle_2)

class ComponentGraphDNA(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    db = _swig_property(_core.ComponentGraphDNA_db_get, _core.ComponentGraphDNA_db_set)
    nodes = _swig_property(_core.ComponentGraphDNA_nodes_get, _core.ComponentGraphDNA_nodes_set)
    edges = _swig_property(_core.ComponentGraphDNA_edges_get, _core.ComponentGraphDNA_edges_set)

    def __init__(self, *args):
        this = _core.new_ComponentGraphDNA(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def __eq__(self, arg2: 'ComponentGraphDNA') -> "bool":
        return _core.ComponentGraphDNA___eq__(self, arg2)

    def valid(self) -> "bool":
        return _core.ComponentGraphDNA_valid(self)

    def node_name(self, node_code: 'elm::cellcode const &') -> "std::string":
        return _core.ComponentGraphDNA_node_name(self, node_code)

    def node_code(self, node_name: 'std::string const &') -> "elm::cellcode":
        return _core.ComponentGraphDNA_node_code(self, node_name)
    root_code = _swig_property(_core.ComponentGraphDNA_root_code_get, _core.ComponentGraphDNA_root_code_set)

    def __repr__(self) -> "std::string":
        return _core.ComponentGraphDNA___repr__(self)

    def elemental_codes(self) -> "elm::cellcodeset":
        return _core.ComponentGraphDNA_elemental_codes(self)

    def all_node_codes(self) -> "elm::cellcodeset":
        return _core.ComponentGraphDNA_all_node_codes(self)

    def nest_node_codes(self) -> "elm::cellcodeset":
        return _core.ComponentGraphDNA_nest_node_codes(self)

    def elemental_names(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.ComponentGraphDNA_elemental_names(self)

    def all_node_names(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.ComponentGraphDNA_all_node_names(self)

    def nest_node_names(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.ComponentGraphDNA_nest_node_names(self)

    def dn_node_codes(self, node_code: 'elm::cellcode const &') -> "elm::cellcodeset":
        return _core.ComponentGraphDNA_dn_node_codes(self, node_code)

    def up_node_codes(self, node_code: 'elm::cellcode const &', include_implicit_root: 'bool'=True) -> "elm::cellcodeset":
        return _core.ComponentGraphDNA_up_node_codes(self, node_code, include_implicit_root)

    def chain_dn_node_codes(self, node_code: 'elm::cellcode const &') -> "elm::cellcodeset":
        return _core.ComponentGraphDNA_chain_dn_node_codes(self, node_code)

    def chain_up_node_codes(self, node_code: 'elm::cellcode const &') -> "elm::cellcodeset":
        return _core.ComponentGraphDNA_chain_up_node_codes(self, node_code)

    def node_callsign(self, altcode):
    	try:
    		return "%i: %s"%(altcode, self.node_name(altcode))
    	except LarchError:
    		return "%i: %s"%(altcode, "alt_%i"%(altcode))
    def elemental_callsigns(self):
    	return [self.node_callsign(j) for j in self.elemental_codes()]
    def all_node_callsigns(self):
    	return [self.node_callsign(j) for j in self.all_node_codes()]
    def nest_node_callsigns(self):
    	return [self.node_callsign(j) for j in self.nest_node_codes()]
    def dn_node_callsigns(self,code):
    	return [self.node_callsign(j) for j in self.dn_node_codes(code)]
    def up_node_callsigns(self,code):
    	return [self.node_callsign(j) for j in self.up_node_codes(code)]
    def up_node_candidate_callsigns(self,code):
    	candidates = self.nest_node_codes()
    	candidates -= self.chain_dn_node_codes(code)
    	candidates -= code
    	candidates += 0
    	return [self.node_callsign(j) for j in candidates]
    def dn_node_candidate_callsigns(self,code):
    	candidates = self.all_node_codes()
    	candidates -= 0
    	candidates -= self.chain_up_node_codes(code)
    	candidates -= code
    	return [self.node_callsign(j) for j in candidates]

    __swig_destroy__ = _core.delete_ComponentGraphDNA
    __del__ = lambda self: None
ComponentGraphDNA_swigregister = _core.ComponentGraphDNA_swigregister
ComponentGraphDNA_swigregister(ComponentGraphDNA)


def __LinearFunction__call(self, *args, **kwargs):
	try:
		if (self._receiver_type==0):
			raise LarchError("LinearFunction improperly initialized")
		elif (self._receiver_type & COMPONENTLIST_TYPE_UTILITYCA):
			self.receive_utility_ca(*args, **kwargs)
		elif (self._receiver_type & COMPONENTLIST_TYPE_UTILITYCO):
			if len(kwargs)>0 and len(args)==0:
				self.receive_utility_co_kwd(**kwargs)
			elif len(kwargs)==0 and len(args)>0:
				if len(args)<2: raise LarchError("LinearFunction for co type requires at least two arguments: data and alt")
				self.receive_utility_co(*args)
			else:
				raise LarchError("LinearFunction for co type requires all-or-none use of keyword arguments")
		elif (self._receiver_type & COMPONENTLIST_TYPE_EDGE):
			self.receive_allocation(*args, **kwargs)
		else:
			raise LarchError("LinearFunction Not Implemented for type %i list"%self._receiver_type)
####if self.parentmodel:
####	self.parentmodel.freshen()
	except TypeError:
		for arg in args:
			print('type=',type(arg), 'value=',arg)
		for key,arg in kwargs.items():
			print('key=',key,'type=',type(arg), 'value=',arg)
		raise
LinearFunction.__call__ = __LinearFunction__call
del __LinearFunction__call
LinearFunction.__long_len = LinearFunction.__len__
LinearFunction.__len__ = lambda self: int(self.__long_len())

def __ComponentCellcodeMap__call(self, nest_name, nest_code=None, param_name="", multiplier=1.0, parent=None, parents=None, children=None):
	if isinstance(nest_name,(int,)) and nest_code is None:
		nest_name, nest_code = "nest%i"%nest_name, nest_name
	if isinstance(nest_name,(int,)) and isinstance(nest_code,(str,)):
		nest_name, nest_code = nest_code, nest_name
	self._create(nest_name, nest_code, param_name, multiplier)
	if parent is not None:
		self._link(parent,nest_code)
	if parents is not None:
		for p in parents: self._link(p,nest_code)
	if children is not None:
		for c in children: self._link(nest_code,c)
####if self.parentmodel:
####	self.parentmodel.freshen()
	return self[nest_code]
ComponentCellcodeMap.__call__ = __ComponentCellcodeMap__call
del __ComponentCellcodeMap__call

class model_options_t(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    gradient_diagnostic = _swig_property(_core.model_options_t_gradient_diagnostic_get, _core.model_options_t_gradient_diagnostic_set)
    hessian_diagnostic = _swig_property(_core.model_options_t_hessian_diagnostic_get, _core.model_options_t_hessian_diagnostic_set)
    threads = _swig_property(_core.model_options_t_threads_get, _core.model_options_t_threads_set)
    calc_null_likelihood = _swig_property(_core.model_options_t_calc_null_likelihood_get, _core.model_options_t_calc_null_likelihood_set)
    null_disregards_holdfast = _swig_property(_core.model_options_t_null_disregards_holdfast_get, _core.model_options_t_null_disregards_holdfast_set)
    calc_std_errors = _swig_property(_core.model_options_t_calc_std_errors_get, _core.model_options_t_calc_std_errors_set)
    mute_nan_warnings = _swig_property(_core.model_options_t_mute_nan_warnings_get, _core.model_options_t_mute_nan_warnings_set)
    force_finite_diff_grad = _swig_property(_core.model_options_t_force_finite_diff_grad_get, _core.model_options_t_force_finite_diff_grad_set)
    save_db_hash = _swig_property(_core.model_options_t_save_db_hash_get, _core.model_options_t_save_db_hash_set)
    force_recalculate = _swig_property(_core.model_options_t_force_recalculate_get, _core.model_options_t_force_recalculate_set)
    teardown_after_estimate = _swig_property(_core.model_options_t_teardown_after_estimate_get, _core.model_options_t_teardown_after_estimate_set)
    weight_autorescale = _swig_property(_core.model_options_t_weight_autorescale_get, _core.model_options_t_weight_autorescale_set)
    weight_choice_rebalance = _swig_property(_core.model_options_t_weight_choice_rebalance_get, _core.model_options_t_weight_choice_rebalance_set)
    suspend_xylem_rebuild = _swig_property(_core.model_options_t_suspend_xylem_rebuild_get, _core.model_options_t_suspend_xylem_rebuild_set)
    log_turns = _swig_property(_core.model_options_t_log_turns_get, _core.model_options_t_log_turns_set)
    enforce_bounds = _swig_property(_core.model_options_t_enforce_bounds_get, _core.model_options_t_enforce_bounds_set)
    enforce_constraints = _swig_property(_core.model_options_t_enforce_constraints_get, _core.model_options_t_enforce_constraints_set)
    idca_avail_ratio_floor = _swig_property(_core.model_options_t_idca_avail_ratio_floor_get, _core.model_options_t_idca_avail_ratio_floor_set)
    author = _swig_property(_core.model_options_t_author_get, _core.model_options_t_author_set)

    def __init__(self, *args, **kwargs):
        this = _core.new_model_options_t(*args, **kwargs)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def __call__(self, *args, **kwargs) -> "void":
        return _core.model_options_t___call__(self, *args, **kwargs)

    def copy(self, other: 'model_options_t') -> "void":
        return _core.model_options_t_copy(self, other)

    def __repr__(self) -> "std::string":
        return _core.model_options_t___repr__(self)

    def __str__(self) -> "std::string":
        return _core.model_options_t___str__(self)

    def _save_buffer(self) -> "std::string":
        return _core.model_options_t__save_buffer(self)

    def __getitem__(self, k):
    	return getattr(self, k)
    def __setitem__(self, k, v):
    	return setattr(self, k, v)
    def _as_dict(self):
    	keys = dir(self)
    	dct = {}
    	for k in keys:
    		if k[0:2]!="__" and k not in ['copy', 'this', 'thisown', '_as_dict']:
    			dct[k] = getattr(self, k)
    	return dct
    def __setattr__(self, key, value):
    	if key not in dir(self) and key not in ['copy', 'this', 'thisown', '_as_dict']:
    		raise TypeError( "cannot create the new attribute '%s' for %s" % (str(key),str(type(self))) )
    	super(model_options_t, self).__setattr__(key, value)

    __swig_destroy__ = _core.delete_model_options_t
    __del__ = lambda self: None
model_options_t_swigregister = _core.model_options_t_swigregister
model_options_t_swigregister(model_options_t)

class runstats(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    iteration = _swig_property(_core.runstats_iteration_get, _core.runstats_iteration_set)
    results = _swig_property(_core.runstats_results_get, _core.runstats_results_set)
    timestamp = _swig_property(_core.runstats_timestamp_get, _core.runstats_timestamp_set)
    number_threads = _swig_property(_core.runstats_number_threads_get, _core.runstats_number_threads_set)
    number_cpu_cores = _swig_property(_core.runstats_number_cpu_cores_get, _core.runstats_number_cpu_cores_set)
    processor = _swig_property(_core.runstats_processor_get, _core.runstats_processor_set)
    process_label = _swig_property(_core.runstats_process_label_get, _core.runstats_process_label_set)
    process_starttime = _swig_property(_core.runstats_process_starttime_get, _core.runstats_process_starttime_set)
    process_endtime = _swig_property(_core.runstats_process_endtime_get, _core.runstats_process_endtime_set)
    _notes = _swig_property(_core.runstats__notes_get, _core.runstats__notes_set)

    def elapsed_time(self) -> "double":
        return _core.runstats_elapsed_time(self)

    def runtime_seconds(self) -> "double":
        return _core.runstats_runtime_seconds(self)

    def runtime(self) -> "std::string":
        return _core.runstats_runtime(self)

    def __init__(self, *args):
        this = _core.new_runstats(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _core.delete_runstats
    __del__ = lambda self: None

    def other(self) -> "PyObject *":
        return _core.runstats_other(self)

    def set_other(self, other: 'PyObject *') -> "void":
        return _core.runstats_set_other(self, other)

    def prepend_timing(self, previously: 'runstats') -> "void":
        return _core.runstats_prepend_timing(self, previously)

    def append_timing(self, subsequently: 'runstats') -> "void":
        return _core.runstats_append_timing(self, subsequently)

    def notes(self) -> "std::string":
        return _core.runstats_notes(self)

    def write(self, *args) -> "void":
        return _core.runstats_write(self, *args)

    def flush(self) -> "void":
        return _core.runstats_flush(self)

    def write_result(self, *args) -> "void":
        return _core.runstats_write_result(self, *args)

    def __repr__(self) -> "std::string":
        return _core.runstats___repr__(self)

    def dictionary(self) -> "PyObject *":
        return _core.runstats_dictionary(self)

    def pickled_dictionary(self) -> "std::string":
        return _core.runstats_pickled_dictionary(self)

    def read_from_dictionary(self, dictionary: 'PyObject *') -> "void":
        return _core.runstats_read_from_dictionary(self, dictionary)

    def start_process(self, name: 'std::string const &') -> "void":
        return _core.runstats_start_process(self, name)

    def end_process(self) -> "void":
        return _core.runstats_end_process(self)

    def process_duration(self, *args) -> "double":
        return _core.runstats_process_duration(self, *args)

    def total_duration(self) -> "double":
        return _core.runstats_total_duration(self)

    def process_duration_fancy(self, *args) -> "std::string":
        return _core.runstats_process_duration_fancy(self, *args)

    def total_duration_fancy(self) -> "std::string":
        return _core.runstats_total_duration_fancy(self)

    def __getstate__(self) -> "PyObject *":
        return _core.runstats___getstate__(self)

    def __setstate__(self, state):
    	self.__init__()
    	self.read_from_dictionary(state)

runstats_swigregister = _core.runstats_swigregister
runstats_swigregister(runstats)

class Needs(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.Needs_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.Needs___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.Needs___bool__(self)

    def __len__(self) -> "std::map< std::string,elm::darray_req >::size_type":
        return _core.Needs___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< std::string,elm::darray_req >::key_type const &') -> "std::map< std::string,elm::darray_req >::mapped_type const &":
        return _core.Needs___getitem__(self, key)

    def __delitem__(self, key: 'std::map< std::string,elm::darray_req >::key_type const &') -> "void":
        return _core.Needs___delitem__(self, key)

    def has_key(self, key: 'std::map< std::string,elm::darray_req >::key_type const &') -> "bool":
        return _core.Needs_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _core.Needs_keys(self)

    def values(self) -> "PyObject *":
        return _core.Needs_values(self)

    def items(self) -> "PyObject *":
        return _core.Needs_items(self)

    def __contains__(self, key: 'std::map< std::string,elm::darray_req >::key_type const &') -> "bool":
        return _core.Needs___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _core.Needs_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _core.Needs_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _core.Needs___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _core.Needs_asdict(self)

    def __init__(self, *args):
        this = _core.new_Needs(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self) -> "bool":
        return _core.Needs_empty(self)

    def size(self) -> "std::map< std::string,elm::darray_req >::size_type":
        return _core.Needs_size(self)

    def swap(self, v: 'Needs') -> "void":
        return _core.Needs_swap(self, v)

    def begin(self) -> "std::map< std::string,elm::darray_req >::iterator":
        return _core.Needs_begin(self)

    def end(self) -> "std::map< std::string,elm::darray_req >::iterator":
        return _core.Needs_end(self)

    def rbegin(self) -> "std::map< std::string,elm::darray_req >::reverse_iterator":
        return _core.Needs_rbegin(self)

    def rend(self) -> "std::map< std::string,elm::darray_req >::reverse_iterator":
        return _core.Needs_rend(self)

    def clear(self) -> "void":
        return _core.Needs_clear(self)

    def get_allocator(self) -> "std::map< std::string,elm::darray_req >::allocator_type":
        return _core.Needs_get_allocator(self)

    def count(self, x: 'std::map< std::string,elm::darray_req >::key_type const &') -> "std::map< std::string,elm::darray_req >::size_type":
        return _core.Needs_count(self, x)

    def erase(self, *args) -> "void":
        return _core.Needs_erase(self, *args)

    def find(self, x: 'std::map< std::string,elm::darray_req >::key_type const &') -> "std::map< std::string,elm::darray_req >::iterator":
        return _core.Needs_find(self, x)

    def lower_bound(self, x: 'std::map< std::string,elm::darray_req >::key_type const &') -> "std::map< std::string,elm::darray_req >::iterator":
        return _core.Needs_lower_bound(self, x)

    def upper_bound(self, x: 'std::map< std::string,elm::darray_req >::key_type const &') -> "std::map< std::string,elm::darray_req >::iterator":
        return _core.Needs_upper_bound(self, x)

    def __repr__(self):
    	return "<Needs:" + ",".join(["{}({})".format(i,len(j.get_variables())) for i,j in self.items()]) + ">"

    __swig_destroy__ = _core.delete_Needs
    __del__ = lambda self: None
Needs_swigregister = _core.Needs_swigregister
Needs_swigregister(Needs)

class darray_req(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    dtype = _swig_property(_core.darray_req_dtype_get, _core.darray_req_dtype_set)
    dimty = _swig_property(_core.darray_req_dimty_get, _core.darray_req_dimty_set)
    n_alts = _swig_property(_core.darray_req_n_alts_get, _core.darray_req_n_alts_set)
    contig = _swig_property(_core.darray_req_contig_get, _core.darray_req_contig_set)

    def __init__(self, *args):
        this = _core.new_darray_req(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _core.delete_darray_req
    __del__ = lambda self: None

    def nVars(self) -> "size_t":
        return _core.darray_req_nVars(self)

    def nAlts(self) -> "size_t":
        return _core.darray_req_nAlts(self)

    def get_variables(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        return _core.darray_req_get_variables(self)

    def set_variables(self, v: 'StrVector') -> "void":
        return _core.darray_req_set_variables(self, v)

    def __str__(self) -> "std::string":
        return _core.darray_req___str__(self)

    def __repr__(self) -> "std::string":
        return _core.darray_req___repr__(self)

    def satisfied_by(self, x: 'elm::darray const *') -> "int":
        return _core.darray_req_satisfied_by(self, x)
darray_req_swigregister = _core.darray_req_swigregister
darray_req_swigregister(darray_req)

class darray_export_map(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, caseindexes: 'etk::ndarray *'=None, altindexes: 'etk::ndarray *'=None, data_array: 'etk::ndarray *'=None, n_cases: 'size_t const &'=0, n_alts: 'size_t const &'=0):
        this = _core.new_darray_export_map(caseindexes, altindexes, data_array, n_cases, n_alts)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _core.delete_darray_export_map
    __del__ = lambda self: None

    def maplink(self, caseindexes: 'etk::ndarray *', altindexes: 'etk::ndarray *', data_array: 'etk::ndarray *', n_cases: 'size_t const &', n_alts: 'size_t const &') -> "void":
        return _core.darray_export_map_maplink(self, caseindexes, altindexes, data_array, n_cases, n_alts)

    def clear(self) -> "void":
        return _core.darray_export_map_clear(self)

    def get_ptr_at(self, caseindex: 'long long const &', altindex: 'long long const &') -> "double const *":
        return _core.darray_export_map_get_ptr_at(self, caseindex, altindex)

    def export_into(self, ExportTo: 'double *', c: 'unsigned int const &', a: 'unsigned int const &', numberOfVars: 'unsigned int const &') -> "void":
        return _core.darray_export_map_export_into(self, ExportTo, c, a, numberOfVars)

    def get_value_at(self, caseindex: 'long long const &', altindex: 'long long const &', varindex: 'long long const &') -> "double":
        return _core.darray_export_map_get_value_at(self, caseindex, altindex, varindex)

    def active(self) -> "bool":
        return _core.darray_export_map_active(self)

    def nvars(self) -> "size_t":
        return _core.darray_export_map_nvars(self)

    def nrows(self) -> "size_t":
        return _core.darray_export_map_nrows(self)

    def ncases(self) -> "size_t const &":
        return _core.darray_export_map_ncases(self)

    def nalts(self) -> "size_t const &":
        return _core.darray_export_map_nalts(self)
darray_export_map_swigregister = _core.darray_export_map_swigregister
darray_export_map_swigregister(darray_export_map)


def check_darray(x: 'elm::darray const *') -> "std::string":
    return _core.check_darray(x)
check_darray = _core.check_darray
class ParameterList(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    _parameter_name_index = _swig_property(_core.ParameterList__parameter_name_index_get, _core.ParameterList__parameter_name_index_set)

    def __init__(self, *args):
        this = _core.new_ParameterList(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def __contains__(self, param_name: 'std::string const &') -> "bool":
        return _core.ParameterList___contains__(self, param_name)

    def _len(self) -> "size_t":
        return _core.ParameterList__len(self)

    def parameter_index(self, param_name: 'std::string const &') -> "size_t":
        return _core.ParameterList_parameter_index(self, param_name)

    def zeros(self) -> "PyObject *":
        return _core.ParameterList_zeros(self)

    def constraints(self) -> "PyObject *":
        return _core.ParameterList_constraints(self)

    def tearDown(self) -> "void":
        return _core.ParameterList_tearDown(self)

    def freshen(self) -> "void":
        return _core.ParameterList_freshen(self)
    __swig_destroy__ = _core.delete_ParameterList
    __del__ = lambda self: None
ParameterList_swigregister = _core.ParameterList_swigregister
ParameterList_swigregister(ParameterList)


ParameterList.__len__ = lambda self: int(self._len())

class ParameterAlias(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_core.ParameterAlias_name_get, _core.ParameterAlias_name_set)
    refers_to = _swig_property(_core.ParameterAlias_refers_to_get, _core.ParameterAlias_refers_to_set)
    multiplier = _swig_property(_core.ParameterAlias_multiplier_get, _core.ParameterAlias_multiplier_set)
    _refers_to_modelparam = _swig_property(_core.ParameterAlias__refers_to_modelparam_get, _core.ParameterAlias__refers_to_modelparam_set)

    def get_referred_modelparam(self) -> "PyObject *":
        return _core.ParameterAlias_get_referred_modelparam(self)

    def set_referred_modelparam(self, arg2: 'PyObject *') -> "void":
        return _core.ParameterAlias_set_referred_modelparam(self, arg2)
    __swig_destroy__ = _core.delete_ParameterAlias
    __del__ = lambda self: None

    def __init__(self, name: 'std::string const &', refers_to: 'std::string const &', multiplier: 'double const &'):
        this = _core.new_ParameterAlias(name, refers_to, multiplier)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    @property
    def value(self):
    	return self.multiplier * self.get_referred_modelparam().value
    @property
    def null_value(self):
    	return self.multiplier * self.get_referred_modelparam().null_value
    @property
    def t_stat(self):
    	if self.multiplier == 1:
    		return "= {}".format(self.refers_to)
    	elif self.multiplier == 0:
    		return "= 0"
    	else:
    		return "= {} * {}".format(self.refers_to,self.multiplier)
    def __getitem__(self, *arg):
    	return self.__getattribute__(*arg)


ParameterAlias_swigregister = _core.ParameterAlias_swigregister
ParameterAlias_swigregister(ParameterAlias)

class Parameter(object):
    """
    This object represents a discrete choice model parameter.

    Parameters
    ----------
    name : str
    	The name of the parameter. This name is used both in commands
    	that refer to this parameter, as well as in reports. Generally
    	it is best to choose a short but descriptive name that does
    	not include any special characters, although any unicode string
    	should be acceptable.
    value : float
    	This value represents the current value of the parameter.
    null_value : float
    	This value represents the default value of the parameter, which
    	would be assumed if no information is available. It is generally
    	zero, although for some parameters -- notably the logsum parameters
    	in a nest logit model, but also certain others -- the default value
    	might be one, or some other value.
    holdfast : bool
    	Sets the holdfast attribute. When True, the value of this parameter
    	is held constant during parameter estimation.

    Other Parameters
    ----------------
    initial_value : float
    	The initial value of the parameter. This is where the
    	search algorithm began.
    std_err, robust_std_err : float
    	This is the standard error of the estimate of this parameter. The
    	standard error is derived from the curvature of the log likelihood
    	function at its maximum. The robust standard error of the estimate
    	is derived from the sandwich estimator.
    covariance, robust_covariance : dict
    	These are dictionary with parameter names as keys and floats
    	as values, representing the (robust) covariance between this estimator
    	and the other estimators in the model.

    Notes
    -----
    It is not usually necessary to define the 'other parameters' explicitly.
    The values are normally derived as an outcome of the model estimation
    process, and the ability to set them here is provided to allow
    the save and load methods to accurately
    recreate a model with all attributes intact.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    name = _swig_property(_core.Parameter_name_get, _core.Parameter_name_set)
    value = _swig_property(_core.Parameter_value_get, _core.Parameter_value_set)
    null_value = _swig_property(_core.Parameter_null_value_get, _core.Parameter_null_value_set)
    initial_value = _swig_property(_core.Parameter_initial_value_get, _core.Parameter_initial_value_set)
    std_err = _swig_property(_core.Parameter_std_err_get, _core.Parameter_std_err_set)
    robust_std_err = _swig_property(_core.Parameter_robust_std_err_get, _core.Parameter_robust_std_err_set)
    max_value = _swig_property(_core.Parameter_max_value_get, _core.Parameter_max_value_set)
    min_value = _swig_property(_core.Parameter_min_value_get, _core.Parameter_min_value_set)
    holdfast = _swig_property(_core.Parameter_holdfast_get, _core.Parameter_holdfast_set)
    _covar = _swig_property(_core.Parameter__covar_get, _core.Parameter__covar_set)
    _robust_covar = _swig_property(_core.Parameter__robust_covar_get, _core.Parameter__robust_covar_set)

    def getCovariance(self) -> "PyObject *":
        return _core.Parameter_getCovariance(self)

    def setCovariance(self, covariance: 'PyObject *') -> "void":
        return _core.Parameter_setCovariance(self, covariance)

    def getRobustCovariance(self) -> "PyObject *":
        return _core.Parameter_getRobustCovariance(self)

    def setRobustCovariance(self, covariance: 'PyObject *') -> "void":
        return _core.Parameter_setRobustCovariance(self, covariance)

    def t_stat(self) -> "double":
        """
        Calculates the t statistic against the null value of the parameter. 

        The t statistic is calculated as value - null_value)/std_err.
        """
        return _core.Parameter_t_stat(self)


    def representation(self, pretty: 'bool'=True) -> "std::string":
        return _core.Parameter_representation(self, pretty)

    def __init__(self, *args, **kwargs):
        """
        __init__(freedom_info self, std::string const & name, double const & value=0, double const & null_value=0, int const & holdfast=0, double const & initial_value, double const & std_err, double const & robust_std_err, double const & min_value, double const & max_value, PyObject * covariance=None, PyObject * robust_covariance=None) -> Parameter

        This object represents a discrete choice model parameter.

        Parameters
        ----------
        name : str
        	The name of the parameter. This name is used both in commands
        	that refer to this parameter, as well as in reports. Generally
        	it is best to choose a short but descriptive name that does
        	not include any special characters, although any unicode string
        	should be acceptable.
        value : float
        	This value represents the current value of the parameter.
        null_value : float
        	This value represents the default value of the parameter, which
        	would be assumed if no information is available. It is generally
        	zero, although for some parameters -- notably the logsum parameters
        	in a nest logit model, but also certain others -- the default value
        	might be one, or some other value.
        holdfast : bool
        	Sets the holdfast attribute. When True, the value of this parameter
        	is held constant during parameter estimation.

        Other Parameters
        ----------------
        initial_value : float
        	The initial value of the parameter. This is where the
        	search algorithm began.
        std_err, robust_std_err : float
        	This is the standard error of the estimate of this parameter. The
        	standard error is derived from the curvature of the log likelihood
        	function at its maximum. The robust standard error of the estimate
        	is derived from the sandwich estimator.
        covariance, robust_covariance : dict
        	These are dictionary with parameter names as keys and floats
        	as values, representing the (robust) covariance between this estimator
        	and the other estimators in the model.

        Notes
        -----
        It is not usually necessary to define the 'other parameters' explicitly.
        The values are normally derived as an outcome of the model estimation
        process, and the ability to set them here is provided to allow
        the save and load methods to accurately
        recreate a model with all attributes intact.
        """
        this = _core.new_Parameter(*args, **kwargs)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _core.delete_Parameter
    __del__ = lambda self: None

    def update(self, *args) -> "void":
        return _core.Parameter_update(self, *args)

    def __str__(self, z: 'void *'=None) -> "std::string":
        return _core.Parameter___str__(self, z)

    def __repr__(self, z: 'void *'=None) -> "std::string":
        return _core.Parameter___repr__(self, z)

    covariance = _swig_property(getCovariance, setCovariance)
    robust_covariance = _swig_property(getRobustCovariance, setRobustCovariance)
    def __getitem__(self, *arg):
    	return self.__getattribute__(*arg)

    def t_stat_signif(self, df=None):
    	'''Calulates the significance level of the t-test.

    	When df is not given, the reported value is calculated as
    	:math:`2(1-\Phi(t))`, with :math:`\Phi(t)` as the CDF of a the standard
    	normal distribution evaluated at :math:`t`. When df is given, the
    	t distribution with the indicated number of degrees of freedom is
    	used in place of the normal diatribution. In most discrete choice modeling
    	scenarios, the number of degrees of freedom is large enough that the
    	resulting values are indistinguishable.
    	'''
    	import scipy.stats
    	t = self.t_stat()
    	if df is None:
    		return 2.0*scipy.stats.norm.sf(abs(t), loc=0, scale=1)
    	return 2.0*scipy.stats.t.sf(abs(t), df, loc=0, scale=1)

Parameter_swigregister = _core.Parameter_swigregister
Parameter_swigregister(Parameter)


def algorithm_name(algo: 'char const &') -> "std::string":
    return _core.algorithm_name(algo)
algorithm_name = _core.algorithm_name
class sherpa_result(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    starting_obj_value = _swig_property(_core.sherpa_result_starting_obj_value_get, _core.sherpa_result_starting_obj_value_set)
    best_obj_value = _swig_property(_core.sherpa_result_best_obj_value_get, _core.sherpa_result_best_obj_value_set)
    result = _swig_property(_core.sherpa_result_result_get, _core.sherpa_result_result_set)
    explain_stop = _swig_property(_core.sherpa_result_explain_stop_get, _core.sherpa_result_explain_stop_set)

    def __init__(self):
        this = _core.new_sherpa_result()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _core.delete_sherpa_result
    __del__ = lambda self: None
sherpa_result_swigregister = _core.sherpa_result_swigregister
sherpa_result_swigregister(sherpa_result)

class sherpa(ParameterList):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    _LL_current = _swig_property(_core.sherpa__LL_current_get, _core.sherpa__LL_current_set)
    _LL_best = _swig_property(_core.sherpa__LL_best_get, _core.sherpa__LL_best_set)
    max_iterations = _swig_property(_core.sherpa_max_iterations_get, _core.sherpa_max_iterations_set)

    def robust_covariance_matrix(self) -> "etk::symmetric_matrix *":
        return _core.sherpa_robust_covariance_matrix(self)

    def __init__(self, *args):
        this = _core.new_sherpa(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def any_holdfast(self) -> "bool":
        return _core.sherpa_any_holdfast(self)

    def count_holdfast(self) -> "size_t":
        return _core.sherpa_count_holdfast(self)

    def hessfull_to_hessfree(self, full_matrix: 'etk::symmetric_matrix const *', free_matrix: 'etk::symmetric_matrix *') -> "void":
        return _core.sherpa_hessfull_to_hessfree(self, full_matrix, free_matrix)

    def hessfree_to_hessfull(self, full_matrix: 'etk::symmetric_matrix *', free_matrix: 'etk::symmetric_matrix const *') -> "void":
        return _core.sherpa_hessfree_to_hessfull(self, full_matrix, free_matrix)

    def resize_allocated_memory(self) -> "void":
        return _core.sherpa_resize_allocated_memory(self)

    def _get_inverse_hessian_array(self) -> "etk::symmetric_matrix *":
        return _core.sherpa__get_inverse_hessian_array(self)

    def _set_inverse_hessian_array(self, arg2: 'etk::symmetric_matrix *') -> "void":
        return _core.sherpa__set_inverse_hessian_array(self, arg2)

    def _del_inverse_hessian_array(self) -> "void":
        return _core.sherpa__del_inverse_hessian_array(self)

    def _get_robust_covar_array(self) -> "etk::symmetric_matrix *":
        return _core.sherpa__get_robust_covar_array(self)

    def _set_robust_covar_array(self, arg2: 'etk::symmetric_matrix *') -> "void":
        return _core.sherpa__set_robust_covar_array(self, arg2)

    def _del_robust_covar_array(self) -> "void":
        return _core.sherpa__del_robust_covar_array(self)

    def _get_parameter_array(self) -> "etk::ndarray *":
        return _core.sherpa__get_parameter_array(self)

    def _get_parameter_minbound_array(self) -> "etk::ndarray *":
        return _core.sherpa__get_parameter_minbound_array(self)

    def _get_parameter_maxbound_array(self) -> "etk::ndarray *":
        return _core.sherpa__get_parameter_maxbound_array(self)

    def _get_holdfast_array(self) -> "etk::ndarray *":
        return _core.sherpa__get_holdfast_array(self)

    def _get_null_values_array(self) -> "etk::ndarray *":
        return _core.sherpa__get_null_values_array(self)

    def _get_init_values_array(self) -> "etk::ndarray *":
        return _core.sherpa__get_init_values_array(self)

    def _set_parameter_array(self, arg2: 'etk::ndarray *') -> "void":
        return _core.sherpa__set_parameter_array(self, arg2)

    def _set_parameter_minbound_array(self, arg2: 'etk::ndarray *') -> "void":
        return _core.sherpa__set_parameter_minbound_array(self, arg2)

    def _set_parameter_maxbound_array(self, arg2: 'etk::ndarray *') -> "void":
        return _core.sherpa__set_parameter_maxbound_array(self, arg2)

    def _set_holdfast_array(self, arg2: 'etk::ndarray *') -> "void":
        return _core.sherpa__set_holdfast_array(self, arg2)

    def _set_null_values_array(self, arg2: 'etk::ndarray *') -> "void":
        return _core.sherpa__set_null_values_array(self, arg2)

    def _set_init_values_array(self, arg2: 'etk::ndarray *') -> "void":
        return _core.sherpa__set_init_values_array(self, arg2)

    parameter_array = property(_get_parameter_array, None, None, "An array of current parameter values")
    parameter_minimums = property(_get_parameter_minbound_array, None, None, "An array of minimum parameter values")
    parameter_maximums = property(_get_parameter_maxbound_array, None, None, "An array of maximum parameter values")
    parameter_holdfast_array = property(_get_holdfast_array, None, None, "An array of current holdfast flags")
    parameter_initial_values_array = property(_get_init_values_array, None, None, "An array of initial parameter values")
    parameter_null_values_array = property(_get_null_values_array, None, None, "An array of parameter null values")


    def parameter(self, *args, **kwargs) -> "elm::ModelParameter":
        return _core.sherpa_parameter(self, *args, **kwargs)

    def __getitem__(self, *args) -> "elm::ModelParameter":
        return _core.sherpa___getitem__(self, *args)

    def alias(self, *args) -> "freedom_alias &":
        return _core.sherpa_alias(self, *args)

    def del_alias(self, alias_name: 'std::string const &') -> "void":
        return _core.sherpa_del_alias(self, alias_name)

    def unlink_alias(self, alias_name: 'std::string const &') -> "void":
        return _core.sherpa_unlink_alias(self, alias_name)
    __swig_destroy__ = _core.delete_sherpa
    __del__ = lambda self: None
sherpa_swigregister = _core.sherpa_swigregister
sherpa_swigregister(sherpa)

class Model2(sherpa):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def _xylem(self) -> "elm::VAS_System const &":
        return _core.Model2__xylem(self)

    def _sayweakself(self, *args) -> "void":
        return _core.Model2__sayweakself(self, *args)

    def _setweakself(self, ref_to_self: 'PyObject *') -> "void":
        return _core.Model2__setweakself(self, ref_to_self)

    def _get_root_cellcode(self) -> "elm::cellcode":
        return _core.Model2__get_root_cellcode(self)

    def _set_root_cellcode(self, r: 'elm::cellcode const &') -> "void":
        return _core.Model2__set_root_cellcode(self, r)
    _nCases_recall = _swig_property(_core.Model2__nCases_recall_get, _core.Model2__nCases_recall_set)

    def _force_feed(self, forced_features: 'int') -> "void":
        return _core.Model2__force_feed(self, forced_features)

    def freshen(self) -> "void":
        return _core.Model2_freshen(self)

    def CoefUtilityCA(self) -> "PyObject *":
        return _core.Model2_CoefUtilityCA(self)

    def CoefUtilityCO(self) -> "PyObject *":
        return _core.Model2_CoefUtilityCO(self)

    def Coef(self, label: 'std::string const &') -> "etk::ndarray const *":
        return _core.Model2_Coef(self, label)

    def needs(self) -> "std::map< std::string,elm::darray_req,std::less< std::string >,std::allocator< std::pair< std::string const,elm::darray_req > > >":
        val = _core.Model2_needs(self)

        temp = {}
        for i,j in val.items(): temp[i] = j
        val = temp


        return val


    def provision(self, *args) -> "void":

        if len(args)==0:
        	if hasattr(self,'db') and isinstance(self.db,(DB,DT)):
        		args = (self.db.provision(self.needs()), )
        	else:
        		raise LarchError('model has no db specified for provisioning')


        return _core.Model2_provision(self, *args)


    def is_provisioned(self, ex: 'bool'=False) -> "int":
        return _core.Model2_is_provisioned(self, ex)

    def Data(self, label: 'std::string const &') -> "elm::darray const *":
        return _core.Model2_Data(self, label)

    def DataEdit(self, label: 'std::string const &') -> "elm::darray *":
        return _core.Model2_DataEdit(self, label)
    Data_UtilityCE_manual = _swig_property(_core.Model2_Data_UtilityCE_manual_get, _core.Model2_Data_UtilityCE_manual_set)
    Data_UtilityCE_builtin = _swig_property(_core.Model2_Data_UtilityCE_builtin_get, _core.Model2_Data_UtilityCE_builtin_set)

    def get_weight_scale_factor(self) -> "double":
        return _core.Model2_get_weight_scale_factor(self)

    def auto_rescale_weights(self, mean_weight: 'double const &'=1.0) -> "std::string":
        return _core.Model2_auto_rescale_weights(self, mean_weight)

    def restore_scale_weights(self) -> "void":
        return _core.Model2_restore_scale_weights(self)

    def clear_cache(self) -> "void":
        return _core.Model2_clear_cache(self)

    def loglike(self) -> "double":
        return _core.Model2_loglike(self)

    def loglike_casewise(self, *args) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_loglike_casewise(self, *args)

    def _gradient_casewise(self, *args) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2__gradient_casewise(self, *args)

    def finite_diff_gradient(self, *args) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_finite_diff_gradient(self, *args)

    def calc_utility(self, *args) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_calc_utility(self, *args)

    def calc_probability(self, u: 'etk::ndarray *') -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_calc_probability(self, u)

    def calc_logsums(self, u: 'etk::ndarray *') -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_calc_logsums(self, u)

    def calc_utility_probability(self, utilitydataco: 'etk::ndarray *', utilitydataca: 'etk::ndarray *'=None, availability: 'etk::ndarray *'=None) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_calc_utility_probability(self, utilitydataco, utilitydataca, availability)

    def calc_utility_logsums(self, utilitydataco: 'etk::ndarray *', utilitydataca: 'etk::ndarray *'=None, availability: 'etk::ndarray *'=None) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_calc_utility_logsums(self, utilitydataco, utilitydataca, availability)

    def loglike_given_utility(self) -> "double":
        return _core.Model2_loglike_given_utility(self)

    def negative_d_loglike_given_utility(self) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_negative_d_loglike_given_utility(self)

    def calculate_parameter_covariance(self) -> "void":
        return _core.Model2_calculate_parameter_covariance(self)

    def _mnl_gradient_full_casewise(self) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2__mnl_gradient_full_casewise(self)

    def _ngev_gradient_full_casewise(self) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2__ngev_gradient_full_casewise(self)

    def _ngev_d_prob(self) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2__ngev_d_prob(self)

    def log_likelihood_from_prob(self, probarray: 'etk::ndarray *') -> "double":
        return _core.Model2_log_likelihood_from_prob(self, probarray)
    _LL_null = _swig_property(_core.Model2__LL_null_get, _core.Model2__LL_null_set)
    _LL_nil = _swig_property(_core.Model2__LL_nil_get, _core.Model2__LL_nil_set)
    _LL_constants = _swig_property(_core.Model2__LL_constants_get, _core.Model2__LL_constants_set)

    def write_runstats_note(self, comment: 'std::string const &') -> "void":
        return _core.Model2_write_runstats_note(self, comment)

    def read_runstats_notes(self) -> "std::string":
        return _core.Model2_read_runstats_notes(self)

    def start_timing(self, name: 'std::string const &') -> "void":
        return _core.Model2_start_timing(self, name)

    def finish_timing(self) -> "void":
        return _core.Model2_finish_timing(self)

    def alias_names(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.Model2_alias_names(self)

    def probability(self, params: 'etk::ndarray *'=None) -> "etk::ndarray *":
        return _core.Model2_probability(self, params)

    def _get_hessian_array(self) -> "etk::symmetric_matrix *":
        return _core.Model2__get_hessian_array(self)

    def _set_hessian_array(self, arg2: 'etk::symmetric_matrix *') -> "void":
        return _core.Model2__set_hessian_array(self, arg2)

    def _del_hessian_array(self) -> "void":
        return _core.Model2__del_hessian_array(self)

    def parameter_values(self, *args) -> "void":
        return _core.Model2_parameter_values(self, *args)

    def parameter_values_as_bytes(self) -> "PyObject *":
        return _core.Model2_parameter_values_as_bytes(self)

    def utilityca(self, *args) -> "void":
        return _core.Model2_utilityca(self, *args)

    def utilityco(self, *args) -> "void":
        return _core.Model2_utilityco(self, *args)
    utility = _swig_property(_core.Model2_utility_get, _core.Model2_utility_set)
    quantity = _swig_property(_core.Model2_quantity_get, _core.Model2_quantity_set)
    nest = _swig_property(_core.Model2_nest_get, _core.Model2_nest_set)
    link = _swig_property(_core.Model2_link_get, _core.Model2_link_set)
    samplingbias = _swig_property(_core.Model2_samplingbias_get, _core.Model2_samplingbias_set)

    def Input_Graph(self) -> "elm::ComponentGraphDNA":
        return _core.Model2_Input_Graph(self)

    def logger(self, l: 'PyObject *'=None) -> "PyObject *":
        return _core.Model2_logger(self, l)
    _string_sender_ptr = _swig_property(_core.Model2__string_sender_ptr_get, _core.Model2__string_sender_ptr_set)
    option = _swig_property(_core.Model2_option_get, _core.Model2_option_set)

    def _maximize_bhhh(self) -> "elm::runstats":
        return _core.Model2__maximize_bhhh(self)

    def loglike_null(self) -> "double":
        return _core.Model2_loglike_null(self)

    def estimate(self, *args) -> "elm::runstats":

        if self._ref_to_db is not None and self.is_provisioned()==0:
        	self.provision()
        	self.setUpMessage = "autoprovision yes (estimate)"
        	if self.logger(): self.logger().info("autoprovisioned data from database")


        return _core.Model2_estimate(self, *args)


    def estimate_tight(self, magnitude: 'double'=8) -> "elm::runstats":
        return _core.Model2_estimate_tight(self, magnitude)

    def _get_parameter(self) -> "PyObject *":
        return _core.Model2__get_parameter(self)

    def _get_nest(self) -> "PyObject *":
        return _core.Model2__get_nest(self)

    def _get_link(self) -> "PyObject *":
        return _core.Model2__get_link(self)

    def _get_utilityca(self) -> "PyObject *":
        return _core.Model2__get_utilityca(self)

    def _get_utilityco(self) -> "PyObject *":
        return _core.Model2__get_utilityco(self)

    def _get_samplingbiasca(self) -> "PyObject *":
        return _core.Model2__get_samplingbiasca(self)

    def _get_samplingbiasco(self) -> "PyObject *":
        return _core.Model2__get_samplingbiasco(self)

    def _get_logger(self) -> "PyObject *":
        return _core.Model2__get_logger(self)

    def _get_estimation_statistics(self) -> "PyObject *":
        return _core.Model2__get_estimation_statistics(self)

    def _get_estimation_run_statistics(self) -> "PyObject *":
        return _core.Model2__get_estimation_run_statistics(self)

    def _set_estimation_statistics(self, *args, **kwargs) -> "void":
        return _core.Model2__set_estimation_statistics(self, *args, **kwargs)

    def _set_estimation_run_statistics_pickle(self, dict: 'PyObject *') -> "void":
        return _core.Model2__set_estimation_run_statistics_pickle(self, dict)

    def prints(self, precision: 'unsigned int const &'=5, cell_width: 'unsigned int const &'=11) -> "std::string":
        return _core.Model2_prints(self, precision, cell_width)

    def full_report(self, precision: 'unsigned int const &'=5, cell_width: 'unsigned int const &'=11) -> "std::string":
        return _core.Model2_full_report(self, precision, cell_width)

    def __repr__(self) -> "std::string":
        return _core.Model2___repr__(self)

    def __init__(self, *args):
        this = _core.new_Model2(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

        try:
        	self._ref_to_db = args[0]
        except IndexError:
        	self._ref_to_db = None
        from .logging import easy_logging_active
        if easy_logging_active():
        	self.logger(True)
        try:
        	self._pull_graph_from_db()
        except LarchError:
        	pass
        from .util import dicta
        self.descriptions = dicta()



    __swig_destroy__ = _core.delete_Model2
    __del__ = lambda self: None

    def delete_data_fountain(self) -> "void":
        val = _core.Model2_delete_data_fountain(self)

        self._ref_to_db = None


        return val


    def change_data_fountain(self, datafile: 'Fountain') -> "void":
        return _core.Model2_change_data_fountain(self, datafile)

    def setUp(self, and_load_data: 'bool'=True) -> "void":

        if self._ref_to_db is not None and self.is_provisioned()==0 and and_load_data:
        	self.provision()
        	self.setUpMessage = "autoprovision yes (setUp)"
        	if self.logger(): self.logger().info("autoprovisioned data from database")


        return _core.Model2_setUp(self, and_load_data)


    def _pull_graph_from_db(self) -> "void":
        return _core.Model2__pull_graph_from_db(self)
    setUpMessage = _swig_property(_core.Model2_setUpMessage_get, _core.Model2_setUpMessage_set)

    def tearDown(self) -> "void":
        return _core.Model2_tearDown(self)

    def unprovision(self) -> "void":
        return _core.Model2_unprovision(self)
    title = _swig_property(_core.Model2_title_get, _core.Model2_title_set)

    def save_buffer(self) -> "std::string":
        return _core.Model2_save_buffer(self)

    def negative_d_loglike(self, *args) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_negative_d_loglike(self, *args)

    def negative_d_loglike_cached(self, *args) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_negative_d_loglike_cached(self, *args)

    def negative_d_loglike_nocache(self, *args) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_negative_d_loglike_nocache(self, *args)

    def bhhh_cached(self, *args) -> "std::shared_ptr< etk::symmetric_matrix >":
        return _core.Model2_bhhh_cached(self, *args)

    def bhhh_nocache(self, *args) -> "std::shared_ptr< etk::symmetric_matrix >":
        return _core.Model2_bhhh_nocache(self, *args)

    def bhhh(self, *args) -> "std::shared_ptr< etk::symmetric_matrix >":
        return _core.Model2_bhhh(self, *args)

    def bhhh_direction(self, *args) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_bhhh_direction(self, *args)

    def bhhh_tolerance(self, *args) -> "double":
        return _core.Model2_bhhh_tolerance(self, *args)

    def bhhh_tolerance_nocache(self, *args) -> "double":
        return _core.Model2_bhhh_tolerance_nocache(self, *args)

    def Utility(self) -> "etk::ndarray *":
        return _core.Model2_Utility(self)

    def Probability(self) -> "etk::ndarray *":
        return _core.Model2_Probability(self)

    def Cond_Prob(self) -> "etk::ndarray *":
        return _core.Model2_Cond_Prob(self)

    def Allocation(self) -> "etk::ndarray *":
        return _core.Model2_Allocation(self)

    def Quantity(self) -> "etk::ndarray *":
        return _core.Model2_Quantity(self)

    def CaseLogLike(self) -> "etk::ndarray *":
        return _core.Model2_CaseLogLike(self)

    def SamplingWeight(self) -> "etk::ndarray *":
        return _core.Model2_SamplingWeight(self)

    def AdjProbability(self) -> "etk::ndarray *":
        return _core.Model2_AdjProbability(self)

    def nAlts(self) -> "unsigned long long":
        return _core.Model2_nAlts(self)

    def nCases(self) -> "unsigned long long":
        return _core.Model2_nCases(self)

    def alternative_names(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.Model2_alternative_names(self)

    def alternative_codes(self) -> "std::vector< long long,std::allocator< long long > >":
        return _core.Model2_alternative_codes(self)

    def _compute_d2_loglike(self, *args) -> "void":
        return _core.Model2__compute_d2_loglike(self, *args)

    def teardown(self) -> "void":
        return _core.Model2_teardown(self)
Model2_swigregister = _core.Model2_swigregister
Model2_swigregister(Model2)

class autoindex_string(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def at_index(self, index: 'size_t const &') -> "std::string const &":
        return _core.autoindex_string_at_index(self, index)

    def __len__(self) -> "size_t":
        return _core.autoindex_string___len__(self)

    def clear(self) -> "void":
        return _core.autoindex_string_clear(self)

    def strings(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        return _core.autoindex_string_strings(self)

    def drop(self, codex: 'std::string const &') -> "size_t":
        return _core.autoindex_string_drop(self, codex)

    def __contains__(self, codex: 'std::string const &') -> "bool":
        return _core.autoindex_string___contains__(self, codex)

    def __init__(self, *args):
        this = _core.new_autoindex_string(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _core.delete_autoindex_string
    __del__ = lambda self: None

    def extend(self, init: 'StrVector') -> "void":
        return _core.autoindex_string_extend(self, init)

    def index_from_string(self, codex: 'std::string const &') -> "size_t":
        return _core.autoindex_string_index_from_string(self, codex)

    def string_from_index(self, index: 'size_t const &') -> "std::string":
        return _core.autoindex_string_string_from_index(self, index)

    def __getitem__(self, key):
    	if isinstance(key, int):
    		if key<len(self):
    			if key>=0:
    				return key
    			else:
    				key = len(self)+key
    				if key<0:
    					raise IndexError()
    				return key
    		else:
    			raise IndexError()
    	elif isinstance(key, str):
    		return self.index_from_string(key)
    	elif isinstance(key, bytes):
    		return self.index_from_string(key.decode('utf8'))
    def __repr__(self):
    	return "larch.core.autoindex_string(" + repr(self.strings()) + ")"

autoindex_string_swigregister = _core.autoindex_string_swigregister
autoindex_string_swigregister(autoindex_string)

class ModelParameter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _core.new_ModelParameter(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _core.delete_ModelParameter
    __del__ = lambda self: None

    def _get_value(self) -> "double":
        return _core.ModelParameter__get_value(self)

    def _set_value(self, value: 'double const &') -> "void":
        return _core.ModelParameter__set_value(self, value)

    def _get_min(self) -> "double":
        return _core.ModelParameter__get_min(self)

    def _set_min(self, value: 'double const &') -> "void":
        return _core.ModelParameter__set_min(self, value)

    def _del_min(self) -> "void":
        return _core.ModelParameter__del_min(self)

    def _get_max(self) -> "double":
        return _core.ModelParameter__get_max(self)

    def _set_max(self, value: 'double const &') -> "void":
        return _core.ModelParameter__set_max(self, value)

    def _del_max(self) -> "void":
        return _core.ModelParameter__del_max(self)

    def _get_std_err(self) -> "double":
        return _core.ModelParameter__get_std_err(self)

    def _get_t_stat(self) -> "double":
        return _core.ModelParameter__get_t_stat(self)

    def _get_robust_std_err(self) -> "double":
        return _core.ModelParameter__get_robust_std_err(self)

    def _get_name(self) -> "std::string":
        return _core.ModelParameter__get_name(self)

    def _get_holdfast(self) -> "signed char":
        return _core.ModelParameter__get_holdfast(self)

    def _set_holdfast(self, *args) -> "void":
        return _core.ModelParameter__set_holdfast(self, *args)

    def _del_holdfast(self) -> "void":
        return _core.ModelParameter__del_holdfast(self)

    def _get_nullvalue(self) -> "double":
        return _core.ModelParameter__get_nullvalue(self)

    def _set_nullvalue(self, value: 'double const &') -> "void":
        return _core.ModelParameter__set_nullvalue(self, value)

    def _get_initvalue(self) -> "double":
        return _core.ModelParameter__get_initvalue(self)

    def _set_initvalue(self, value: 'double const &') -> "void":
        return _core.ModelParameter__set_initvalue(self, value)

    def _get_index(self) -> "size_t":
        return _core.ModelParameter__get_index(self)

    def _get_complete_covariance_matrix(self) -> "etk::symmetric_matrix *":
        return _core.ModelParameter__get_complete_covariance_matrix(self)

    def _get_model(self) -> "PyObject *":
        return _core.ModelParameter__get_model(self)

    value = property(_get_value, _set_value)
    null_value = property(_get_nullvalue, _set_nullvalue)
    initial_value = property(_get_initvalue, _set_initvalue)
    minimum = property(_get_min, _set_min, _del_min)
    min_value = minimum
    maximum = property(_get_max, _set_max, _del_max)
    max_value = maximum
    holdfast = property(_get_holdfast, _set_holdfast, _del_holdfast)
    std_err = property(_get_std_err, None, None, "the standard error of the estimator")
    robust_std_err = property(_get_robust_std_err, None, None, "the robust standard error of the estimator via bhhh sandwich")
    name = property(_get_name, None, None, "the parameter name")
    index = property(_get_index, None, None, "the parameter index within the model")
    t_stat = property(_get_t_stat, None, None, "the t-statistic for the estimator")
    def __repr__(self):
    	return "ModelParameter('{}', value={})".format(self.name, self.value)
    @property
    def covariance(self):
    	slot = self.index
    	cov = self._get_complete_covariance_matrix()
    	model = self._get_model()
    	ret = {}
    	for name, val in zip(model.parameter_names(), cov[:,slot]):
    		ret[name] = val
    	return ret
    @property
    def robust_covariance(self):
    	slot = self.index
    	model = self._get_model()
    	cov = model.robust_covariance_matrix
    	ret = {}
    	for name, val in zip(model.parameter_names(), cov[:,slot]):
    		ret[name] = val
    	return ret

ModelParameter_swigregister = _core.ModelParameter_swigregister
ModelParameter_swigregister(ModelParameter)


from .model import Model



